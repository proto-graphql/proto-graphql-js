// @generated by protoc-gen-pothos v0.7.0 with parameter "import_prefix=@proto-graphql/e2e-testapis-protobuf-es-v2/lib/,pothos_builder_path=../builder,protobuf_lib=protobuf-es"
// @generated from file testapis/options/message_and_field/message_and_field.proto (package testapis.options.message_and_field, syntax proto3)
/* eslint-disable */

import { builder } from "../../../../builder";
import { create, isMessage, MessageShape } from "@bufbuild/protobuf";
import {
  EnumWillRename,
  IgnoredMessage_NotIgnored,
  IgnoredMessage_NotIgnoredSchema,
  InterfaceMessage,
  InterfaceMessage_Type,
  InterfaceMessageSchema,
  MessageOnlyOutputSchema,
  MessageWillRename,
  MessageWillRenameSchema,
  PrefixedEnum,
  PrefixedMessage,
  PrefixedMessage_InnerMessage,
  PrefixedMessage_InnerMessage2,
  PrefixedMessage_InnerMessage2Schema,
  PrefixedMessage_InnerMessageSchema,
  PrefixedMessage_SquashedMessage,
  PrefixedMessage_SquashedMessageSchema,
  PrefixedMessageSchema,
} from "@proto-graphql/e2e-testapis-protobuf-es-v2/lib/testapis/options/message_and_field/message_and_field_pb";
import { EnumRef, InputObjectRef } from "@pothos/core";

export const PrefixedMessage$Ref = builder.objectRef<
  MessageShape<typeof PrefixedMessageSchema>
>("PrefixedMessage");
builder.objectType(PrefixedMessage$Ref, {
  name: "PrefixedMessage",
  fields: (t) => ({
    id: t.expose("id", {
      type: "Int64",
      nullable: false,
      extensions: {
        protobufField: {
          name: "id",
          typeFullName: "uint64",
          options: { "[graphql.field]": { id: true } },
        },
      },
    }),
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
    prefixedEnum: t.field({
      type: PrefixedEnum$Ref,
      nullable: true,
      resolve: (source) => {
        if (source.prefixedEnum === PrefixedEnum.PREFIXED_ENUM_UNSPECIFIED) {
          return null;
        }

        if (source.prefixedEnum === PrefixedEnum.PREFIXED_IGNORED) {
          throw new Error("PREFIXED_IGNORED is ignored in GraphQL schema");
        }

        return source.prefixedEnum;
      },
      extensions: {
        protobufField: {
          name: "prefixed_enum",
          typeFullName: "testapis.options.message_and_field.PrefixedEnum",
        },
      },
    }),
    thisFieldWasRenamed: t.expose("thisFieldWillBeRenamed", {
      type: "String",
      nullable: false,
      extensions: {
        protobufField: {
          name: "this_field_will_be_renamed",
          typeFullName: "string",
          options: { "[graphql.field]": { name: "thisFieldWasRenamed" } },
        },
      },
    }),
    skipResolver: t.expose("skipResolver", {
      type: "String",
      nullable: false,
      extensions: {
        protobufField: {
          name: "skip_resolver",
          typeFullName: "string",
          options: { "[graphql.field]": { skipResolver: true } },
        },
      },
    }),
    squashedMessage: t.field({
      type: PrefixedMessageSquashedMessage$Ref,
      nullable: true,
      resolve: (source) => {
        return (source.squashedMessage?.squashedMessage.value ?? null) as
          | PrefixedMessage_InnerMessage
          | PrefixedMessage_InnerMessage2
          | undefined
          | null;
      },
      extensions: {
        protobufField: {
          name: "squashed_message",
          typeFullName:
            "testapis.options.message_and_field.PrefixedMessage.SquashedMessage",
        },
      },
    }),
    renamedMessage: t.expose("renamedMessage", {
      type: RenamedMessage$Ref,
      nullable: true,
      extensions: {
        protobufField: {
          name: "renamed_message",
          typeFullName: "testapis.options.message_and_field.MessageWillRename",
        },
      },
    }),
    renamedEnum: t.field({
      type: RenamedEnum$Ref,
      nullable: true,
      resolve: (source) => {
        if (source.renamedEnum === EnumWillRename.UNSPECIFIED) {
          return null;
        }

        return source.renamedEnum;
      },
      extensions: {
        protobufField: {
          name: "renamed_enum",
          typeFullName: "testapis.options.message_and_field.EnumWillRename",
        },
      },
    }),
    notIgnoredMessage: t.expose("notIgnoredMessage", {
      type: IgnoredMessageNotIgnored$Ref,
      nullable: true,
      extensions: {
        protobufField: {
          name: "not_ignored_message",
          typeFullName:
            "testapis.options.message_and_field.IgnoredMessage.NotIgnored",
        },
      },
    }),
    squashedMessages: t.field({
      type: [PrefixedMessageSquashedMessage$Ref],
      nullable: { list: true, items: false },
      resolve: (source) => {
        return source.squashedMessages.map((item) => {
          const value = item.squashedMessage.value as
            | PrefixedMessage_InnerMessage
            | PrefixedMessage_InnerMessage2
            | undefined;
          if (value == null) {
            throw new Error("squashedMessages should not be null");
          }
          return value;
        });
      },
      extensions: {
        protobufField: {
          name: "squashed_messages",
          typeFullName:
            "testapis.options.message_and_field.PrefixedMessage.SquashedMessage",
        },
      },
    }),
    partialIgnoreOneof: t.field({
      type: PrefixedMessagePartialIgnoreOneof$Ref,
      nullable: true,
      resolve: (source) => {
        return (source.partialIgnoreOneof.value ?? null) as
          | PrefixedMessage_InnerMessage
          | undefined
          | null;
      },
      extensions: { protobufField: { name: "partial_ignore_oneof" } },
    }),
  }),
  isTypeOf: (source) => {
    return isMessage(source, PrefixedMessageSchema);
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.options.message_and_field.PrefixedMessage",
      name: "PrefixedMessage",
      package: "testapis.options.message_and_field",
    },
  },
});

export const RenamedMessage$Ref = builder.objectRef<
  MessageShape<typeof MessageWillRenameSchema>
>("RenamedMessage");
builder.objectType(RenamedMessage$Ref, {
  name: "RenamedMessage",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return isMessage(source, MessageWillRenameSchema);
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.options.message_and_field.MessageWillRename",
      name: "MessageWillRename",
      package: "testapis.options.message_and_field",
      options: { "[graphql.object_type]": { name: "RenamedMessage" } },
    },
  },
});

export const MessageOnlyOutput$Ref = builder.objectRef<
  MessageShape<typeof MessageOnlyOutputSchema>
>("MessageOnlyOutput");
builder.objectType(MessageOnlyOutput$Ref, {
  name: "MessageOnlyOutput",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return isMessage(source, MessageOnlyOutputSchema);
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.options.message_and_field.MessageOnlyOutput",
      name: "MessageOnlyOutput",
      package: "testapis.options.message_and_field",
      options: { "[graphql.input_type]": { ignore: true } },
    },
  },
});

export const PrefixedMessageInnerMessage$Ref = builder.objectRef<
  MessageShape<typeof PrefixedMessage_InnerMessageSchema>
>("PrefixedMessageInnerMessage");
builder.objectType(PrefixedMessageInnerMessage$Ref, {
  name: "PrefixedMessageInnerMessage",
  fields: (t) => ({
    id: t.expose("id", {
      type: "Int64",
      nullable: false,
      extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
    }),
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return isMessage(source, PrefixedMessage_InnerMessageSchema);
  },
  extensions: {
    protobufMessage: {
      fullName:
        "testapis.options.message_and_field.PrefixedMessage.InnerMessage",
      name: "InnerMessage",
      package: "testapis.options.message_and_field",
    },
  },
});

export const PrefixedMessageInnerMessage2$Ref = builder.objectRef<
  MessageShape<typeof PrefixedMessage_InnerMessage2Schema>
>("PrefixedMessageInnerMessage2");
builder.objectType(PrefixedMessageInnerMessage2$Ref, {
  name: "PrefixedMessageInnerMessage2",
  fields: (t) => ({
    id: t.expose("id", {
      type: "Int64",
      nullable: false,
      extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
    }),
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return isMessage(source, PrefixedMessage_InnerMessage2Schema);
  },
  extensions: {
    protobufMessage: {
      fullName:
        "testapis.options.message_and_field.PrefixedMessage.InnerMessage2",
      name: "InnerMessage2",
      package: "testapis.options.message_and_field",
    },
  },
});

export const IgnoredMessageNotIgnored$Ref = builder.objectRef<
  MessageShape<typeof IgnoredMessage_NotIgnoredSchema>
>("IgnoredMessageNotIgnored");
builder.objectType(IgnoredMessageNotIgnored$Ref, {
  name: "IgnoredMessageNotIgnored",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return isMessage(source, IgnoredMessage_NotIgnoredSchema);
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.options.message_and_field.IgnoredMessage.NotIgnored",
      name: "NotIgnored",
      package: "testapis.options.message_and_field",
    },
  },
});

export type PrefixedMessageInput$Shape = {
  id: PrefixedMessage["id"];
  body: PrefixedMessage["body"];
  prefixedEnum?: PrefixedMessage["prefixedEnum"] | null;
  thisFieldWasRenamed: PrefixedMessage["thisFieldWillBeRenamed"];
  skipResolver: PrefixedMessage["skipResolver"];
  squashedMessage?: PrefixedMessageSquashedMessageInput$Shape | null;
  renamedMessage?: RenamedMessageInput$Shape | null;
  renamedEnum?: PrefixedMessage["renamedEnum"] | null;
  notIgnoredMessage?: IgnoredMessageNotIgnoredInput$Shape | null;
  oneofNotIgnoredField?: PrefixedMessageInnerMessageInput$Shape | null;
  squashedMessages?: Array<PrefixedMessageSquashedMessageInput$Shape> | null;
};

export const PrefixedMessageInput$Ref: InputObjectRef<
  PrefixedMessageInput$Shape
> = builder.inputRef<PrefixedMessageInput$Shape>("PrefixedMessageInput")
  .implement({
    fields: (t) => ({
      id: t.field({
        type: "Int64",
        required: true,
        extensions: {
          protobufField: {
            name: "id",
            typeFullName: "uint64",
            options: { "[graphql.field]": { id: true } },
          },
        },
      }),
      body: t.field({
        type: "String",
        required: true,
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
      prefixedEnum: t.field({
        type: PrefixedEnum$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "prefixed_enum",
            typeFullName: "testapis.options.message_and_field.PrefixedEnum",
          },
        },
      }),
      thisFieldWasRenamed: t.field({
        type: "String",
        required: true,
        extensions: {
          protobufField: {
            name: "this_field_will_be_renamed",
            typeFullName: "string",
            options: { "[graphql.field]": { name: "thisFieldWasRenamed" } },
          },
        },
      }),
      skipResolver: t.field({
        type: "String",
        required: true,
        extensions: {
          protobufField: {
            name: "skip_resolver",
            typeFullName: "string",
            options: { "[graphql.field]": { skipResolver: true } },
          },
        },
      }),
      squashedMessage: t.field({
        type: PrefixedMessageSquashedMessageInput$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "squashed_message",
            typeFullName:
              "testapis.options.message_and_field.PrefixedMessage.SquashedMessage",
          },
        },
      }),
      renamedMessage: t.field({
        type: RenamedMessageInput$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "renamed_message",
            typeFullName:
              "testapis.options.message_and_field.MessageWillRename",
          },
        },
      }),
      renamedEnum: t.field({
        type: RenamedEnum$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "renamed_enum",
            typeFullName: "testapis.options.message_and_field.EnumWillRename",
          },
        },
      }),
      notIgnoredMessage: t.field({
        type: IgnoredMessageNotIgnoredInput$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "not_ignored_message",
            typeFullName:
              "testapis.options.message_and_field.IgnoredMessage.NotIgnored",
          },
        },
      }),
      oneofNotIgnoredField: t.field({
        type: PrefixedMessageInnerMessageInput$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "oneof_not_ignored_field",
            typeFullName:
              "testapis.options.message_and_field.PrefixedMessage.InnerMessage",
          },
        },
      }),
      squashedMessages: t.field({
        type: [PrefixedMessageSquashedMessageInput$Ref],
        required: { list: false, items: true },
        extensions: {
          protobufField: {
            name: "squashed_messages",
            typeFullName:
              "testapis.options.message_and_field.PrefixedMessage.SquashedMessage",
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.options.message_and_field.PrefixedMessage",
        name: "PrefixedMessage",
        package: "testapis.options.message_and_field",
      },
    },
  }) as InputObjectRef<PrefixedMessageInput$Shape>;

export function PrefixedMessageInput$toProto(
  input: PrefixedMessageInput$Shape | null | undefined,
): PrefixedMessage {
  return create(PrefixedMessageSchema, {
    id: input?.id ?? undefined,
    body: input?.body ?? undefined,
    prefixedEnum: input?.prefixedEnum ?? undefined,
    thisFieldWillBeRenamed: input?.thisFieldWasRenamed ?? undefined,
    skipResolver: input?.skipResolver ?? undefined,
    squashedMessage: input?.squashedMessage
      ? PrefixedMessageSquashedMessageInput$toProto(input.squashedMessage)
      : undefined,
    renamedMessage: input?.renamedMessage
      ? RenamedMessageInput$toProto(input.renamedMessage)
      : undefined,
    renamedEnum: input?.renamedEnum ?? undefined,
    notIgnoredMessage: input?.notIgnoredMessage
      ? IgnoredMessageNotIgnoredInput$toProto(input.notIgnoredMessage)
      : undefined,
    squashedMessages: input?.squashedMessages?.map((v) =>
      PrefixedMessageSquashedMessageInput$toProto(v)
    ),
    partialIgnoreOneof: input?.oneofNotIgnoredField
      ? {
        case: "oneofNotIgnoredField",
        value: PrefixedMessageInnerMessageInput$toProto(
          input.oneofNotIgnoredField,
        ),
      }
      : undefined,
  });
}

export type RenamedMessageInput$Shape = { body: MessageWillRename["body"]; };

export const RenamedMessageInput$Ref: InputObjectRef<
  RenamedMessageInput$Shape
> = builder.inputRef<RenamedMessageInput$Shape>("RenamedMessageInput")
  .implement({
    fields: (t) => ({
      body: t.field({
        type: "String",
        required: true,
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.options.message_and_field.MessageWillRename",
        name: "MessageWillRename",
        package: "testapis.options.message_and_field",
        options: { "[graphql.object_type]": { name: "RenamedMessage" } },
      },
    },
  }) as InputObjectRef<RenamedMessageInput$Shape>;

export function RenamedMessageInput$toProto(
  input: RenamedMessageInput$Shape | null | undefined,
): MessageWillRename {
  return create(MessageWillRenameSchema, { body: input?.body ?? undefined });
}

export type InterfaceMessageInput$Shape = { id: InterfaceMessage["id"]; };

export const InterfaceMessageInput$Ref: InputObjectRef<
  InterfaceMessageInput$Shape
> = builder.inputRef<InterfaceMessageInput$Shape>("InterfaceMessageInput")
  .implement({
    fields: (t) => ({
      id: t.field({
        type: "Int64",
        required: true,
        extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.options.message_and_field.InterfaceMessage",
        name: "InterfaceMessage",
        package: "testapis.options.message_and_field",
        options: { "[graphql.object_type]": { interface: true } },
      },
    },
  }) as InputObjectRef<InterfaceMessageInput$Shape>;

export function InterfaceMessageInput$toProto(
  input: InterfaceMessageInput$Shape | null | undefined,
): InterfaceMessage {
  return create(InterfaceMessageSchema, { id: input?.id ?? undefined });
}

export type PrefixedMessageInnerMessageInput$Shape = {
  id: PrefixedMessage_InnerMessage["id"];
  body: PrefixedMessage_InnerMessage["body"];
};

export const PrefixedMessageInnerMessageInput$Ref: InputObjectRef<
  PrefixedMessageInnerMessageInput$Shape
> = builder.inputRef<PrefixedMessageInnerMessageInput$Shape>(
  "PrefixedMessageInnerMessageInput",
).implement({
  fields: (t) => ({
    id: t.field({
      type: "Int64",
      required: true,
      extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
    }),
    body: t.field({
      type: "String",
      required: true,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName:
        "testapis.options.message_and_field.PrefixedMessage.InnerMessage",
      name: "InnerMessage",
      package: "testapis.options.message_and_field",
    },
  },
}) as InputObjectRef<PrefixedMessageInnerMessageInput$Shape>;

export function PrefixedMessageInnerMessageInput$toProto(
  input: PrefixedMessageInnerMessageInput$Shape | null | undefined,
): PrefixedMessage_InnerMessage {
  return create(PrefixedMessage_InnerMessageSchema, {
    id: input?.id ?? undefined,
    body: input?.body ?? undefined,
  });
}

export type PrefixedMessageInnerMessage2Input$Shape = {
  id: PrefixedMessage_InnerMessage2["id"];
  body: PrefixedMessage_InnerMessage2["body"];
};

export const PrefixedMessageInnerMessage2Input$Ref: InputObjectRef<
  PrefixedMessageInnerMessage2Input$Shape
> = builder.inputRef<PrefixedMessageInnerMessage2Input$Shape>(
  "PrefixedMessageInnerMessage2Input",
).implement({
  fields: (t) => ({
    id: t.field({
      type: "Int64",
      required: true,
      extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
    }),
    body: t.field({
      type: "String",
      required: true,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName:
        "testapis.options.message_and_field.PrefixedMessage.InnerMessage2",
      name: "InnerMessage2",
      package: "testapis.options.message_and_field",
    },
  },
}) as InputObjectRef<PrefixedMessageInnerMessage2Input$Shape>;

export function PrefixedMessageInnerMessage2Input$toProto(
  input: PrefixedMessageInnerMessage2Input$Shape | null | undefined,
): PrefixedMessage_InnerMessage2 {
  return create(PrefixedMessage_InnerMessage2Schema, {
    id: input?.id ?? undefined,
    body: input?.body ?? undefined,
  });
}

export type PrefixedMessageSquashedMessageInput$Shape = {
  oneofField?: PrefixedMessageInnerMessageInput$Shape | null;
  oneofField2?: PrefixedMessageInnerMessage2Input$Shape | null;
};

export const PrefixedMessageSquashedMessageInput$Ref: InputObjectRef<
  PrefixedMessageSquashedMessageInput$Shape
> = builder.inputRef<PrefixedMessageSquashedMessageInput$Shape>(
  "PrefixedMessageSquashedMessageInput",
).implement({
  fields: (t) => ({
    oneofField: t.field({
      type: PrefixedMessageInnerMessageInput$Ref,
      required: false,
      extensions: {
        protobufField: {
          name: "oneof_field",
          typeFullName:
            "testapis.options.message_and_field.PrefixedMessage.InnerMessage",
        },
      },
    }),
    oneofField2: t.field({
      type: PrefixedMessageInnerMessage2Input$Ref,
      required: false,
      extensions: {
        protobufField: {
          name: "oneof_field_2",
          typeFullName:
            "testapis.options.message_and_field.PrefixedMessage.InnerMessage2",
        },
      },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName:
        "testapis.options.message_and_field.PrefixedMessage.SquashedMessage",
      name: "SquashedMessage",
      package: "testapis.options.message_and_field",
      options: { "[graphql.object_type]": { squashUnion: true } },
    },
  },
}) as InputObjectRef<PrefixedMessageSquashedMessageInput$Shape>;

export function PrefixedMessageSquashedMessageInput$toProto(
  input: PrefixedMessageSquashedMessageInput$Shape | null | undefined,
): PrefixedMessage_SquashedMessage {
  return create(PrefixedMessage_SquashedMessageSchema, {
    squashedMessage: input?.oneofField
      ? {
        case: "oneofField",
        value: PrefixedMessageInnerMessageInput$toProto(input.oneofField),
      }
      : input?.oneofField2
      ? {
        case: "oneofField2",
        value: PrefixedMessageInnerMessage2Input$toProto(input.oneofField2),
      }
      : undefined,
  });
}

export type IgnoredMessageNotIgnoredInput$Shape = {
  body: IgnoredMessage_NotIgnored["body"];
};

export const IgnoredMessageNotIgnoredInput$Ref: InputObjectRef<
  IgnoredMessageNotIgnoredInput$Shape
> = builder.inputRef<IgnoredMessageNotIgnoredInput$Shape>(
  "IgnoredMessageNotIgnoredInput",
).implement({
  fields: (t) => ({
    body: t.field({
      type: "String",
      required: true,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName: "testapis.options.message_and_field.IgnoredMessage.NotIgnored",
      name: "NotIgnored",
      package: "testapis.options.message_and_field",
    },
  },
}) as InputObjectRef<IgnoredMessageNotIgnoredInput$Shape>;

export function IgnoredMessageNotIgnoredInput$toProto(
  input: IgnoredMessageNotIgnoredInput$Shape | null | undefined,
): IgnoredMessage_NotIgnored {
  return create(IgnoredMessage_NotIgnoredSchema, {
    body: input?.body ?? undefined,
  });
}

export const InterfaceMessage$Ref = builder.interfaceRef<
  Pick<MessageShape<typeof InterfaceMessageSchema>, "id">
>("InterfaceMessage");
builder.interfaceType(InterfaceMessage$Ref, {
  name: "InterfaceMessage",
  fields: (t) => ({
    id: t.expose("id", {
      type: "Int64",
      nullable: false,
      extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName: "testapis.options.message_and_field.InterfaceMessage",
      name: "InterfaceMessage",
      package: "testapis.options.message_and_field",
      options: { "[graphql.object_type]": { interface: true } },
    },
  },
});

export const PrefixedMessageSquashedMessage$Ref = builder.unionType(
  "PrefixedMessageSquashedMessage",
  {
    types: [PrefixedMessageInnerMessage$Ref, PrefixedMessageInnerMessage2$Ref],
    extensions: {
      protobufOneof: {
        fullName:
          "testapis.options.message_and_field.PrefixedMessage.SquashedMessage",
        name: "SquashedMessage",
        package: "testapis.options.message_and_field",
        fields: [{
          name: "oneof_field",
          type:
            "testapis.options.message_and_field.PrefixedMessage.InnerMessage",
          options: { "[graphql.object_type]": { squashUnion: true } },
        }, {
          name: "oneof_field_2",
          type:
            "testapis.options.message_and_field.PrefixedMessage.InnerMessage2",
          options: { "[graphql.object_type]": { squashUnion: true } },
        }],
      },
    },
  },
);

export const PrefixedMessagePartialIgnoreOneof$Ref = builder.unionType(
  "PrefixedMessagePartialIgnoreOneof",
  {
    types: [PrefixedMessageInnerMessage$Ref],
    extensions: {
      protobufOneof: {
        fullName:
          "testapis.options.message_and_field.PrefixedMessage.partial_ignore_oneof",
        name: "partial_ignore_oneof",
        messageName: "PrefixedMessage",
        package: "testapis.options.message_and_field",
        fields: [{
          name: "oneof_not_ignored_field",
          type:
            "testapis.options.message_and_field.PrefixedMessage.InnerMessage",
        }],
      },
    },
  },
);

export const RenamedEnum$Ref: EnumRef<EnumWillRename, EnumWillRename> = builder
  .enumType("RenamedEnum", {
    values: {
      FOO: {
        value: 1,
        extensions: { protobufEnumValue: { name: "ENUM_WILL_RENAME_FOO" } },
      },
      BAR: {
        value: 2,
        extensions: { protobufEnumValue: { name: "ENUM_WILL_RENAME_BAR" } },
      },
    } as const,
    extensions: {
      protobufEnum: {
        name: "EnumWillRename",
        fullName: "testapis.options.message_and_field.EnumWillRename",
        package: "testapis.options.message_and_field",
        options: { "[graphql.enum_type]": { name: "RenamedEnum" } },
      },
    },
  });

export const PrefixedEnum$Ref: EnumRef<PrefixedEnum, PrefixedEnum> = builder
  .enumType("PrefixedEnum", {
    values: {
      PREFIXED_FOO: {
        value: 1,
        extensions: { protobufEnumValue: { name: "PREFIXED_FOO" } },
      },
      PREFIXED_BAR: {
        value: 2,
        extensions: { protobufEnumValue: { name: "PREFIXED_BAR" } },
      },
    } as const,
    extensions: {
      protobufEnum: {
        name: "PrefixedEnum",
        fullName: "testapis.options.message_and_field.PrefixedEnum",
        package: "testapis.options.message_and_field",
      },
    },
  });

export const InterfaceMessageType$Ref: EnumRef<
  InterfaceMessage_Type,
  InterfaceMessage_Type
> = builder.enumType("InterfaceMessageType", {
  values: {
    INNER: { value: 1, extensions: { protobufEnumValue: { name: "INNER" } } },
    INNER2: { value: 2, extensions: { protobufEnumValue: { name: "INNER2" } } },
  } as const,
  extensions: {
    protobufEnum: {
      name: "Type",
      fullName: "testapis.options.message_and_field.InterfaceMessage.Type",
      package: "testapis.options.message_and_field",
    },
  },
});
