# Generated Code Reference

Detailed reference for the TypeScript code generated by protoc-gen-pothos.

## File Structure

For each `.proto` file, the plugin generates a `.pb.pothos.ts` file containing:

```
proto/example/user.proto
    â†“
src/__generated__/example/user.pb.pothos.ts
```

Each generated file includes:
1. Import statements
2. Object type definitions (`$Ref`)
3. Input type definitions (`$Shape`, `$Ref`)
4. Enum type definitions
5. Union type definitions (for oneofs)
6. Helper functions (protobuf-es only: `$toProto`)

## Naming Conventions

### Export Identifiers

| Proto Definition | Generated Export | Type |
|------------------|------------------|------|
| `message User` | `User$Ref` | `ObjectRef<User>` |
| `message User` (input) | `UserInput$Shape` | Type alias |
| `message User` (input) | `UserInput$Ref` | `InputObjectRef<UserInput$Shape>` |
| `message User` (partial) | `UserPartialInput$Shape` | Type alias |
| `message User` (partial) | `UserPartialInput$Ref` | `InputObjectRef<...>` |
| `enum Role` | `Role$Ref` | `EnumRef<Role, Role>` |
| `oneof content` in `Media` | `MediaContent$Ref` | Union type |
| `message User` (protobuf-es) | `UserInput$toProto` | Function |

### Nested Messages

Nested messages use underscore-separated naming:

```protobuf
message User {
  message Address {
    string city = 1;
  }
}
```

Generated exports:
- `UserAddress$Ref`
- `UserAddressInput$Shape`
- `UserAddressInput$Ref`

## Object Type Generation

### Basic Object Type

```protobuf
message Date {
  uint32 year = 1;
  uint32 month = 2;
  uint32 day = 3;
}
```

```typescript
export const Date$Ref = builder.objectRef<Date>("Date");
builder.objectType(Date$Ref, {
  name: "Date",
  fields: (t) => ({
    year: t.expose("year", {
      type: "Int",
      nullable: false,
      extensions: { protobufField: { name: "year", typeFullName: "uint32" } },
    }),
    month: t.expose("month", {
      type: "Int",
      nullable: false,
      extensions: { protobufField: { name: "month", typeFullName: "uint32" } },
    }),
    day: t.expose("day", {
      type: "Int",
      nullable: false,
      extensions: { protobufField: { name: "day", typeFullName: "uint32" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as Date | { $type: string & {}; }).$type ===
      "testapis.custom_types.Date";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.custom_types.Date",
      name: "Date",
      package: "testapis.custom_types",
    },
  },
});
```

### Field Methods

| Method | Usage |
|--------|-------|
| `t.expose()` | Direct field exposure without resolver |
| `t.field()` | Field with custom resolver |

`t.expose()` is used when the field value can be accessed directly from the source object.

`t.field()` is used when:
- Custom resolver logic is required
- Type conversion is needed (e.g., `bytes` to `Buffer`)
- Enum unspecified value handling

### isTypeOf Implementation

The `isTypeOf` function enables union type resolution:

**ts-proto:**
```typescript
isTypeOf: (source) => {
  return (source as Message | { $type: string & {}; }).$type ===
    "package.name.MessageName";
}
```

**protobuf-es:**
```typescript
isTypeOf: (source) => {
  return source instanceof MessageClass;
}
```

## Input Type Generation

### Basic Input Type

```typescript
export type DateInput$Shape = {
  year: Date["year"];
  month: Date["month"];
  day: Date["day"];
};

export const DateInput$Ref: InputObjectRef<DateInput$Shape> = builder.inputRef<
  DateInput$Shape
>("DateInput").implement({
  fields: (t) => ({
    year: t.field({
      type: "Int",
      required: true,
      extensions: { protobufField: { name: "year", typeFullName: "uint32" } },
    }),
    month: t.field({
      type: "Int",
      required: true,
      extensions: { protobufField: { name: "month", typeFullName: "uint32" } },
    }),
    day: t.field({
      type: "Int",
      required: true,
      extensions: { protobufField: { name: "day", typeFullName: "uint32" } },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName: "testapis.custom_types.Date",
      name: "Date",
      package: "testapis.custom_types",
    },
  },
});
```

### Shape Type

The `$Shape` type alias derives field types from the protobuf message type:

```typescript
export type PostInput$Shape = {
  title: Post["title"];                    // Required field
  publishedDate?: DateInput$Shape | null;  // Optional nested message
};
```

### Partial Input Type

When `partial_inputs=true` is configured:

```typescript
export type DatePartialInput$Shape = {
  year?: Date["year"] | null;
  month?: Date["month"] | null;
  day?: Date["day"] | null;
};

export const DatePartialInput$Ref: InputObjectRef<DatePartialInput$Shape> =
  builder.inputRef<DatePartialInput$Shape>("DatePartialInput").implement({
    fields: (t) => ({
      year: t.field({
        type: "Int",
        required: false,  // All fields optional
        extensions: { protobufField: { name: "year", typeFullName: "uint32" } },
      }),
      // ...
    }),
    // ...
  });
```

## Enum Type Generation

### Basic Enum

```protobuf
enum NotDeprecatedEnum {
  NOT_DEPRECATED_ENUM_UNSPECIFIED = 0;
  NOT_DEPRECATED_FOO = 1;
  DEPRECATED_BAR = 2 [deprecated = true];
}
```

```typescript
export const NotDeprecatedEnum$Ref: EnumRef<
  NotDeprecatedEnum,
  NotDeprecatedEnum
> = builder.enumType("NotDeprecatedEnum", {
  values: {
    NOT_DEPRECATED_FOO: {
      value: 1,
      extensions: { protobufEnumValue: { name: "NOT_DEPRECATED_FOO" } },
    },
    DEPRECATED_BAR: {
      deprecationReason:
        "testapis.deprecation.NotDeprecatedEnum.DEPRECATED_BAR is mark as deprecated in a *.proto file.",
      value: 2,
      extensions: {
        protobufEnumValue: {
          name: "DEPRECATED_BAR",
          options: { deprecated: true },
        },
      },
    },
  } as const,
  extensions: {
    protobufEnum: {
      name: "NotDeprecatedEnum",
      fullName: "testapis.deprecation.NotDeprecatedEnum",
      package: "testapis.deprecation",
    },
  },
});
```

### UNSPECIFIED Value Handling

Values matching `<ENUM_NAME>_UNSPECIFIED` at position 0 are excluded from GraphQL enum values.

When a field references an enum with an unspecified value, a resolver is generated:

```typescript
role: t.field({
  type: MyEnum$Ref,
  nullable: false,
  resolve: (source) => {
    if (source.role === MyEnum.MY_ENUM_UNSPECIFIED) {
      throw new Error("role is required field. But got unspecified.");
    }
    return source.role;
  },
}),
```

## Union Type Generation (Oneofs)

### Basic Union

```protobuf
message NotDeprecatedMessage {
  oneof not_deprecated_oneof {
    InnerMessage1 msg1 = 1;
    InnerMessage2 msg2 = 2;
  }
}
```

```typescript
export const NotDeprecatedMessageNotDeprecatedOneof$Ref = builder.unionType(
  "NotDeprecatedMessageNotDeprecatedOneof",
  {
    types: [
      NotDeprecatedMessageInnerMessage1$Ref,
      NotDeprecatedMessageInnerMessage2$Ref,
    ],
    extensions: {
      protobufOneof: {
        fullName:
          "testapis.deprecation.NotDeprecatedMessage.not_deprecated_oneof",
        name: "not_deprecated_oneof",
        messageName: "NotDeprecatedMessage",
        package: "testapis.deprecation",
        fields: [{
          name: "msg1",
          type: "testapis.deprecation.NotDeprecatedMessage.InnerMessage1",
        }, {
          name: "msg2",
          type: "testapis.deprecation.NotDeprecatedMessage.InnerMessage2",
        }],
      },
    },
  },
);
```

### Oneof Field Resolver

**ts-proto:**
```typescript
content: t.field({
  type: MediaContent$Ref,
  nullable: true,
  resolve: (source) => {
    return source.image ?? source.video ?? null;
  },
}),
```

**protobuf-es:**
```typescript
content: t.field({
  type: MediaContent$Ref,
  nullable: true,
  resolve: (source) => {
    return source.content.value ?? null;
  },
}),
```

### Required Oneof

When marked with `// Required.`:

```typescript
content: t.field({
  type: MediaContent$Ref,
  nullable: false,
  resolve: (source) => {
    const value = source.image ?? source.video;
    if (value == null) {
      throw new Error("content should not be null");
    }
    return value;
  },
}),
```

## Field Resolver Patterns

### Bytes Field

Bytes fields require `Buffer` conversion:

```typescript
data: t.field({
  type: "Byte",
  nullable: true,
  resolve: (source) => {
    return source.data == null ? null : Buffer.from(source.data);
  },
}),
```

### Repeated Bytes Field

```typescript
dataList: t.field({
  type: ["Byte"],
  nullable: false,
  resolve: (source) => {
    return source.dataList.map((v) => Buffer.from(v));
  },
}),
```

### Nested Message Field

```typescript
publishedDate: t.expose("publishedDate", {
  type: Date$Ref,
  nullable: true,
  description: "Optional.",
  extensions: {
    protobufField: {
      name: "published_date",
      typeFullName: "testapis.custom_types.Date",
    },
  },
}),
```

## protobuf-es: toProto Functions

protobuf-es generates `$toProto` helper functions for converting GraphQL input to protobuf messages:

### Simple Message

```typescript
export function DateInput$toProto(
  input: DateInput$Shape | null | undefined,
): Date {
  return new Date({
    year: input?.year ?? undefined,
    month: input?.month ?? undefined,
    day: input?.day ?? undefined,
  });
}
```

### Nested Message

```typescript
export function PostInput$toProto(
  input: PostInput$Shape | null | undefined,
): Post {
  return new Post({
    title: input?.title ?? undefined,
    publishedDate: input?.publishedDate
      ? DateInput$toProto(input.publishedDate)
      : undefined,
  });
}
```

### Oneof Fields

```typescript
export function OneofParentInput$toProto(
  input: OneofParentInput$Shape | null | undefined,
): OneofParent {
  return new OneofParent({
    normalField: input?.normalField ?? undefined,
    requiredOneofMembers: input?.requiredMessage1
      ? { case: "requiredMessage1", value: Message1Input$toProto(input.requiredMessage1) }
      : input?.requiredMessage2
      ? { case: "requiredMessage2", value: Message2Input$toProto(input.requiredMessage2) }
      : undefined,
  });
}
```

## Extensions Object

Generated code includes `extensions` objects for introspection:

### protobufMessage

```typescript
extensions: {
  protobufMessage: {
    fullName: "testapis.custom_types.Date",
    name: "Date",
    package: "testapis.custom_types",
  },
}
```

### protobufField

```typescript
extensions: {
  protobufField: {
    name: "published_date",
    typeFullName: "testapis.custom_types.Date",
  },
}
```

### protobufEnum

```typescript
extensions: {
  protobufEnum: {
    name: "MyEnum",
    fullName: "testapi.enums.MyEnum",
    package: "testapi.enums",
  },
}
```

### protobufEnumValue

```typescript
extensions: {
  protobufEnumValue: {
    name: "MY_ENUM_FOO",
    options: { deprecated: true },  // if applicable
  },
}
```

### protobufOneof

```typescript
extensions: {
  protobufOneof: {
    fullName: "testapis.oneof.Media.content",
    name: "content",
    messageName: "Media",
    package: "testapis.oneof",
    fields: [
      { name: "image", type: "testapis.oneof.Image" },
      { name: "video", type: "testapis.oneof.Video" },
    ],
  },
}
```

## ts-proto vs protobuf-es Differences

| Feature | ts-proto | protobuf-es |
|---------|----------|-------------|
| Import path suffix | None | `_pb` |
| `isTypeOf` check | `$type` property | `instanceof` |
| Oneof access | `source.field1 ?? source.field2` | `source.oneofName.value` |
| Input conversion | Manual | `$toProto` function |
| 64-bit integers | `String` | `Int64` scalar |

## See Also

- [Configuration](./configuration.md) - Plugin options
- [Messages](../type-mapping/messages.md) - Message to GraphQL mapping
- [Enums](../type-mapping/enums.md) - Enum conversion rules
- [Oneofs](../type-mapping/oneofs.md) - Oneof and union types
- [Scalars](../type-mapping/scalars.md) - Scalar type mappings
