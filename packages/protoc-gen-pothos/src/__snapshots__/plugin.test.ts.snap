// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`'testapis.custom_types' > generates files by plugin 'with import prefix' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/custom_types/date.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { Date } from "@testapis/ts-proto/testapis/custom_types/date";
import { builder } from "../../builder";

export const Date$Ref = builder.objectRef<Date>("Date");
builder.objectType(Date$Ref, {
  name: "Date",
  fields: (t) => ({
    year: t.expose("year", {
      type: "Int",
      nullable: false,
      extensions: { protobufField: { name: "year", typeFullName: "uint32" } },
    }),
    month: t.expose("month", {
      type: "Int",
      nullable: false,
      extensions: { protobufField: { name: "month", typeFullName: "uint32" } },
    }),
    day: t.expose("day", {
      type: "Int",
      nullable: false,
      extensions: { protobufField: { name: "day", typeFullName: "uint32" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as Date | { $type: string & {}; }).$type ===
      "testapis.custom_types.Date";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.custom_types.Date",
      name: "Date",
      package: "testapis.custom_types",
    },
  },
});

export type DateInput$Shape = {
  year: Date["year"];
  month: Date["month"];
  day: Date["day"];
};

export const DateInput$Ref: InputObjectRef<DateInput$Shape> = builder.inputRef<
  DateInput$Shape
>("DateInput").implement(
  {
    fields: (t) => ({
      year: t.field({
        type: "Int",
        required: true,
        extensions: { protobufField: { name: "year", typeFullName: "uint32" } },
      }),
      month: t.field({
        type: "Int",
        required: true,
        extensions: {
          protobufField: { name: "month", typeFullName: "uint32" },
        },
      }),
      day: t.field({
        type: "Int",
        required: true,
        extensions: { protobufField: { name: "day", typeFullName: "uint32" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.custom_types.Date",
        name: "Date",
        package: "testapis.custom_types",
      },
    },
  },
);
",
    "name": "testapis/custom_types/date.pb.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/custom_types/post.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { Post } from "@testapis/ts-proto/testapis/custom_types/post";
import { builder } from "../../builder";
import { Date$Ref, DateInput$Ref, DateInput$Shape } from "./date.pb.pothos";

export const Post$Ref = builder.objectRef<Post>("Post");
builder.objectType(Post$Ref, {
  name: "Post",
  fields: (t) => ({
    title: t.expose("title", {
      type: "String",
      nullable: false,
      description: "Required.",
      extensions: { protobufField: { name: "title", typeFullName: "string" } },
    }),
    publishedDate: t.expose("publishedDate", {
      type: Date$Ref,
      nullable: true,
      description: "Optional.",
      extensions: {
        protobufField: {
          name: "published_date",
          typeFullName: "testapis.custom_types.Date",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as Post | { $type: string & {}; }).$type ===
      "testapis.custom_types.Post";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.custom_types.Post",
      name: "Post",
      package: "testapis.custom_types",
    },
  },
});

export type PostInput$Shape = {
  title: Post["title"];
  publishedDate?: DateInput$Shape | null;
};

export const PostInput$Ref: InputObjectRef<PostInput$Shape> = builder.inputRef<
  PostInput$Shape
>("PostInput").implement(
  {
    fields: (t) => ({
      title: t.field({
        type: "String",
        required: true,
        description: "Required.",
        extensions: {
          protobufField: { name: "title", typeFullName: "string" },
        },
      }),
      publishedDate: t.field({
        type: DateInput$Ref,
        required: false,
        description: "Optional.",
        extensions: {
          protobufField: {
            name: "published_date",
            typeFullName: "testapis.custom_types.Date",
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.custom_types.Post",
        name: "Post",
        package: "testapis.custom_types",
      },
    },
  },
);
",
    "name": "testapis/custom_types/post.pb.pothos.ts",
  },
]
`;

exports[`'testapis.custom_types' > generates files by plugin 'with partial inputs' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/custom_types/date.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { Date } from "@testapis/ts-proto/testapis/custom_types/date";
import { builder } from "../../builder";

export const Date$Ref = builder.objectRef<Date>("Date");
builder.objectType(Date$Ref, {
  name: "Date",
  fields: (t) => ({
    year: t.expose("year", {
      type: "Int",
      nullable: false,
      extensions: { protobufField: { name: "year", typeFullName: "uint32" } },
    }),
    month: t.expose("month", {
      type: "Int",
      nullable: false,
      extensions: { protobufField: { name: "month", typeFullName: "uint32" } },
    }),
    day: t.expose("day", {
      type: "Int",
      nullable: false,
      extensions: { protobufField: { name: "day", typeFullName: "uint32" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as Date | { $type: string & {}; }).$type ===
      "testapis.custom_types.Date";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.custom_types.Date",
      name: "Date",
      package: "testapis.custom_types",
    },
  },
});

export type DateInput$Shape = {
  year: Date["year"];
  month: Date["month"];
  day: Date["day"];
};

export const DateInput$Ref: InputObjectRef<DateInput$Shape> = builder.inputRef<
  DateInput$Shape
>("DateInput").implement(
  {
    fields: (t) => ({
      year: t.field({
        type: "Int",
        required: true,
        extensions: { protobufField: { name: "year", typeFullName: "uint32" } },
      }),
      month: t.field({
        type: "Int",
        required: true,
        extensions: {
          protobufField: { name: "month", typeFullName: "uint32" },
        },
      }),
      day: t.field({
        type: "Int",
        required: true,
        extensions: { protobufField: { name: "day", typeFullName: "uint32" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.custom_types.Date",
        name: "Date",
        package: "testapis.custom_types",
      },
    },
  },
);

export type DatePartialInput$Shape = {
  year?: Date["year"] | null;
  month?: Date["month"] | null;
  day?: Date["day"] | null;
};

export const DatePartialInput$Ref: InputObjectRef<DatePartialInput$Shape> =
  builder.inputRef<DatePartialInput$Shape>("DatePartialInput").implement(
    {
      fields: (t) => ({
        year: t.field({
          type: "Int",
          required: false,
          extensions: {
            protobufField: { name: "year", typeFullName: "uint32" },
          },
        }),
        month: t.field({
          type: "Int",
          required: false,
          extensions: {
            protobufField: { name: "month", typeFullName: "uint32" },
          },
        }),
        day: t.field({
          type: "Int",
          required: false,
          extensions: {
            protobufField: { name: "day", typeFullName: "uint32" },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.custom_types.Date",
          name: "Date",
          package: "testapis.custom_types",
        },
      },
    },
  );
",
    "name": "testapis/custom_types/date.pb.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/custom_types/post.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { Post } from "@testapis/ts-proto/testapis/custom_types/post";
import { builder } from "../../builder";
import {
  Date$Ref,
  DateInput$Ref,
  DateInput$Shape,
  DatePartialInput$Ref,
  DatePartialInput$Shape,
} from "./date.pb.pothos";

export const Post$Ref = builder.objectRef<Post>("Post");
builder.objectType(Post$Ref, {
  name: "Post",
  fields: (t) => ({
    title: t.expose("title", {
      type: "String",
      nullable: false,
      description: "Required.",
      extensions: { protobufField: { name: "title", typeFullName: "string" } },
    }),
    publishedDate: t.expose("publishedDate", {
      type: Date$Ref,
      nullable: true,
      description: "Optional.",
      extensions: {
        protobufField: {
          name: "published_date",
          typeFullName: "testapis.custom_types.Date",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as Post | { $type: string & {}; }).$type ===
      "testapis.custom_types.Post";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.custom_types.Post",
      name: "Post",
      package: "testapis.custom_types",
    },
  },
});

export type PostInput$Shape = {
  title: Post["title"];
  publishedDate?: DateInput$Shape | null;
};

export const PostInput$Ref: InputObjectRef<PostInput$Shape> = builder.inputRef<
  PostInput$Shape
>("PostInput").implement(
  {
    fields: (t) => ({
      title: t.field({
        type: "String",
        required: true,
        description: "Required.",
        extensions: {
          protobufField: { name: "title", typeFullName: "string" },
        },
      }),
      publishedDate: t.field({
        type: DateInput$Ref,
        required: false,
        description: "Optional.",
        extensions: {
          protobufField: {
            name: "published_date",
            typeFullName: "testapis.custom_types.Date",
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.custom_types.Post",
        name: "Post",
        package: "testapis.custom_types",
      },
    },
  },
);

export type PostPartialInput$Shape = {
  title?: Post["title"] | null;
  publishedDate?: DatePartialInput$Shape | null;
};

export const PostPartialInput$Ref: InputObjectRef<PostPartialInput$Shape> =
  builder.inputRef<PostPartialInput$Shape>("PostPartialInput").implement(
    {
      fields: (t) => ({
        title: t.field({
          type: "String",
          required: false,
          description: "Required.",
          extensions: {
            protobufField: { name: "title", typeFullName: "string" },
          },
        }),
        publishedDate: t.field({
          type: DatePartialInput$Ref,
          required: false,
          description: "Optional.",
          extensions: {
            protobufField: {
              name: "published_date",
              typeFullName: "testapis.custom_types.Date",
            },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.custom_types.Post",
          name: "Post",
          package: "testapis.custom_types",
        },
      },
    },
  );
",
    "name": "testapis/custom_types/post.pb.pothos.ts",
  },
]
`;

exports[`'testapis.custom_types' > generates files by plugin 'without import prefix' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/custom_types/date.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { builder } from "../../builder";
import { Date } from "./testapis/custom_types/date";

export const Date$Ref = builder.objectRef<Date>("Date");
builder.objectType(Date$Ref, {
  name: "Date",
  fields: (t) => ({
    year: t.expose("year", {
      type: "Int",
      nullable: false,
      extensions: { protobufField: { name: "year", typeFullName: "uint32" } },
    }),
    month: t.expose("month", {
      type: "Int",
      nullable: false,
      extensions: { protobufField: { name: "month", typeFullName: "uint32" } },
    }),
    day: t.expose("day", {
      type: "Int",
      nullable: false,
      extensions: { protobufField: { name: "day", typeFullName: "uint32" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as Date | { $type: string & {}; }).$type ===
      "testapis.custom_types.Date";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.custom_types.Date",
      name: "Date",
      package: "testapis.custom_types",
    },
  },
});

export type DateInput$Shape = {
  year: Date["year"];
  month: Date["month"];
  day: Date["day"];
};

export const DateInput$Ref: InputObjectRef<DateInput$Shape> = builder.inputRef<
  DateInput$Shape
>("DateInput").implement(
  {
    fields: (t) => ({
      year: t.field({
        type: "Int",
        required: true,
        extensions: { protobufField: { name: "year", typeFullName: "uint32" } },
      }),
      month: t.field({
        type: "Int",
        required: true,
        extensions: {
          protobufField: { name: "month", typeFullName: "uint32" },
        },
      }),
      day: t.field({
        type: "Int",
        required: true,
        extensions: { protobufField: { name: "day", typeFullName: "uint32" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.custom_types.Date",
        name: "Date",
        package: "testapis.custom_types",
      },
    },
  },
);
",
    "name": "testapis/custom_types/date.pb.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/custom_types/post.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { builder } from "../../builder";
import { Date$Ref, DateInput$Ref, DateInput$Shape } from "./date.pb.pothos";
import { Post } from "./testapis/custom_types/post";

export const Post$Ref = builder.objectRef<Post>("Post");
builder.objectType(Post$Ref, {
  name: "Post",
  fields: (t) => ({
    title: t.expose("title", {
      type: "String",
      nullable: false,
      description: "Required.",
      extensions: { protobufField: { name: "title", typeFullName: "string" } },
    }),
    publishedDate: t.expose("publishedDate", {
      type: Date$Ref,
      nullable: true,
      description: "Optional.",
      extensions: {
        protobufField: {
          name: "published_date",
          typeFullName: "testapis.custom_types.Date",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as Post | { $type: string & {}; }).$type ===
      "testapis.custom_types.Post";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.custom_types.Post",
      name: "Post",
      package: "testapis.custom_types",
    },
  },
});

export type PostInput$Shape = {
  title: Post["title"];
  publishedDate?: DateInput$Shape | null;
};

export const PostInput$Ref: InputObjectRef<PostInput$Shape> = builder.inputRef<
  PostInput$Shape
>("PostInput").implement(
  {
    fields: (t) => ({
      title: t.field({
        type: "String",
        required: true,
        description: "Required.",
        extensions: {
          protobufField: { name: "title", typeFullName: "string" },
        },
      }),
      publishedDate: t.field({
        type: DateInput$Ref,
        required: false,
        description: "Optional.",
        extensions: {
          protobufField: {
            name: "published_date",
            typeFullName: "testapis.custom_types.Date",
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.custom_types.Post",
        name: "Post",
        package: "testapis.custom_types",
      },
    },
  },
);
",
    "name": "testapis/custom_types/post.pb.pothos.ts",
  },
]
`;

exports[`'testapis.deprecation' > generates files by plugin 'with import prefix' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/deprecation/deprecation.proto

/* eslint-disable */

import { EnumRef, InputObjectRef } from "@pothos/core";
import {
  DeprecatedEnum,
  DeprecatedMessage,
  DeprecatedMessage_InnerMessage,
  NotDeprecatedEnum,
  NotDeprecatedMessage,
  NotDeprecatedMessage_InnerMessage1,
  NotDeprecatedMessage_InnerMessage2,
} from "@testapis/ts-proto/testapis/deprecation/deprecation";
import { builder } from "../../builder";

export const DeprecatedMessage$Ref = builder.objectRef<DeprecatedMessage>(
  "DeprecatedMessage",
);
builder.objectType(DeprecatedMessage$Ref, {
  name: "DeprecatedMessage",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      deprecationReason:
        "testapis.deprecation.DeprecatedMessage is mark as deprecated in a *.proto file.",
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
    enum: t.field({
      type: NotDeprecatedEnum$Ref,
      nullable: true,
      deprecationReason:
        "testapis.deprecation.DeprecatedMessage is mark as deprecated in a *.proto file.",
      resolve: (source) => {
        if (source.enum === NotDeprecatedEnum.NOT_DEPRECATED_ENUM_UNSPECIFIED) {
          return null;
        }

        return source.enum;
      },
      extensions: {
        protobufField: {
          name: "enum",
          typeFullName: "testapis.deprecation.NotDeprecatedEnum",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as DeprecatedMessage | { $type: string & {}; }).$type ===
      "testapis.deprecation.DeprecatedMessage";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.deprecation.DeprecatedMessage",
      name: "DeprecatedMessage",
      package: "testapis.deprecation",
      options: { deprecated: true },
    },
  },
});

export const NotDeprecatedMessage$Ref = builder.objectRef<NotDeprecatedMessage>(
  "NotDeprecatedMessage",
);
builder.objectType(NotDeprecatedMessage$Ref, {
  name: "NotDeprecatedMessage",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      deprecationReason:
        "testapis.deprecation.NotDeprecatedMessage.body is mark as deprecated in a *.proto file.",
      extensions: {
        protobufField: {
          name: "body",
          typeFullName: "string",
          options: { deprecated: true },
        },
      },
    }),
    enum: t.field({
      type: DeprecatedEnum$Ref,
      nullable: true,
      deprecationReason:
        "testapis.deprecation.DeprecatedEnum is mark as deprecated in a *.proto file.",
      resolve: (source) => {
        if (source.enum === DeprecatedEnum.DEPRECATED_ENUM_UNSPECIFIED) {
          return null;
        }

        return source.enum;
      },
      extensions: {
        protobufField: {
          name: "enum",
          typeFullName: "testapis.deprecation.DeprecatedEnum",
        },
      },
    }),
    notDeprecatedOneof: t.field({
      type: NotDeprecatedMessageNotDeprecatedOneof$Ref,
      nullable: true,
      resolve: (source) => {
        const value = source.msg1 ?? source.msg2;
        if (value == null) {
          return null;
        }
        return value;
      },
      extensions: { protobufField: { name: "not_deprecated_oneof" } },
    }),
    deprecatedOneof: t.field({
      type: NotDeprecatedMessageDeprecatedOneof$Ref,
      nullable: true,
      deprecationReason:
        "testapis.deprecation.NotDeprecatedMessage.deprecated_oneof is mark as deprecated in a *.proto file.",
      resolve: (source) => {
        const value = source.msg3 ?? source.msg4;
        if (value == null) {
          return null;
        }
        return value;
      },
      extensions: { protobufField: { name: "deprecated_oneof" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as NotDeprecatedMessage | { $type: string & {}; }).$type ===
      "testapis.deprecation.NotDeprecatedMessage";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.deprecation.NotDeprecatedMessage",
      name: "NotDeprecatedMessage",
      package: "testapis.deprecation",
    },
  },
});

export const DeprecatedMessageInnerMessage$Ref = builder.objectRef<
  DeprecatedMessage_InnerMessage
>("DeprecatedMessageInnerMessage");
builder.objectType(DeprecatedMessageInnerMessage$Ref, {
  name: "DeprecatedMessageInnerMessage",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      deprecationReason:
        "testapis.deprecation.DeprecatedMessage is mark as deprecated in a *.proto file.",
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as DeprecatedMessage_InnerMessage | { $type: string & {}; })
      .$type ===
      "testapis.deprecation.DeprecatedMessage.InnerMessage";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.deprecation.DeprecatedMessage.InnerMessage",
      name: "InnerMessage",
      package: "testapis.deprecation",
    },
  },
});

export const NotDeprecatedMessageInnerMessage1$Ref = builder.objectRef<
  NotDeprecatedMessage_InnerMessage1
>("NotDeprecatedMessageInnerMessage1");
builder.objectType(NotDeprecatedMessageInnerMessage1$Ref, {
  name: "NotDeprecatedMessageInnerMessage1",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as NotDeprecatedMessage_InnerMessage1 | {
      $type: string & {};
    }).$type ===
      "testapis.deprecation.NotDeprecatedMessage.InnerMessage1";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.deprecation.NotDeprecatedMessage.InnerMessage1",
      name: "InnerMessage1",
      package: "testapis.deprecation",
    },
  },
});

export const NotDeprecatedMessageInnerMessage2$Ref = builder.objectRef<
  NotDeprecatedMessage_InnerMessage2
>("NotDeprecatedMessageInnerMessage2");
builder.objectType(NotDeprecatedMessageInnerMessage2$Ref, {
  name: "NotDeprecatedMessageInnerMessage2",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as NotDeprecatedMessage_InnerMessage2 | {
      $type: string & {};
    }).$type ===
      "testapis.deprecation.NotDeprecatedMessage.InnerMessage2";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.deprecation.NotDeprecatedMessage.InnerMessage2",
      name: "InnerMessage2",
      package: "testapis.deprecation",
    },
  },
});

export type DeprecatedMessageInput$Shape = {
  body?: DeprecatedMessage["body"] | null;
  enum?: DeprecatedMessage["enum"] | null;
};

export const DeprecatedMessageInput$Ref: InputObjectRef<
  DeprecatedMessageInput$Shape
> = builder.inputRef<DeprecatedMessageInput$Shape>("DeprecatedMessageInput")
  .implement(
    {
      fields: (t) => ({
        body: t.field({
          type: "String",
          required: false,
          deprecationReason:
            "testapis.deprecation.DeprecatedMessage is mark as deprecated in a *.proto file.",
          extensions: {
            protobufField: { name: "body", typeFullName: "string" },
          },
        }),
        enum: t.field({
          type: NotDeprecatedEnum$Ref,
          required: false,
          deprecationReason:
            "testapis.deprecation.DeprecatedMessage is mark as deprecated in a *.proto file.",
          extensions: {
            protobufField: {
              name: "enum",
              typeFullName: "testapis.deprecation.NotDeprecatedEnum",
            },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.deprecation.DeprecatedMessage",
          name: "DeprecatedMessage",
          package: "testapis.deprecation",
          options: { deprecated: true },
        },
      },
    },
  );

export type NotDeprecatedMessageInput$Shape = {
  body?: NotDeprecatedMessage["body"] | null;
  enum?: NotDeprecatedMessage["enum"] | null;
  msg1?: NotDeprecatedMessageInnerMessage1Input$Shape | null;
  msg2?: NotDeprecatedMessageInnerMessage2Input$Shape | null;
  msg3?: NotDeprecatedMessageInnerMessage1Input$Shape | null;
  msg4?: NotDeprecatedMessageInnerMessage2Input$Shape | null;
};

export const NotDeprecatedMessageInput$Ref: InputObjectRef<
  NotDeprecatedMessageInput$Shape
> = builder.inputRef<NotDeprecatedMessageInput$Shape>(
  "NotDeprecatedMessageInput",
).implement(
  {
    fields: (t) => ({
      body: t.field({
        type: "String",
        required: false,
        deprecationReason:
          "testapis.deprecation.NotDeprecatedMessage.body is mark as deprecated in a *.proto file.",
        extensions: {
          protobufField: {
            name: "body",
            typeFullName: "string",
            options: { deprecated: true },
          },
        },
      }),
      enum: t.field({
        type: DeprecatedEnum$Ref,
        required: false,
        deprecationReason:
          "testapis.deprecation.DeprecatedEnum is mark as deprecated in a *.proto file.",
        extensions: {
          protobufField: {
            name: "enum",
            typeFullName: "testapis.deprecation.DeprecatedEnum",
          },
        },
      }),
      msg1: t.field({
        type: NotDeprecatedMessageInnerMessage1Input$Ref,
        required: false,
        deprecationReason:
          "testapis.deprecation.NotDeprecatedMessage.msg1 is mark as deprecated in a *.proto file.",
        extensions: {
          protobufField: {
            name: "msg1",
            typeFullName:
              "testapis.deprecation.NotDeprecatedMessage.InnerMessage1",
            options: { deprecated: true },
          },
        },
      }),
      msg2: t.field({
        type: NotDeprecatedMessageInnerMessage2Input$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "msg2",
            typeFullName:
              "testapis.deprecation.NotDeprecatedMessage.InnerMessage2",
          },
        },
      }),
      msg3: t.field({
        type: NotDeprecatedMessageInnerMessage1Input$Ref,
        required: false,
        deprecationReason:
          "testapis.deprecation.NotDeprecatedMessage.msg3 is mark as deprecated in a *.proto file.",
        extensions: {
          protobufField: {
            name: "msg3",
            typeFullName:
              "testapis.deprecation.NotDeprecatedMessage.InnerMessage1",
            options: { deprecated: true },
          },
        },
      }),
      msg4: t.field({
        type: NotDeprecatedMessageInnerMessage2Input$Ref,
        required: false,
        deprecationReason:
          "testapis.deprecation.NotDeprecatedMessage.msg4 is mark as deprecated in a *.proto file.",
        extensions: {
          protobufField: {
            name: "msg4",
            typeFullName:
              "testapis.deprecation.NotDeprecatedMessage.InnerMessage2",
            options: { deprecated: true },
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.deprecation.NotDeprecatedMessage",
        name: "NotDeprecatedMessage",
        package: "testapis.deprecation",
      },
    },
  },
);

export type DeprecatedMessageInnerMessageInput$Shape = {
  body?: DeprecatedMessage_InnerMessage["body"] | null;
};

export const DeprecatedMessageInnerMessageInput$Ref: InputObjectRef<
  DeprecatedMessageInnerMessageInput$Shape
> = builder.inputRef<DeprecatedMessageInnerMessageInput$Shape>(
  "DeprecatedMessageInnerMessageInput",
).implement(
  {
    fields: (t) => ({
      body: t.field({
        type: "String",
        required: false,
        deprecationReason:
          "testapis.deprecation.DeprecatedMessage is mark as deprecated in a *.proto file.",
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.deprecation.DeprecatedMessage.InnerMessage",
        name: "InnerMessage",
        package: "testapis.deprecation",
      },
    },
  },
);

export type NotDeprecatedMessageInnerMessage1Input$Shape = {
  body: NotDeprecatedMessage_InnerMessage1["body"];
};

export const NotDeprecatedMessageInnerMessage1Input$Ref: InputObjectRef<
  NotDeprecatedMessageInnerMessage1Input$Shape
> = builder.inputRef<NotDeprecatedMessageInnerMessage1Input$Shape>(
  "NotDeprecatedMessageInnerMessage1Input",
).implement(
  {
    fields: (t) => ({
      body: t.field({
        type: "String",
        required: true,
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.deprecation.NotDeprecatedMessage.InnerMessage1",
        name: "InnerMessage1",
        package: "testapis.deprecation",
      },
    },
  },
);

export type NotDeprecatedMessageInnerMessage2Input$Shape = {
  body: NotDeprecatedMessage_InnerMessage2["body"];
};

export const NotDeprecatedMessageInnerMessage2Input$Ref: InputObjectRef<
  NotDeprecatedMessageInnerMessage2Input$Shape
> = builder.inputRef<NotDeprecatedMessageInnerMessage2Input$Shape>(
  "NotDeprecatedMessageInnerMessage2Input",
).implement(
  {
    fields: (t) => ({
      body: t.field({
        type: "String",
        required: true,
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.deprecation.NotDeprecatedMessage.InnerMessage2",
        name: "InnerMessage2",
        package: "testapis.deprecation",
      },
    },
  },
);

export const NotDeprecatedMessageNotDeprecatedOneof$Ref = builder.unionType(
  "NotDeprecatedMessageNotDeprecatedOneof",
  {
    types: [
      NotDeprecatedMessageInnerMessage1$Ref,
      NotDeprecatedMessageInnerMessage2$Ref,
    ],
    extensions: {
      protobufOneof: {
        fullName:
          "testapis.deprecation.NotDeprecatedMessage.not_deprecated_oneof",
        name: "not_deprecated_oneof",
        messageName: "NotDeprecatedMessage",
        package: "testapis.deprecation",
        fields: [{
          name: "msg1",
          type: "testapis.deprecation.NotDeprecatedMessage.InnerMessage1",
        }, {
          name: "msg2",
          type: "testapis.deprecation.NotDeprecatedMessage.InnerMessage2",
        }],
      },
    },
  },
);

export const NotDeprecatedMessageDeprecatedOneof$Ref = builder.unionType(
  "NotDeprecatedMessageDeprecatedOneof",
  {
    types: [
      NotDeprecatedMessageInnerMessage1$Ref,
      NotDeprecatedMessageInnerMessage2$Ref,
    ],
    extensions: {
      protobufOneof: {
        fullName: "testapis.deprecation.NotDeprecatedMessage.deprecated_oneof",
        name: "deprecated_oneof",
        messageName: "NotDeprecatedMessage",
        package: "testapis.deprecation",
        fields: [{
          name: "msg3",
          type: "testapis.deprecation.NotDeprecatedMessage.InnerMessage1",
        }, {
          name: "msg4",
          type: "testapis.deprecation.NotDeprecatedMessage.InnerMessage2",
        }],
      },
    },
  },
);

export const NotDeprecatedEnum$Ref: EnumRef<
  NotDeprecatedEnum,
  NotDeprecatedEnum
> = builder.enumType("NotDeprecatedEnum", {
  values: {
    NOT_DEPRECATED_FOO: {
      value: 1,
      extensions: { protobufEnumValue: { name: "NOT_DEPRECATED_FOO" } },
    },
    DEPRECATED_BAR: {
      deprecationReason:
        "testapis.deprecation.NotDeprecatedEnum.DEPRECATED_BAR is mark as deprecated in a *.proto file.",
      value: 2,
      extensions: {
        protobufEnumValue: {
          name: "DEPRECATED_BAR",
          options: { deprecated: true },
        },
      },
    },
  } as const,
  extensions: {
    protobufEnum: {
      name: "NotDeprecatedEnum",
      fullName: "testapis.deprecation.NotDeprecatedEnum",
      package: "testapis.deprecation",
    },
  },
});

export const DeprecatedEnum$Ref: EnumRef<DeprecatedEnum, DeprecatedEnum> =
  builder.enumType("DeprecatedEnum", {
    values: {
      DEPRECATED_BAZ: {
        deprecationReason:
          "testapis.deprecation.DeprecatedEnum is mark as deprecated in a *.proto file.",
        value: 1,
        extensions: { protobufEnumValue: { name: "DEPRECATED_BAZ" } },
      },
      DEPRECATED_QUX: {
        deprecationReason:
          "testapis.deprecation.DeprecatedEnum is mark as deprecated in a *.proto file.",
        value: 2,
        extensions: { protobufEnumValue: { name: "DEPRECATED_QUX" } },
      },
    } as const,
    extensions: {
      protobufEnum: {
        name: "DeprecatedEnum",
        fullName: "testapis.deprecation.DeprecatedEnum",
        package: "testapis.deprecation",
        options: { deprecated: true },
      },
    },
  });
",
    "name": "testapis/deprecation/deprecation.pb.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/deprecation/file_deprecation.proto

/* eslint-disable */

import { EnumRef, InputObjectRef } from "@pothos/core";
import {
  DeprecatedFileEnum,
  DeprecatedFileMessage,
  DeprecatedFileMessage_InnerMessage,
} from "@testapis/ts-proto/testapis/deprecation/file_deprecation";
import { builder } from "../../builder";

export const DeprecatedFileMessage$Ref = builder.objectRef<
  DeprecatedFileMessage
>("DeprecatedFileMessage");
builder.objectType(DeprecatedFileMessage$Ref, {
  name: "DeprecatedFileMessage",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      deprecationReason:
        "testapis/deprecation/file_deprecation.proto is mark as deprecated.",
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
    enum: t.field({
      type: DeprecatedFileEnum$Ref,
      nullable: true,
      deprecationReason:
        "testapis/deprecation/file_deprecation.proto is mark as deprecated.",
      resolve: (source) => {
        if (
          source.enum === DeprecatedFileEnum.DEPRECATED_FILE_ENUM_UNSPECIFIED
        ) {
          return null;
        }

        return source.enum;
      },
      extensions: {
        protobufField: {
          name: "enum",
          typeFullName: "testapis.deprecation.DeprecatedFileEnum",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as DeprecatedFileMessage | { $type: string & {}; }).$type ===
      "testapis.deprecation.DeprecatedFileMessage";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.deprecation.DeprecatedFileMessage",
      name: "DeprecatedFileMessage",
      package: "testapis.deprecation",
    },
  },
});

export const DeprecatedFileMessageInnerMessage$Ref = builder.objectRef<
  DeprecatedFileMessage_InnerMessage
>("DeprecatedFileMessageInnerMessage");
builder.objectType(DeprecatedFileMessageInnerMessage$Ref, {
  name: "DeprecatedFileMessageInnerMessage",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      deprecationReason:
        "testapis/deprecation/file_deprecation.proto is mark as deprecated.",
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as DeprecatedFileMessage_InnerMessage | {
      $type: string & {};
    }).$type ===
      "testapis.deprecation.DeprecatedFileMessage.InnerMessage";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.deprecation.DeprecatedFileMessage.InnerMessage",
      name: "InnerMessage",
      package: "testapis.deprecation",
    },
  },
});

export type DeprecatedFileMessageInput$Shape = {
  body?: DeprecatedFileMessage["body"] | null;
  enum?: DeprecatedFileMessage["enum"] | null;
};

export const DeprecatedFileMessageInput$Ref: InputObjectRef<
  DeprecatedFileMessageInput$Shape
> = builder.inputRef<DeprecatedFileMessageInput$Shape>(
  "DeprecatedFileMessageInput",
).implement(
  {
    fields: (t) => ({
      body: t.field({
        type: "String",
        required: false,
        deprecationReason:
          "testapis/deprecation/file_deprecation.proto is mark as deprecated.",
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
      enum: t.field({
        type: DeprecatedFileEnum$Ref,
        required: false,
        deprecationReason:
          "testapis/deprecation/file_deprecation.proto is mark as deprecated.",
        extensions: {
          protobufField: {
            name: "enum",
            typeFullName: "testapis.deprecation.DeprecatedFileEnum",
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.deprecation.DeprecatedFileMessage",
        name: "DeprecatedFileMessage",
        package: "testapis.deprecation",
      },
    },
  },
);

export type DeprecatedFileMessageInnerMessageInput$Shape = {
  body?: DeprecatedFileMessage_InnerMessage["body"] | null;
};

export const DeprecatedFileMessageInnerMessageInput$Ref: InputObjectRef<
  DeprecatedFileMessageInnerMessageInput$Shape
> = builder.inputRef<DeprecatedFileMessageInnerMessageInput$Shape>(
  "DeprecatedFileMessageInnerMessageInput",
).implement(
  {
    fields: (t) => ({
      body: t.field({
        type: "String",
        required: false,
        deprecationReason:
          "testapis/deprecation/file_deprecation.proto is mark as deprecated.",
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.deprecation.DeprecatedFileMessage.InnerMessage",
        name: "InnerMessage",
        package: "testapis.deprecation",
      },
    },
  },
);

export const DeprecatedFileEnum$Ref: EnumRef<
  DeprecatedFileEnum,
  DeprecatedFileEnum
> = builder.enumType("DeprecatedFileEnum", {
  values: {
    DEPRECATED_FILE_FOO: {
      deprecationReason:
        "testapis/deprecation/file_deprecation.proto is mark as deprecated.",
      value: 1,
      extensions: { protobufEnumValue: { name: "DEPRECATED_FILE_FOO" } },
    },
    DEPRECATED_FILE_BAR: {
      deprecationReason:
        "testapis/deprecation/file_deprecation.proto is mark as deprecated.",
      value: 2,
      extensions: { protobufEnumValue: { name: "DEPRECATED_FILE_BAR" } },
    },
  } as const,
  extensions: {
    protobufEnum: {
      name: "DeprecatedFileEnum",
      fullName: "testapis.deprecation.DeprecatedFileEnum",
      package: "testapis.deprecation",
    },
  },
});
",
    "name": "testapis/deprecation/file_deprecation.pb.pothos.ts",
  },
]
`;

exports[`'testapis.deprecation' > generates files by plugin 'with partial inputs' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/deprecation/deprecation.proto

/* eslint-disable */

import { EnumRef, InputObjectRef } from "@pothos/core";
import {
  DeprecatedEnum,
  DeprecatedMessage,
  DeprecatedMessage_InnerMessage,
  NotDeprecatedEnum,
  NotDeprecatedMessage,
  NotDeprecatedMessage_InnerMessage1,
  NotDeprecatedMessage_InnerMessage2,
} from "@testapis/ts-proto/testapis/deprecation/deprecation";
import { builder } from "../../builder";

export const DeprecatedMessage$Ref = builder.objectRef<DeprecatedMessage>(
  "DeprecatedMessage",
);
builder.objectType(DeprecatedMessage$Ref, {
  name: "DeprecatedMessage",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      deprecationReason:
        "testapis.deprecation.DeprecatedMessage is mark as deprecated in a *.proto file.",
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
    enum: t.field({
      type: NotDeprecatedEnum$Ref,
      nullable: true,
      deprecationReason:
        "testapis.deprecation.DeprecatedMessage is mark as deprecated in a *.proto file.",
      resolve: (source) => {
        if (source.enum === NotDeprecatedEnum.NOT_DEPRECATED_ENUM_UNSPECIFIED) {
          return null;
        }

        return source.enum;
      },
      extensions: {
        protobufField: {
          name: "enum",
          typeFullName: "testapis.deprecation.NotDeprecatedEnum",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as DeprecatedMessage | { $type: string & {}; }).$type ===
      "testapis.deprecation.DeprecatedMessage";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.deprecation.DeprecatedMessage",
      name: "DeprecatedMessage",
      package: "testapis.deprecation",
      options: { deprecated: true },
    },
  },
});

export const NotDeprecatedMessage$Ref = builder.objectRef<NotDeprecatedMessage>(
  "NotDeprecatedMessage",
);
builder.objectType(NotDeprecatedMessage$Ref, {
  name: "NotDeprecatedMessage",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      deprecationReason:
        "testapis.deprecation.NotDeprecatedMessage.body is mark as deprecated in a *.proto file.",
      extensions: {
        protobufField: {
          name: "body",
          typeFullName: "string",
          options: { deprecated: true },
        },
      },
    }),
    enum: t.field({
      type: DeprecatedEnum$Ref,
      nullable: true,
      deprecationReason:
        "testapis.deprecation.DeprecatedEnum is mark as deprecated in a *.proto file.",
      resolve: (source) => {
        if (source.enum === DeprecatedEnum.DEPRECATED_ENUM_UNSPECIFIED) {
          return null;
        }

        return source.enum;
      },
      extensions: {
        protobufField: {
          name: "enum",
          typeFullName: "testapis.deprecation.DeprecatedEnum",
        },
      },
    }),
    notDeprecatedOneof: t.field({
      type: NotDeprecatedMessageNotDeprecatedOneof$Ref,
      nullable: true,
      resolve: (source) => {
        const value = source.msg1 ?? source.msg2;
        if (value == null) {
          return null;
        }
        return value;
      },
      extensions: { protobufField: { name: "not_deprecated_oneof" } },
    }),
    deprecatedOneof: t.field({
      type: NotDeprecatedMessageDeprecatedOneof$Ref,
      nullable: true,
      deprecationReason:
        "testapis.deprecation.NotDeprecatedMessage.deprecated_oneof is mark as deprecated in a *.proto file.",
      resolve: (source) => {
        const value = source.msg3 ?? source.msg4;
        if (value == null) {
          return null;
        }
        return value;
      },
      extensions: { protobufField: { name: "deprecated_oneof" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as NotDeprecatedMessage | { $type: string & {}; }).$type ===
      "testapis.deprecation.NotDeprecatedMessage";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.deprecation.NotDeprecatedMessage",
      name: "NotDeprecatedMessage",
      package: "testapis.deprecation",
    },
  },
});

export const DeprecatedMessageInnerMessage$Ref = builder.objectRef<
  DeprecatedMessage_InnerMessage
>("DeprecatedMessageInnerMessage");
builder.objectType(DeprecatedMessageInnerMessage$Ref, {
  name: "DeprecatedMessageInnerMessage",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      deprecationReason:
        "testapis.deprecation.DeprecatedMessage is mark as deprecated in a *.proto file.",
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as DeprecatedMessage_InnerMessage | { $type: string & {}; })
      .$type ===
      "testapis.deprecation.DeprecatedMessage.InnerMessage";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.deprecation.DeprecatedMessage.InnerMessage",
      name: "InnerMessage",
      package: "testapis.deprecation",
    },
  },
});

export const NotDeprecatedMessageInnerMessage1$Ref = builder.objectRef<
  NotDeprecatedMessage_InnerMessage1
>("NotDeprecatedMessageInnerMessage1");
builder.objectType(NotDeprecatedMessageInnerMessage1$Ref, {
  name: "NotDeprecatedMessageInnerMessage1",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as NotDeprecatedMessage_InnerMessage1 | {
      $type: string & {};
    }).$type ===
      "testapis.deprecation.NotDeprecatedMessage.InnerMessage1";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.deprecation.NotDeprecatedMessage.InnerMessage1",
      name: "InnerMessage1",
      package: "testapis.deprecation",
    },
  },
});

export const NotDeprecatedMessageInnerMessage2$Ref = builder.objectRef<
  NotDeprecatedMessage_InnerMessage2
>("NotDeprecatedMessageInnerMessage2");
builder.objectType(NotDeprecatedMessageInnerMessage2$Ref, {
  name: "NotDeprecatedMessageInnerMessage2",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as NotDeprecatedMessage_InnerMessage2 | {
      $type: string & {};
    }).$type ===
      "testapis.deprecation.NotDeprecatedMessage.InnerMessage2";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.deprecation.NotDeprecatedMessage.InnerMessage2",
      name: "InnerMessage2",
      package: "testapis.deprecation",
    },
  },
});

export type DeprecatedMessageInput$Shape = {
  body?: DeprecatedMessage["body"] | null;
  enum?: DeprecatedMessage["enum"] | null;
};

export const DeprecatedMessageInput$Ref: InputObjectRef<
  DeprecatedMessageInput$Shape
> = builder.inputRef<DeprecatedMessageInput$Shape>("DeprecatedMessageInput")
  .implement(
    {
      fields: (t) => ({
        body: t.field({
          type: "String",
          required: false,
          deprecationReason:
            "testapis.deprecation.DeprecatedMessage is mark as deprecated in a *.proto file.",
          extensions: {
            protobufField: { name: "body", typeFullName: "string" },
          },
        }),
        enum: t.field({
          type: NotDeprecatedEnum$Ref,
          required: false,
          deprecationReason:
            "testapis.deprecation.DeprecatedMessage is mark as deprecated in a *.proto file.",
          extensions: {
            protobufField: {
              name: "enum",
              typeFullName: "testapis.deprecation.NotDeprecatedEnum",
            },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.deprecation.DeprecatedMessage",
          name: "DeprecatedMessage",
          package: "testapis.deprecation",
          options: { deprecated: true },
        },
      },
    },
  );

export type DeprecatedMessagePartialInput$Shape = {
  body?: DeprecatedMessage["body"] | null;
  enum?: DeprecatedMessage["enum"] | null;
};

export const DeprecatedMessagePartialInput$Ref: InputObjectRef<
  DeprecatedMessagePartialInput$Shape
> = builder.inputRef<DeprecatedMessagePartialInput$Shape>(
  "DeprecatedMessagePartialInput",
).implement(
  {
    fields: (t) => ({
      body: t.field({
        type: "String",
        required: false,
        deprecationReason:
          "testapis.deprecation.DeprecatedMessage is mark as deprecated in a *.proto file.",
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
      enum: t.field({
        type: NotDeprecatedEnum$Ref,
        required: false,
        deprecationReason:
          "testapis.deprecation.DeprecatedMessage is mark as deprecated in a *.proto file.",
        extensions: {
          protobufField: {
            name: "enum",
            typeFullName: "testapis.deprecation.NotDeprecatedEnum",
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.deprecation.DeprecatedMessage",
        name: "DeprecatedMessage",
        package: "testapis.deprecation",
        options: { deprecated: true },
      },
    },
  },
);

export type NotDeprecatedMessageInput$Shape = {
  body?: NotDeprecatedMessage["body"] | null;
  enum?: NotDeprecatedMessage["enum"] | null;
  msg1?: NotDeprecatedMessageInnerMessage1Input$Shape | null;
  msg2?: NotDeprecatedMessageInnerMessage2Input$Shape | null;
  msg3?: NotDeprecatedMessageInnerMessage1Input$Shape | null;
  msg4?: NotDeprecatedMessageInnerMessage2Input$Shape | null;
};

export const NotDeprecatedMessageInput$Ref: InputObjectRef<
  NotDeprecatedMessageInput$Shape
> = builder.inputRef<NotDeprecatedMessageInput$Shape>(
  "NotDeprecatedMessageInput",
).implement(
  {
    fields: (t) => ({
      body: t.field({
        type: "String",
        required: false,
        deprecationReason:
          "testapis.deprecation.NotDeprecatedMessage.body is mark as deprecated in a *.proto file.",
        extensions: {
          protobufField: {
            name: "body",
            typeFullName: "string",
            options: { deprecated: true },
          },
        },
      }),
      enum: t.field({
        type: DeprecatedEnum$Ref,
        required: false,
        deprecationReason:
          "testapis.deprecation.DeprecatedEnum is mark as deprecated in a *.proto file.",
        extensions: {
          protobufField: {
            name: "enum",
            typeFullName: "testapis.deprecation.DeprecatedEnum",
          },
        },
      }),
      msg1: t.field({
        type: NotDeprecatedMessageInnerMessage1Input$Ref,
        required: false,
        deprecationReason:
          "testapis.deprecation.NotDeprecatedMessage.msg1 is mark as deprecated in a *.proto file.",
        extensions: {
          protobufField: {
            name: "msg1",
            typeFullName:
              "testapis.deprecation.NotDeprecatedMessage.InnerMessage1",
            options: { deprecated: true },
          },
        },
      }),
      msg2: t.field({
        type: NotDeprecatedMessageInnerMessage2Input$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "msg2",
            typeFullName:
              "testapis.deprecation.NotDeprecatedMessage.InnerMessage2",
          },
        },
      }),
      msg3: t.field({
        type: NotDeprecatedMessageInnerMessage1Input$Ref,
        required: false,
        deprecationReason:
          "testapis.deprecation.NotDeprecatedMessage.msg3 is mark as deprecated in a *.proto file.",
        extensions: {
          protobufField: {
            name: "msg3",
            typeFullName:
              "testapis.deprecation.NotDeprecatedMessage.InnerMessage1",
            options: { deprecated: true },
          },
        },
      }),
      msg4: t.field({
        type: NotDeprecatedMessageInnerMessage2Input$Ref,
        required: false,
        deprecationReason:
          "testapis.deprecation.NotDeprecatedMessage.msg4 is mark as deprecated in a *.proto file.",
        extensions: {
          protobufField: {
            name: "msg4",
            typeFullName:
              "testapis.deprecation.NotDeprecatedMessage.InnerMessage2",
            options: { deprecated: true },
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.deprecation.NotDeprecatedMessage",
        name: "NotDeprecatedMessage",
        package: "testapis.deprecation",
      },
    },
  },
);

export type NotDeprecatedMessagePartialInput$Shape = {
  body?: NotDeprecatedMessage["body"] | null;
  enum?: NotDeprecatedMessage["enum"] | null;
  msg1?: NotDeprecatedMessageInnerMessage1PartialInput$Shape | null;
  msg2?: NotDeprecatedMessageInnerMessage2PartialInput$Shape | null;
  msg3?: NotDeprecatedMessageInnerMessage1PartialInput$Shape | null;
  msg4?: NotDeprecatedMessageInnerMessage2PartialInput$Shape | null;
};

export const NotDeprecatedMessagePartialInput$Ref: InputObjectRef<
  NotDeprecatedMessagePartialInput$Shape
> = builder.inputRef<NotDeprecatedMessagePartialInput$Shape>(
  "NotDeprecatedMessagePartialInput",
).implement(
  {
    fields: (t) => ({
      body: t.field({
        type: "String",
        required: false,
        deprecationReason:
          "testapis.deprecation.NotDeprecatedMessage.body is mark as deprecated in a *.proto file.",
        extensions: {
          protobufField: {
            name: "body",
            typeFullName: "string",
            options: { deprecated: true },
          },
        },
      }),
      enum: t.field({
        type: DeprecatedEnum$Ref,
        required: false,
        deprecationReason:
          "testapis.deprecation.DeprecatedEnum is mark as deprecated in a *.proto file.",
        extensions: {
          protobufField: {
            name: "enum",
            typeFullName: "testapis.deprecation.DeprecatedEnum",
          },
        },
      }),
      msg1: t.field({
        type: NotDeprecatedMessageInnerMessage1PartialInput$Ref,
        required: false,
        deprecationReason:
          "testapis.deprecation.NotDeprecatedMessage.msg1 is mark as deprecated in a *.proto file.",
        extensions: {
          protobufField: {
            name: "msg1",
            typeFullName:
              "testapis.deprecation.NotDeprecatedMessage.InnerMessage1",
            options: { deprecated: true },
          },
        },
      }),
      msg2: t.field({
        type: NotDeprecatedMessageInnerMessage2PartialInput$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "msg2",
            typeFullName:
              "testapis.deprecation.NotDeprecatedMessage.InnerMessage2",
          },
        },
      }),
      msg3: t.field({
        type: NotDeprecatedMessageInnerMessage1PartialInput$Ref,
        required: false,
        deprecationReason:
          "testapis.deprecation.NotDeprecatedMessage.msg3 is mark as deprecated in a *.proto file.",
        extensions: {
          protobufField: {
            name: "msg3",
            typeFullName:
              "testapis.deprecation.NotDeprecatedMessage.InnerMessage1",
            options: { deprecated: true },
          },
        },
      }),
      msg4: t.field({
        type: NotDeprecatedMessageInnerMessage2PartialInput$Ref,
        required: false,
        deprecationReason:
          "testapis.deprecation.NotDeprecatedMessage.msg4 is mark as deprecated in a *.proto file.",
        extensions: {
          protobufField: {
            name: "msg4",
            typeFullName:
              "testapis.deprecation.NotDeprecatedMessage.InnerMessage2",
            options: { deprecated: true },
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.deprecation.NotDeprecatedMessage",
        name: "NotDeprecatedMessage",
        package: "testapis.deprecation",
      },
    },
  },
);

export type DeprecatedMessageInnerMessageInput$Shape = {
  body?: DeprecatedMessage_InnerMessage["body"] | null;
};

export const DeprecatedMessageInnerMessageInput$Ref: InputObjectRef<
  DeprecatedMessageInnerMessageInput$Shape
> = builder.inputRef<DeprecatedMessageInnerMessageInput$Shape>(
  "DeprecatedMessageInnerMessageInput",
).implement(
  {
    fields: (t) => ({
      body: t.field({
        type: "String",
        required: false,
        deprecationReason:
          "testapis.deprecation.DeprecatedMessage is mark as deprecated in a *.proto file.",
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.deprecation.DeprecatedMessage.InnerMessage",
        name: "InnerMessage",
        package: "testapis.deprecation",
      },
    },
  },
);

export type DeprecatedMessageInnerMessagePartialInput$Shape = {
  body?: DeprecatedMessage_InnerMessage["body"] | null;
};

export const DeprecatedMessageInnerMessagePartialInput$Ref: InputObjectRef<
  DeprecatedMessageInnerMessagePartialInput$Shape
> = builder.inputRef<DeprecatedMessageInnerMessagePartialInput$Shape>(
  "DeprecatedMessageInnerMessagePartialInput",
).implement(
  {
    fields: (t) => ({
      body: t.field({
        type: "String",
        required: false,
        deprecationReason:
          "testapis.deprecation.DeprecatedMessage is mark as deprecated in a *.proto file.",
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.deprecation.DeprecatedMessage.InnerMessage",
        name: "InnerMessage",
        package: "testapis.deprecation",
      },
    },
  },
);

export type NotDeprecatedMessageInnerMessage1Input$Shape = {
  body: NotDeprecatedMessage_InnerMessage1["body"];
};

export const NotDeprecatedMessageInnerMessage1Input$Ref: InputObjectRef<
  NotDeprecatedMessageInnerMessage1Input$Shape
> = builder.inputRef<NotDeprecatedMessageInnerMessage1Input$Shape>(
  "NotDeprecatedMessageInnerMessage1Input",
).implement(
  {
    fields: (t) => ({
      body: t.field({
        type: "String",
        required: true,
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.deprecation.NotDeprecatedMessage.InnerMessage1",
        name: "InnerMessage1",
        package: "testapis.deprecation",
      },
    },
  },
);

export type NotDeprecatedMessageInnerMessage1PartialInput$Shape = {
  body?: NotDeprecatedMessage_InnerMessage1["body"] | null;
};

export const NotDeprecatedMessageInnerMessage1PartialInput$Ref: InputObjectRef<
  NotDeprecatedMessageInnerMessage1PartialInput$Shape
> = builder.inputRef<NotDeprecatedMessageInnerMessage1PartialInput$Shape>(
  "NotDeprecatedMessageInnerMessage1PartialInput",
).implement(
  {
    fields: (t) => ({
      body: t.field({
        type: "String",
        required: false,
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.deprecation.NotDeprecatedMessage.InnerMessage1",
        name: "InnerMessage1",
        package: "testapis.deprecation",
      },
    },
  },
);

export type NotDeprecatedMessageInnerMessage2Input$Shape = {
  body: NotDeprecatedMessage_InnerMessage2["body"];
};

export const NotDeprecatedMessageInnerMessage2Input$Ref: InputObjectRef<
  NotDeprecatedMessageInnerMessage2Input$Shape
> = builder.inputRef<NotDeprecatedMessageInnerMessage2Input$Shape>(
  "NotDeprecatedMessageInnerMessage2Input",
).implement(
  {
    fields: (t) => ({
      body: t.field({
        type: "String",
        required: true,
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.deprecation.NotDeprecatedMessage.InnerMessage2",
        name: "InnerMessage2",
        package: "testapis.deprecation",
      },
    },
  },
);

export type NotDeprecatedMessageInnerMessage2PartialInput$Shape = {
  body?: NotDeprecatedMessage_InnerMessage2["body"] | null;
};

export const NotDeprecatedMessageInnerMessage2PartialInput$Ref: InputObjectRef<
  NotDeprecatedMessageInnerMessage2PartialInput$Shape
> = builder.inputRef<NotDeprecatedMessageInnerMessage2PartialInput$Shape>(
  "NotDeprecatedMessageInnerMessage2PartialInput",
).implement(
  {
    fields: (t) => ({
      body: t.field({
        type: "String",
        required: false,
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.deprecation.NotDeprecatedMessage.InnerMessage2",
        name: "InnerMessage2",
        package: "testapis.deprecation",
      },
    },
  },
);

export const NotDeprecatedMessageNotDeprecatedOneof$Ref = builder.unionType(
  "NotDeprecatedMessageNotDeprecatedOneof",
  {
    types: [
      NotDeprecatedMessageInnerMessage1$Ref,
      NotDeprecatedMessageInnerMessage2$Ref,
    ],
    extensions: {
      protobufOneof: {
        fullName:
          "testapis.deprecation.NotDeprecatedMessage.not_deprecated_oneof",
        name: "not_deprecated_oneof",
        messageName: "NotDeprecatedMessage",
        package: "testapis.deprecation",
        fields: [{
          name: "msg1",
          type: "testapis.deprecation.NotDeprecatedMessage.InnerMessage1",
        }, {
          name: "msg2",
          type: "testapis.deprecation.NotDeprecatedMessage.InnerMessage2",
        }],
      },
    },
  },
);

export const NotDeprecatedMessageDeprecatedOneof$Ref = builder.unionType(
  "NotDeprecatedMessageDeprecatedOneof",
  {
    types: [
      NotDeprecatedMessageInnerMessage1$Ref,
      NotDeprecatedMessageInnerMessage2$Ref,
    ],
    extensions: {
      protobufOneof: {
        fullName: "testapis.deprecation.NotDeprecatedMessage.deprecated_oneof",
        name: "deprecated_oneof",
        messageName: "NotDeprecatedMessage",
        package: "testapis.deprecation",
        fields: [{
          name: "msg3",
          type: "testapis.deprecation.NotDeprecatedMessage.InnerMessage1",
        }, {
          name: "msg4",
          type: "testapis.deprecation.NotDeprecatedMessage.InnerMessage2",
        }],
      },
    },
  },
);

export const NotDeprecatedEnum$Ref: EnumRef<
  NotDeprecatedEnum,
  NotDeprecatedEnum
> = builder.enumType("NotDeprecatedEnum", {
  values: {
    NOT_DEPRECATED_FOO: {
      value: 1,
      extensions: { protobufEnumValue: { name: "NOT_DEPRECATED_FOO" } },
    },
    DEPRECATED_BAR: {
      deprecationReason:
        "testapis.deprecation.NotDeprecatedEnum.DEPRECATED_BAR is mark as deprecated in a *.proto file.",
      value: 2,
      extensions: {
        protobufEnumValue: {
          name: "DEPRECATED_BAR",
          options: { deprecated: true },
        },
      },
    },
  } as const,
  extensions: {
    protobufEnum: {
      name: "NotDeprecatedEnum",
      fullName: "testapis.deprecation.NotDeprecatedEnum",
      package: "testapis.deprecation",
    },
  },
});

export const DeprecatedEnum$Ref: EnumRef<DeprecatedEnum, DeprecatedEnum> =
  builder.enumType("DeprecatedEnum", {
    values: {
      DEPRECATED_BAZ: {
        deprecationReason:
          "testapis.deprecation.DeprecatedEnum is mark as deprecated in a *.proto file.",
        value: 1,
        extensions: { protobufEnumValue: { name: "DEPRECATED_BAZ" } },
      },
      DEPRECATED_QUX: {
        deprecationReason:
          "testapis.deprecation.DeprecatedEnum is mark as deprecated in a *.proto file.",
        value: 2,
        extensions: { protobufEnumValue: { name: "DEPRECATED_QUX" } },
      },
    } as const,
    extensions: {
      protobufEnum: {
        name: "DeprecatedEnum",
        fullName: "testapis.deprecation.DeprecatedEnum",
        package: "testapis.deprecation",
        options: { deprecated: true },
      },
    },
  });
",
    "name": "testapis/deprecation/deprecation.pb.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/deprecation/file_deprecation.proto

/* eslint-disable */

import { EnumRef, InputObjectRef } from "@pothos/core";
import {
  DeprecatedFileEnum,
  DeprecatedFileMessage,
  DeprecatedFileMessage_InnerMessage,
} from "@testapis/ts-proto/testapis/deprecation/file_deprecation";
import { builder } from "../../builder";

export const DeprecatedFileMessage$Ref = builder.objectRef<
  DeprecatedFileMessage
>("DeprecatedFileMessage");
builder.objectType(DeprecatedFileMessage$Ref, {
  name: "DeprecatedFileMessage",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      deprecationReason:
        "testapis/deprecation/file_deprecation.proto is mark as deprecated.",
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
    enum: t.field({
      type: DeprecatedFileEnum$Ref,
      nullable: true,
      deprecationReason:
        "testapis/deprecation/file_deprecation.proto is mark as deprecated.",
      resolve: (source) => {
        if (
          source.enum === DeprecatedFileEnum.DEPRECATED_FILE_ENUM_UNSPECIFIED
        ) {
          return null;
        }

        return source.enum;
      },
      extensions: {
        protobufField: {
          name: "enum",
          typeFullName: "testapis.deprecation.DeprecatedFileEnum",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as DeprecatedFileMessage | { $type: string & {}; }).$type ===
      "testapis.deprecation.DeprecatedFileMessage";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.deprecation.DeprecatedFileMessage",
      name: "DeprecatedFileMessage",
      package: "testapis.deprecation",
    },
  },
});

export const DeprecatedFileMessageInnerMessage$Ref = builder.objectRef<
  DeprecatedFileMessage_InnerMessage
>("DeprecatedFileMessageInnerMessage");
builder.objectType(DeprecatedFileMessageInnerMessage$Ref, {
  name: "DeprecatedFileMessageInnerMessage",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      deprecationReason:
        "testapis/deprecation/file_deprecation.proto is mark as deprecated.",
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as DeprecatedFileMessage_InnerMessage | {
      $type: string & {};
    }).$type ===
      "testapis.deprecation.DeprecatedFileMessage.InnerMessage";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.deprecation.DeprecatedFileMessage.InnerMessage",
      name: "InnerMessage",
      package: "testapis.deprecation",
    },
  },
});

export type DeprecatedFileMessageInput$Shape = {
  body?: DeprecatedFileMessage["body"] | null;
  enum?: DeprecatedFileMessage["enum"] | null;
};

export const DeprecatedFileMessageInput$Ref: InputObjectRef<
  DeprecatedFileMessageInput$Shape
> = builder.inputRef<DeprecatedFileMessageInput$Shape>(
  "DeprecatedFileMessageInput",
).implement(
  {
    fields: (t) => ({
      body: t.field({
        type: "String",
        required: false,
        deprecationReason:
          "testapis/deprecation/file_deprecation.proto is mark as deprecated.",
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
      enum: t.field({
        type: DeprecatedFileEnum$Ref,
        required: false,
        deprecationReason:
          "testapis/deprecation/file_deprecation.proto is mark as deprecated.",
        extensions: {
          protobufField: {
            name: "enum",
            typeFullName: "testapis.deprecation.DeprecatedFileEnum",
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.deprecation.DeprecatedFileMessage",
        name: "DeprecatedFileMessage",
        package: "testapis.deprecation",
      },
    },
  },
);

export type DeprecatedFileMessagePartialInput$Shape = {
  body?: DeprecatedFileMessage["body"] | null;
  enum?: DeprecatedFileMessage["enum"] | null;
};

export const DeprecatedFileMessagePartialInput$Ref: InputObjectRef<
  DeprecatedFileMessagePartialInput$Shape
> = builder.inputRef<DeprecatedFileMessagePartialInput$Shape>(
  "DeprecatedFileMessagePartialInput",
).implement(
  {
    fields: (t) => ({
      body: t.field({
        type: "String",
        required: false,
        deprecationReason:
          "testapis/deprecation/file_deprecation.proto is mark as deprecated.",
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
      enum: t.field({
        type: DeprecatedFileEnum$Ref,
        required: false,
        deprecationReason:
          "testapis/deprecation/file_deprecation.proto is mark as deprecated.",
        extensions: {
          protobufField: {
            name: "enum",
            typeFullName: "testapis.deprecation.DeprecatedFileEnum",
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.deprecation.DeprecatedFileMessage",
        name: "DeprecatedFileMessage",
        package: "testapis.deprecation",
      },
    },
  },
);

export type DeprecatedFileMessageInnerMessageInput$Shape = {
  body?: DeprecatedFileMessage_InnerMessage["body"] | null;
};

export const DeprecatedFileMessageInnerMessageInput$Ref: InputObjectRef<
  DeprecatedFileMessageInnerMessageInput$Shape
> = builder.inputRef<DeprecatedFileMessageInnerMessageInput$Shape>(
  "DeprecatedFileMessageInnerMessageInput",
).implement(
  {
    fields: (t) => ({
      body: t.field({
        type: "String",
        required: false,
        deprecationReason:
          "testapis/deprecation/file_deprecation.proto is mark as deprecated.",
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.deprecation.DeprecatedFileMessage.InnerMessage",
        name: "InnerMessage",
        package: "testapis.deprecation",
      },
    },
  },
);

export type DeprecatedFileMessageInnerMessagePartialInput$Shape = {
  body?: DeprecatedFileMessage_InnerMessage["body"] | null;
};

export const DeprecatedFileMessageInnerMessagePartialInput$Ref: InputObjectRef<
  DeprecatedFileMessageInnerMessagePartialInput$Shape
> = builder.inputRef<DeprecatedFileMessageInnerMessagePartialInput$Shape>(
  "DeprecatedFileMessageInnerMessagePartialInput",
).implement(
  {
    fields: (t) => ({
      body: t.field({
        type: "String",
        required: false,
        deprecationReason:
          "testapis/deprecation/file_deprecation.proto is mark as deprecated.",
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.deprecation.DeprecatedFileMessage.InnerMessage",
        name: "InnerMessage",
        package: "testapis.deprecation",
      },
    },
  },
);

export const DeprecatedFileEnum$Ref: EnumRef<
  DeprecatedFileEnum,
  DeprecatedFileEnum
> = builder.enumType("DeprecatedFileEnum", {
  values: {
    DEPRECATED_FILE_FOO: {
      deprecationReason:
        "testapis/deprecation/file_deprecation.proto is mark as deprecated.",
      value: 1,
      extensions: { protobufEnumValue: { name: "DEPRECATED_FILE_FOO" } },
    },
    DEPRECATED_FILE_BAR: {
      deprecationReason:
        "testapis/deprecation/file_deprecation.proto is mark as deprecated.",
      value: 2,
      extensions: { protobufEnumValue: { name: "DEPRECATED_FILE_BAR" } },
    },
  } as const,
  extensions: {
    protobufEnum: {
      name: "DeprecatedFileEnum",
      fullName: "testapis.deprecation.DeprecatedFileEnum",
      package: "testapis.deprecation",
    },
  },
});
",
    "name": "testapis/deprecation/file_deprecation.pb.pothos.ts",
  },
]
`;

exports[`'testapis.deprecation' > generates files by plugin 'without import prefix' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/deprecation/deprecation.proto

/* eslint-disable */

import { EnumRef, InputObjectRef } from "@pothos/core";
import { builder } from "../../builder";
import {
  DeprecatedEnum,
  DeprecatedMessage,
  DeprecatedMessage_InnerMessage,
  NotDeprecatedEnum,
  NotDeprecatedMessage,
  NotDeprecatedMessage_InnerMessage1,
  NotDeprecatedMessage_InnerMessage2,
} from "./testapis/deprecation/deprecation";

export const DeprecatedMessage$Ref = builder.objectRef<DeprecatedMessage>(
  "DeprecatedMessage",
);
builder.objectType(DeprecatedMessage$Ref, {
  name: "DeprecatedMessage",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      deprecationReason:
        "testapis.deprecation.DeprecatedMessage is mark as deprecated in a *.proto file.",
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
    enum: t.field({
      type: NotDeprecatedEnum$Ref,
      nullable: true,
      deprecationReason:
        "testapis.deprecation.DeprecatedMessage is mark as deprecated in a *.proto file.",
      resolve: (source) => {
        if (source.enum === NotDeprecatedEnum.NOT_DEPRECATED_ENUM_UNSPECIFIED) {
          return null;
        }

        return source.enum;
      },
      extensions: {
        protobufField: {
          name: "enum",
          typeFullName: "testapis.deprecation.NotDeprecatedEnum",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as DeprecatedMessage | { $type: string & {}; }).$type ===
      "testapis.deprecation.DeprecatedMessage";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.deprecation.DeprecatedMessage",
      name: "DeprecatedMessage",
      package: "testapis.deprecation",
      options: { deprecated: true },
    },
  },
});

export const NotDeprecatedMessage$Ref = builder.objectRef<NotDeprecatedMessage>(
  "NotDeprecatedMessage",
);
builder.objectType(NotDeprecatedMessage$Ref, {
  name: "NotDeprecatedMessage",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      deprecationReason:
        "testapis.deprecation.NotDeprecatedMessage.body is mark as deprecated in a *.proto file.",
      extensions: {
        protobufField: {
          name: "body",
          typeFullName: "string",
          options: { deprecated: true },
        },
      },
    }),
    enum: t.field({
      type: DeprecatedEnum$Ref,
      nullable: true,
      deprecationReason:
        "testapis.deprecation.DeprecatedEnum is mark as deprecated in a *.proto file.",
      resolve: (source) => {
        if (source.enum === DeprecatedEnum.DEPRECATED_ENUM_UNSPECIFIED) {
          return null;
        }

        return source.enum;
      },
      extensions: {
        protobufField: {
          name: "enum",
          typeFullName: "testapis.deprecation.DeprecatedEnum",
        },
      },
    }),
    notDeprecatedOneof: t.field({
      type: NotDeprecatedMessageNotDeprecatedOneof$Ref,
      nullable: true,
      resolve: (source) => {
        const value = source.msg1 ?? source.msg2;
        if (value == null) {
          return null;
        }
        return value;
      },
      extensions: { protobufField: { name: "not_deprecated_oneof" } },
    }),
    deprecatedOneof: t.field({
      type: NotDeprecatedMessageDeprecatedOneof$Ref,
      nullable: true,
      deprecationReason:
        "testapis.deprecation.NotDeprecatedMessage.deprecated_oneof is mark as deprecated in a *.proto file.",
      resolve: (source) => {
        const value = source.msg3 ?? source.msg4;
        if (value == null) {
          return null;
        }
        return value;
      },
      extensions: { protobufField: { name: "deprecated_oneof" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as NotDeprecatedMessage | { $type: string & {}; }).$type ===
      "testapis.deprecation.NotDeprecatedMessage";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.deprecation.NotDeprecatedMessage",
      name: "NotDeprecatedMessage",
      package: "testapis.deprecation",
    },
  },
});

export const DeprecatedMessageInnerMessage$Ref = builder.objectRef<
  DeprecatedMessage_InnerMessage
>("DeprecatedMessageInnerMessage");
builder.objectType(DeprecatedMessageInnerMessage$Ref, {
  name: "DeprecatedMessageInnerMessage",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      deprecationReason:
        "testapis.deprecation.DeprecatedMessage is mark as deprecated in a *.proto file.",
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as DeprecatedMessage_InnerMessage | { $type: string & {}; })
      .$type ===
      "testapis.deprecation.DeprecatedMessage.InnerMessage";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.deprecation.DeprecatedMessage.InnerMessage",
      name: "InnerMessage",
      package: "testapis.deprecation",
    },
  },
});

export const NotDeprecatedMessageInnerMessage1$Ref = builder.objectRef<
  NotDeprecatedMessage_InnerMessage1
>("NotDeprecatedMessageInnerMessage1");
builder.objectType(NotDeprecatedMessageInnerMessage1$Ref, {
  name: "NotDeprecatedMessageInnerMessage1",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as NotDeprecatedMessage_InnerMessage1 | {
      $type: string & {};
    }).$type ===
      "testapis.deprecation.NotDeprecatedMessage.InnerMessage1";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.deprecation.NotDeprecatedMessage.InnerMessage1",
      name: "InnerMessage1",
      package: "testapis.deprecation",
    },
  },
});

export const NotDeprecatedMessageInnerMessage2$Ref = builder.objectRef<
  NotDeprecatedMessage_InnerMessage2
>("NotDeprecatedMessageInnerMessage2");
builder.objectType(NotDeprecatedMessageInnerMessage2$Ref, {
  name: "NotDeprecatedMessageInnerMessage2",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as NotDeprecatedMessage_InnerMessage2 | {
      $type: string & {};
    }).$type ===
      "testapis.deprecation.NotDeprecatedMessage.InnerMessage2";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.deprecation.NotDeprecatedMessage.InnerMessage2",
      name: "InnerMessage2",
      package: "testapis.deprecation",
    },
  },
});

export type DeprecatedMessageInput$Shape = {
  body?: DeprecatedMessage["body"] | null;
  enum?: DeprecatedMessage["enum"] | null;
};

export const DeprecatedMessageInput$Ref: InputObjectRef<
  DeprecatedMessageInput$Shape
> = builder.inputRef<DeprecatedMessageInput$Shape>("DeprecatedMessageInput")
  .implement(
    {
      fields: (t) => ({
        body: t.field({
          type: "String",
          required: false,
          deprecationReason:
            "testapis.deprecation.DeprecatedMessage is mark as deprecated in a *.proto file.",
          extensions: {
            protobufField: { name: "body", typeFullName: "string" },
          },
        }),
        enum: t.field({
          type: NotDeprecatedEnum$Ref,
          required: false,
          deprecationReason:
            "testapis.deprecation.DeprecatedMessage is mark as deprecated in a *.proto file.",
          extensions: {
            protobufField: {
              name: "enum",
              typeFullName: "testapis.deprecation.NotDeprecatedEnum",
            },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.deprecation.DeprecatedMessage",
          name: "DeprecatedMessage",
          package: "testapis.deprecation",
          options: { deprecated: true },
        },
      },
    },
  );

export type NotDeprecatedMessageInput$Shape = {
  body?: NotDeprecatedMessage["body"] | null;
  enum?: NotDeprecatedMessage["enum"] | null;
  msg1?: NotDeprecatedMessageInnerMessage1Input$Shape | null;
  msg2?: NotDeprecatedMessageInnerMessage2Input$Shape | null;
  msg3?: NotDeprecatedMessageInnerMessage1Input$Shape | null;
  msg4?: NotDeprecatedMessageInnerMessage2Input$Shape | null;
};

export const NotDeprecatedMessageInput$Ref: InputObjectRef<
  NotDeprecatedMessageInput$Shape
> = builder.inputRef<NotDeprecatedMessageInput$Shape>(
  "NotDeprecatedMessageInput",
).implement(
  {
    fields: (t) => ({
      body: t.field({
        type: "String",
        required: false,
        deprecationReason:
          "testapis.deprecation.NotDeprecatedMessage.body is mark as deprecated in a *.proto file.",
        extensions: {
          protobufField: {
            name: "body",
            typeFullName: "string",
            options: { deprecated: true },
          },
        },
      }),
      enum: t.field({
        type: DeprecatedEnum$Ref,
        required: false,
        deprecationReason:
          "testapis.deprecation.DeprecatedEnum is mark as deprecated in a *.proto file.",
        extensions: {
          protobufField: {
            name: "enum",
            typeFullName: "testapis.deprecation.DeprecatedEnum",
          },
        },
      }),
      msg1: t.field({
        type: NotDeprecatedMessageInnerMessage1Input$Ref,
        required: false,
        deprecationReason:
          "testapis.deprecation.NotDeprecatedMessage.msg1 is mark as deprecated in a *.proto file.",
        extensions: {
          protobufField: {
            name: "msg1",
            typeFullName:
              "testapis.deprecation.NotDeprecatedMessage.InnerMessage1",
            options: { deprecated: true },
          },
        },
      }),
      msg2: t.field({
        type: NotDeprecatedMessageInnerMessage2Input$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "msg2",
            typeFullName:
              "testapis.deprecation.NotDeprecatedMessage.InnerMessage2",
          },
        },
      }),
      msg3: t.field({
        type: NotDeprecatedMessageInnerMessage1Input$Ref,
        required: false,
        deprecationReason:
          "testapis.deprecation.NotDeprecatedMessage.msg3 is mark as deprecated in a *.proto file.",
        extensions: {
          protobufField: {
            name: "msg3",
            typeFullName:
              "testapis.deprecation.NotDeprecatedMessage.InnerMessage1",
            options: { deprecated: true },
          },
        },
      }),
      msg4: t.field({
        type: NotDeprecatedMessageInnerMessage2Input$Ref,
        required: false,
        deprecationReason:
          "testapis.deprecation.NotDeprecatedMessage.msg4 is mark as deprecated in a *.proto file.",
        extensions: {
          protobufField: {
            name: "msg4",
            typeFullName:
              "testapis.deprecation.NotDeprecatedMessage.InnerMessage2",
            options: { deprecated: true },
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.deprecation.NotDeprecatedMessage",
        name: "NotDeprecatedMessage",
        package: "testapis.deprecation",
      },
    },
  },
);

export type DeprecatedMessageInnerMessageInput$Shape = {
  body?: DeprecatedMessage_InnerMessage["body"] | null;
};

export const DeprecatedMessageInnerMessageInput$Ref: InputObjectRef<
  DeprecatedMessageInnerMessageInput$Shape
> = builder.inputRef<DeprecatedMessageInnerMessageInput$Shape>(
  "DeprecatedMessageInnerMessageInput",
).implement(
  {
    fields: (t) => ({
      body: t.field({
        type: "String",
        required: false,
        deprecationReason:
          "testapis.deprecation.DeprecatedMessage is mark as deprecated in a *.proto file.",
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.deprecation.DeprecatedMessage.InnerMessage",
        name: "InnerMessage",
        package: "testapis.deprecation",
      },
    },
  },
);

export type NotDeprecatedMessageInnerMessage1Input$Shape = {
  body: NotDeprecatedMessage_InnerMessage1["body"];
};

export const NotDeprecatedMessageInnerMessage1Input$Ref: InputObjectRef<
  NotDeprecatedMessageInnerMessage1Input$Shape
> = builder.inputRef<NotDeprecatedMessageInnerMessage1Input$Shape>(
  "NotDeprecatedMessageInnerMessage1Input",
).implement(
  {
    fields: (t) => ({
      body: t.field({
        type: "String",
        required: true,
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.deprecation.NotDeprecatedMessage.InnerMessage1",
        name: "InnerMessage1",
        package: "testapis.deprecation",
      },
    },
  },
);

export type NotDeprecatedMessageInnerMessage2Input$Shape = {
  body: NotDeprecatedMessage_InnerMessage2["body"];
};

export const NotDeprecatedMessageInnerMessage2Input$Ref: InputObjectRef<
  NotDeprecatedMessageInnerMessage2Input$Shape
> = builder.inputRef<NotDeprecatedMessageInnerMessage2Input$Shape>(
  "NotDeprecatedMessageInnerMessage2Input",
).implement(
  {
    fields: (t) => ({
      body: t.field({
        type: "String",
        required: true,
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.deprecation.NotDeprecatedMessage.InnerMessage2",
        name: "InnerMessage2",
        package: "testapis.deprecation",
      },
    },
  },
);

export const NotDeprecatedMessageNotDeprecatedOneof$Ref = builder.unionType(
  "NotDeprecatedMessageNotDeprecatedOneof",
  {
    types: [
      NotDeprecatedMessageInnerMessage1$Ref,
      NotDeprecatedMessageInnerMessage2$Ref,
    ],
    extensions: {
      protobufOneof: {
        fullName:
          "testapis.deprecation.NotDeprecatedMessage.not_deprecated_oneof",
        name: "not_deprecated_oneof",
        messageName: "NotDeprecatedMessage",
        package: "testapis.deprecation",
        fields: [{
          name: "msg1",
          type: "testapis.deprecation.NotDeprecatedMessage.InnerMessage1",
        }, {
          name: "msg2",
          type: "testapis.deprecation.NotDeprecatedMessage.InnerMessage2",
        }],
      },
    },
  },
);

export const NotDeprecatedMessageDeprecatedOneof$Ref = builder.unionType(
  "NotDeprecatedMessageDeprecatedOneof",
  {
    types: [
      NotDeprecatedMessageInnerMessage1$Ref,
      NotDeprecatedMessageInnerMessage2$Ref,
    ],
    extensions: {
      protobufOneof: {
        fullName: "testapis.deprecation.NotDeprecatedMessage.deprecated_oneof",
        name: "deprecated_oneof",
        messageName: "NotDeprecatedMessage",
        package: "testapis.deprecation",
        fields: [{
          name: "msg3",
          type: "testapis.deprecation.NotDeprecatedMessage.InnerMessage1",
        }, {
          name: "msg4",
          type: "testapis.deprecation.NotDeprecatedMessage.InnerMessage2",
        }],
      },
    },
  },
);

export const NotDeprecatedEnum$Ref: EnumRef<
  NotDeprecatedEnum,
  NotDeprecatedEnum
> = builder.enumType("NotDeprecatedEnum", {
  values: {
    NOT_DEPRECATED_FOO: {
      value: 1,
      extensions: { protobufEnumValue: { name: "NOT_DEPRECATED_FOO" } },
    },
    DEPRECATED_BAR: {
      deprecationReason:
        "testapis.deprecation.NotDeprecatedEnum.DEPRECATED_BAR is mark as deprecated in a *.proto file.",
      value: 2,
      extensions: {
        protobufEnumValue: {
          name: "DEPRECATED_BAR",
          options: { deprecated: true },
        },
      },
    },
  } as const,
  extensions: {
    protobufEnum: {
      name: "NotDeprecatedEnum",
      fullName: "testapis.deprecation.NotDeprecatedEnum",
      package: "testapis.deprecation",
    },
  },
});

export const DeprecatedEnum$Ref: EnumRef<DeprecatedEnum, DeprecatedEnum> =
  builder.enumType("DeprecatedEnum", {
    values: {
      DEPRECATED_BAZ: {
        deprecationReason:
          "testapis.deprecation.DeprecatedEnum is mark as deprecated in a *.proto file.",
        value: 1,
        extensions: { protobufEnumValue: { name: "DEPRECATED_BAZ" } },
      },
      DEPRECATED_QUX: {
        deprecationReason:
          "testapis.deprecation.DeprecatedEnum is mark as deprecated in a *.proto file.",
        value: 2,
        extensions: { protobufEnumValue: { name: "DEPRECATED_QUX" } },
      },
    } as const,
    extensions: {
      protobufEnum: {
        name: "DeprecatedEnum",
        fullName: "testapis.deprecation.DeprecatedEnum",
        package: "testapis.deprecation",
        options: { deprecated: true },
      },
    },
  });
",
    "name": "testapis/deprecation/deprecation.pb.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/deprecation/file_deprecation.proto

/* eslint-disable */

import { EnumRef, InputObjectRef } from "@pothos/core";
import { builder } from "../../builder";
import {
  DeprecatedFileEnum,
  DeprecatedFileMessage,
  DeprecatedFileMessage_InnerMessage,
} from "./testapis/deprecation/file_deprecation";

export const DeprecatedFileMessage$Ref = builder.objectRef<
  DeprecatedFileMessage
>("DeprecatedFileMessage");
builder.objectType(DeprecatedFileMessage$Ref, {
  name: "DeprecatedFileMessage",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      deprecationReason:
        "testapis/deprecation/file_deprecation.proto is mark as deprecated.",
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
    enum: t.field({
      type: DeprecatedFileEnum$Ref,
      nullable: true,
      deprecationReason:
        "testapis/deprecation/file_deprecation.proto is mark as deprecated.",
      resolve: (source) => {
        if (
          source.enum === DeprecatedFileEnum.DEPRECATED_FILE_ENUM_UNSPECIFIED
        ) {
          return null;
        }

        return source.enum;
      },
      extensions: {
        protobufField: {
          name: "enum",
          typeFullName: "testapis.deprecation.DeprecatedFileEnum",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as DeprecatedFileMessage | { $type: string & {}; }).$type ===
      "testapis.deprecation.DeprecatedFileMessage";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.deprecation.DeprecatedFileMessage",
      name: "DeprecatedFileMessage",
      package: "testapis.deprecation",
    },
  },
});

export const DeprecatedFileMessageInnerMessage$Ref = builder.objectRef<
  DeprecatedFileMessage_InnerMessage
>("DeprecatedFileMessageInnerMessage");
builder.objectType(DeprecatedFileMessageInnerMessage$Ref, {
  name: "DeprecatedFileMessageInnerMessage",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      deprecationReason:
        "testapis/deprecation/file_deprecation.proto is mark as deprecated.",
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as DeprecatedFileMessage_InnerMessage | {
      $type: string & {};
    }).$type ===
      "testapis.deprecation.DeprecatedFileMessage.InnerMessage";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.deprecation.DeprecatedFileMessage.InnerMessage",
      name: "InnerMessage",
      package: "testapis.deprecation",
    },
  },
});

export type DeprecatedFileMessageInput$Shape = {
  body?: DeprecatedFileMessage["body"] | null;
  enum?: DeprecatedFileMessage["enum"] | null;
};

export const DeprecatedFileMessageInput$Ref: InputObjectRef<
  DeprecatedFileMessageInput$Shape
> = builder.inputRef<DeprecatedFileMessageInput$Shape>(
  "DeprecatedFileMessageInput",
).implement(
  {
    fields: (t) => ({
      body: t.field({
        type: "String",
        required: false,
        deprecationReason:
          "testapis/deprecation/file_deprecation.proto is mark as deprecated.",
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
      enum: t.field({
        type: DeprecatedFileEnum$Ref,
        required: false,
        deprecationReason:
          "testapis/deprecation/file_deprecation.proto is mark as deprecated.",
        extensions: {
          protobufField: {
            name: "enum",
            typeFullName: "testapis.deprecation.DeprecatedFileEnum",
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.deprecation.DeprecatedFileMessage",
        name: "DeprecatedFileMessage",
        package: "testapis.deprecation",
      },
    },
  },
);

export type DeprecatedFileMessageInnerMessageInput$Shape = {
  body?: DeprecatedFileMessage_InnerMessage["body"] | null;
};

export const DeprecatedFileMessageInnerMessageInput$Ref: InputObjectRef<
  DeprecatedFileMessageInnerMessageInput$Shape
> = builder.inputRef<DeprecatedFileMessageInnerMessageInput$Shape>(
  "DeprecatedFileMessageInnerMessageInput",
).implement(
  {
    fields: (t) => ({
      body: t.field({
        type: "String",
        required: false,
        deprecationReason:
          "testapis/deprecation/file_deprecation.proto is mark as deprecated.",
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.deprecation.DeprecatedFileMessage.InnerMessage",
        name: "InnerMessage",
        package: "testapis.deprecation",
      },
    },
  },
);

export const DeprecatedFileEnum$Ref: EnumRef<
  DeprecatedFileEnum,
  DeprecatedFileEnum
> = builder.enumType("DeprecatedFileEnum", {
  values: {
    DEPRECATED_FILE_FOO: {
      deprecationReason:
        "testapis/deprecation/file_deprecation.proto is mark as deprecated.",
      value: 1,
      extensions: { protobufEnumValue: { name: "DEPRECATED_FILE_FOO" } },
    },
    DEPRECATED_FILE_BAR: {
      deprecationReason:
        "testapis/deprecation/file_deprecation.proto is mark as deprecated.",
      value: 2,
      extensions: { protobufEnumValue: { name: "DEPRECATED_FILE_BAR" } },
    },
  } as const,
  extensions: {
    protobufEnum: {
      name: "DeprecatedFileEnum",
      fullName: "testapis.deprecation.DeprecatedFileEnum",
      package: "testapis.deprecation",
    },
  },
});
",
    "name": "testapis/deprecation/file_deprecation.pb.pothos.ts",
  },
]
`;

exports[`'testapis.edgecases.import_from_same_pkg' > generates files by plugin 'with import prefix' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/edgecases/import_from_same_pkg/child.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { ChildMessage } from "@testapis/ts-proto/testapis/edgecases/import_from_same_pkg/child";
import { builder } from "../../../builder";

export const ChildMessage$Ref = builder.objectRef<ChildMessage>("ChildMessage");
builder.objectType(ChildMessage$Ref, {
  name: "ChildMessage",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as ChildMessage | { $type: string & {}; }).$type ===
      "testapis.edgecases.import_from_same_pkg.ChildMessage";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.edgecases.import_from_same_pkg.ChildMessage",
      name: "ChildMessage",
      package: "testapis.edgecases.import_from_same_pkg",
    },
  },
});

export type ChildMessageInput$Shape = {
  body: ChildMessage["body"];
};

export const ChildMessageInput$Ref: InputObjectRef<ChildMessageInput$Shape> =
  builder.inputRef<ChildMessageInput$Shape>("ChildMessageInput").implement(
    {
      fields: (t) => ({
        body: t.field({
          type: "String",
          required: true,
          extensions: {
            protobufField: { name: "body", typeFullName: "string" },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.edgecases.import_from_same_pkg.ChildMessage",
          name: "ChildMessage",
          package: "testapis.edgecases.import_from_same_pkg",
        },
      },
    },
  );
",
    "name": "testapis/edgecases/import_from_same_pkg/child.pb.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/edgecases/import_from_same_pkg/parent.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { ParentMessage } from "@testapis/ts-proto/testapis/edgecases/import_from_same_pkg/parent";
import { builder } from "../../../builder";
import {
  ChildMessage$Ref,
  ChildMessageInput$Ref,
  ChildMessageInput$Shape,
} from "./child.pb.pothos";

export const ParentMessage$Ref = builder.objectRef<ParentMessage>(
  "ParentMessage",
);
builder.objectType(ParentMessage$Ref, {
  name: "ParentMessage",
  fields: (t) => ({
    child: t.expose("child", {
      type: ChildMessage$Ref,
      nullable: true,
      extensions: {
        protobufField: {
          name: "child",
          typeFullName: "testapis.edgecases.import_from_same_pkg.ChildMessage",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as ParentMessage | { $type: string & {}; }).$type ===
      "testapis.edgecases.import_from_same_pkg.ParentMessage";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.edgecases.import_from_same_pkg.ParentMessage",
      name: "ParentMessage",
      package: "testapis.edgecases.import_from_same_pkg",
    },
  },
});

export type ParentMessageInput$Shape = {
  child?: ChildMessageInput$Shape | null;
};

export const ParentMessageInput$Ref: InputObjectRef<ParentMessageInput$Shape> =
  builder.inputRef<ParentMessageInput$Shape>("ParentMessageInput").implement(
    {
      fields: (t) => ({
        child: t.field({
          type: ChildMessageInput$Ref,
          required: false,
          extensions: {
            protobufField: {
              name: "child",
              typeFullName:
                "testapis.edgecases.import_from_same_pkg.ChildMessage",
            },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.edgecases.import_from_same_pkg.ParentMessage",
          name: "ParentMessage",
          package: "testapis.edgecases.import_from_same_pkg",
        },
      },
    },
  );
",
    "name": "testapis/edgecases/import_from_same_pkg/parent.pb.pothos.ts",
  },
]
`;

exports[`'testapis.edgecases.import_from_same_pkg' > generates files by plugin 'with partial inputs' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/edgecases/import_from_same_pkg/child.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { ChildMessage } from "@testapis/ts-proto/testapis/edgecases/import_from_same_pkg/child";
import { builder } from "../../../builder";

export const ChildMessage$Ref = builder.objectRef<ChildMessage>("ChildMessage");
builder.objectType(ChildMessage$Ref, {
  name: "ChildMessage",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as ChildMessage | { $type: string & {}; }).$type ===
      "testapis.edgecases.import_from_same_pkg.ChildMessage";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.edgecases.import_from_same_pkg.ChildMessage",
      name: "ChildMessage",
      package: "testapis.edgecases.import_from_same_pkg",
    },
  },
});

export type ChildMessageInput$Shape = {
  body: ChildMessage["body"];
};

export const ChildMessageInput$Ref: InputObjectRef<ChildMessageInput$Shape> =
  builder.inputRef<ChildMessageInput$Shape>("ChildMessageInput").implement(
    {
      fields: (t) => ({
        body: t.field({
          type: "String",
          required: true,
          extensions: {
            protobufField: { name: "body", typeFullName: "string" },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.edgecases.import_from_same_pkg.ChildMessage",
          name: "ChildMessage",
          package: "testapis.edgecases.import_from_same_pkg",
        },
      },
    },
  );

export type ChildMessagePartialInput$Shape = {
  body?: ChildMessage["body"] | null;
};

export const ChildMessagePartialInput$Ref: InputObjectRef<
  ChildMessagePartialInput$Shape
> = builder.inputRef<ChildMessagePartialInput$Shape>("ChildMessagePartialInput")
  .implement(
    {
      fields: (t) => ({
        body: t.field({
          type: "String",
          required: false,
          extensions: {
            protobufField: { name: "body", typeFullName: "string" },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.edgecases.import_from_same_pkg.ChildMessage",
          name: "ChildMessage",
          package: "testapis.edgecases.import_from_same_pkg",
        },
      },
    },
  );
",
    "name": "testapis/edgecases/import_from_same_pkg/child.pb.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/edgecases/import_from_same_pkg/parent.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { ParentMessage } from "@testapis/ts-proto/testapis/edgecases/import_from_same_pkg/parent";
import { builder } from "../../../builder";
import {
  ChildMessage$Ref,
  ChildMessageInput$Ref,
  ChildMessageInput$Shape,
  ChildMessagePartialInput$Ref,
  ChildMessagePartialInput$Shape,
} from "./child.pb.pothos";

export const ParentMessage$Ref = builder.objectRef<ParentMessage>(
  "ParentMessage",
);
builder.objectType(ParentMessage$Ref, {
  name: "ParentMessage",
  fields: (t) => ({
    child: t.expose("child", {
      type: ChildMessage$Ref,
      nullable: true,
      extensions: {
        protobufField: {
          name: "child",
          typeFullName: "testapis.edgecases.import_from_same_pkg.ChildMessage",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as ParentMessage | { $type: string & {}; }).$type ===
      "testapis.edgecases.import_from_same_pkg.ParentMessage";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.edgecases.import_from_same_pkg.ParentMessage",
      name: "ParentMessage",
      package: "testapis.edgecases.import_from_same_pkg",
    },
  },
});

export type ParentMessageInput$Shape = {
  child?: ChildMessageInput$Shape | null;
};

export const ParentMessageInput$Ref: InputObjectRef<ParentMessageInput$Shape> =
  builder.inputRef<ParentMessageInput$Shape>("ParentMessageInput").implement(
    {
      fields: (t) => ({
        child: t.field({
          type: ChildMessageInput$Ref,
          required: false,
          extensions: {
            protobufField: {
              name: "child",
              typeFullName:
                "testapis.edgecases.import_from_same_pkg.ChildMessage",
            },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.edgecases.import_from_same_pkg.ParentMessage",
          name: "ParentMessage",
          package: "testapis.edgecases.import_from_same_pkg",
        },
      },
    },
  );

export type ParentMessagePartialInput$Shape = {
  child?: ChildMessagePartialInput$Shape | null;
};

export const ParentMessagePartialInput$Ref: InputObjectRef<
  ParentMessagePartialInput$Shape
> = builder.inputRef<ParentMessagePartialInput$Shape>(
  "ParentMessagePartialInput",
).implement(
  {
    fields: (t) => ({
      child: t.field({
        type: ChildMessagePartialInput$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "child",
            typeFullName:
              "testapis.edgecases.import_from_same_pkg.ChildMessage",
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.edgecases.import_from_same_pkg.ParentMessage",
        name: "ParentMessage",
        package: "testapis.edgecases.import_from_same_pkg",
      },
    },
  },
);
",
    "name": "testapis/edgecases/import_from_same_pkg/parent.pb.pothos.ts",
  },
]
`;

exports[`'testapis.edgecases.import_from_same_pkg' > generates files by plugin 'without import prefix' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/edgecases/import_from_same_pkg/child.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { builder } from "../../../builder";
import { ChildMessage } from "./testapis/edgecases/import_from_same_pkg/child";

export const ChildMessage$Ref = builder.objectRef<ChildMessage>("ChildMessage");
builder.objectType(ChildMessage$Ref, {
  name: "ChildMessage",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as ChildMessage | { $type: string & {}; }).$type ===
      "testapis.edgecases.import_from_same_pkg.ChildMessage";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.edgecases.import_from_same_pkg.ChildMessage",
      name: "ChildMessage",
      package: "testapis.edgecases.import_from_same_pkg",
    },
  },
});

export type ChildMessageInput$Shape = {
  body: ChildMessage["body"];
};

export const ChildMessageInput$Ref: InputObjectRef<ChildMessageInput$Shape> =
  builder.inputRef<ChildMessageInput$Shape>("ChildMessageInput").implement(
    {
      fields: (t) => ({
        body: t.field({
          type: "String",
          required: true,
          extensions: {
            protobufField: { name: "body", typeFullName: "string" },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.edgecases.import_from_same_pkg.ChildMessage",
          name: "ChildMessage",
          package: "testapis.edgecases.import_from_same_pkg",
        },
      },
    },
  );
",
    "name": "testapis/edgecases/import_from_same_pkg/child.pb.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/edgecases/import_from_same_pkg/parent.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { builder } from "../../../builder";
import {
  ChildMessage$Ref,
  ChildMessageInput$Ref,
  ChildMessageInput$Shape,
} from "./child.pb.pothos";
import { ParentMessage } from "./testapis/edgecases/import_from_same_pkg/parent";

export const ParentMessage$Ref = builder.objectRef<ParentMessage>(
  "ParentMessage",
);
builder.objectType(ParentMessage$Ref, {
  name: "ParentMessage",
  fields: (t) => ({
    child: t.expose("child", {
      type: ChildMessage$Ref,
      nullable: true,
      extensions: {
        protobufField: {
          name: "child",
          typeFullName: "testapis.edgecases.import_from_same_pkg.ChildMessage",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as ParentMessage | { $type: string & {}; }).$type ===
      "testapis.edgecases.import_from_same_pkg.ParentMessage";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.edgecases.import_from_same_pkg.ParentMessage",
      name: "ParentMessage",
      package: "testapis.edgecases.import_from_same_pkg",
    },
  },
});

export type ParentMessageInput$Shape = {
  child?: ChildMessageInput$Shape | null;
};

export const ParentMessageInput$Ref: InputObjectRef<ParentMessageInput$Shape> =
  builder.inputRef<ParentMessageInput$Shape>("ParentMessageInput").implement(
    {
      fields: (t) => ({
        child: t.field({
          type: ChildMessageInput$Ref,
          required: false,
          extensions: {
            protobufField: {
              name: "child",
              typeFullName:
                "testapis.edgecases.import_from_same_pkg.ChildMessage",
            },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.edgecases.import_from_same_pkg.ParentMessage",
          name: "ParentMessage",
          package: "testapis.edgecases.import_from_same_pkg",
        },
      },
    },
  );
",
    "name": "testapis/edgecases/import_from_same_pkg/parent.pb.pothos.ts",
  },
]
`;

exports[`'testapis.edgecases.import_oneof_member_from_other_file' > generates files by plugin 'with import prefix' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/edgecases/import_oneof_member_from_other_file/member.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import {
  OneofMember1,
  OneofMember2,
} from "@testapis/ts-proto/testapis/edgecases/import_oneof_member_from_other_file/member";
import { builder } from "../../../builder";

export const OneofMember1$Ref = builder.objectRef<OneofMember1>("OneofMember1");
builder.objectType(OneofMember1$Ref, {
  name: "OneofMember1",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as OneofMember1 | { $type: string & {}; }).$type ===
      "testapis.edgecases.import_oneof_member_from_other_file.OneofMember1";
  },
  extensions: {
    protobufMessage: {
      fullName:
        "testapis.edgecases.import_oneof_member_from_other_file.OneofMember1",
      name: "OneofMember1",
      package: "testapis.edgecases.import_oneof_member_from_other_file",
    },
  },
});

export const OneofMember2$Ref = builder.objectRef<OneofMember2>("OneofMember2");
builder.objectType(OneofMember2$Ref, {
  name: "OneofMember2",
  fields: (t) => ({
    count: t.expose("count", {
      type: "Int",
      nullable: false,
      extensions: { protobufField: { name: "count", typeFullName: "int32" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as OneofMember2 | { $type: string & {}; }).$type ===
      "testapis.edgecases.import_oneof_member_from_other_file.OneofMember2";
  },
  extensions: {
    protobufMessage: {
      fullName:
        "testapis.edgecases.import_oneof_member_from_other_file.OneofMember2",
      name: "OneofMember2",
      package: "testapis.edgecases.import_oneof_member_from_other_file",
    },
  },
});

export type OneofMember1Input$Shape = {
  body: OneofMember1["body"];
};

export const OneofMember1Input$Ref: InputObjectRef<OneofMember1Input$Shape> =
  builder.inputRef<OneofMember1Input$Shape>("OneofMember1Input").implement(
    {
      fields: (t) => ({
        body: t.field({
          type: "String",
          required: true,
          extensions: {
            protobufField: { name: "body", typeFullName: "string" },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName:
            "testapis.edgecases.import_oneof_member_from_other_file.OneofMember1",
          name: "OneofMember1",
          package: "testapis.edgecases.import_oneof_member_from_other_file",
        },
      },
    },
  );

export type OneofMember2Input$Shape = {
  count: OneofMember2["count"];
};

export const OneofMember2Input$Ref: InputObjectRef<OneofMember2Input$Shape> =
  builder.inputRef<OneofMember2Input$Shape>("OneofMember2Input").implement(
    {
      fields: (t) => ({
        count: t.field({
          type: "Int",
          required: true,
          extensions: {
            protobufField: { name: "count", typeFullName: "int32" },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName:
            "testapis.edgecases.import_oneof_member_from_other_file.OneofMember2",
          name: "OneofMember2",
          package: "testapis.edgecases.import_oneof_member_from_other_file",
        },
      },
    },
  );
",
    "name": "testapis/edgecases/import_oneof_member_from_other_file/member.pb.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/edgecases/import_oneof_member_from_other_file/parent.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { OneofParent } from "@testapis/ts-proto/testapis/edgecases/import_oneof_member_from_other_file/parent";
import { builder } from "../../../builder";
import {
  OneofMember1$Ref,
  OneofMember1Input$Ref,
  OneofMember1Input$Shape,
  OneofMember2$Ref,
  OneofMember2Input$Ref,
  OneofMember2Input$Shape,
} from "./member.pb.pothos";

export const OneofParent$Ref = builder.objectRef<OneofParent>("OneofParent");
builder.objectType(OneofParent$Ref, {
  name: "OneofParent",
  fields: (t) => ({
    oneofField: t.field({
      type: OneofParentOneofField$Ref,
      nullable: true,
      resolve: (source) => {
        const value = source.member1 ?? source.member2;
        if (value == null) {
          return null;
        }
        return value;
      },
      extensions: { protobufField: { name: "oneof_field" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as OneofParent | { $type: string & {}; }).$type ===
      "testapis.edgecases.import_oneof_member_from_other_file.OneofParent";
  },
  extensions: {
    protobufMessage: {
      fullName:
        "testapis.edgecases.import_oneof_member_from_other_file.OneofParent",
      name: "OneofParent",
      package: "testapis.edgecases.import_oneof_member_from_other_file",
    },
  },
});

export type OneofParentInput$Shape = {
  member1?: OneofMember1Input$Shape | null;
  member2?: OneofMember2Input$Shape | null;
};

export const OneofParentInput$Ref: InputObjectRef<OneofParentInput$Shape> =
  builder.inputRef<OneofParentInput$Shape>("OneofParentInput").implement(
    {
      fields: (t) => ({
        member1: t.field({
          type: OneofMember1Input$Ref,
          required: false,
          extensions: {
            protobufField: {
              name: "member1",
              typeFullName:
                "testapis.edgecases.import_oneof_member_from_other_file.OneofMember1",
            },
          },
        }),
        member2: t.field({
          type: OneofMember2Input$Ref,
          required: false,
          extensions: {
            protobufField: {
              name: "member2",
              typeFullName:
                "testapis.edgecases.import_oneof_member_from_other_file.OneofMember2",
            },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName:
            "testapis.edgecases.import_oneof_member_from_other_file.OneofParent",
          name: "OneofParent",
          package: "testapis.edgecases.import_oneof_member_from_other_file",
        },
      },
    },
  );

export const OneofParentOneofField$Ref = builder.unionType(
  "OneofParentOneofField",
  {
    types: [OneofMember1$Ref, OneofMember2$Ref],
    extensions: {
      protobufOneof: {
        fullName:
          "testapis.edgecases.import_oneof_member_from_other_file.OneofParent.oneof_field",
        name: "oneof_field",
        messageName: "OneofParent",
        package: "testapis.edgecases.import_oneof_member_from_other_file",
        fields: [{
          name: "member1",
          type:
            "testapis.edgecases.import_oneof_member_from_other_file.OneofMember1",
        }, {
          name: "member2",
          type:
            "testapis.edgecases.import_oneof_member_from_other_file.OneofMember2",
        }],
      },
    },
  },
);
",
    "name": "testapis/edgecases/import_oneof_member_from_other_file/parent.pb.pothos.ts",
  },
]
`;

exports[`'testapis.edgecases.import_oneof_member_from_other_file' > generates files by plugin 'with partial inputs' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/edgecases/import_oneof_member_from_other_file/member.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import {
  OneofMember1,
  OneofMember2,
} from "@testapis/ts-proto/testapis/edgecases/import_oneof_member_from_other_file/member";
import { builder } from "../../../builder";

export const OneofMember1$Ref = builder.objectRef<OneofMember1>("OneofMember1");
builder.objectType(OneofMember1$Ref, {
  name: "OneofMember1",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as OneofMember1 | { $type: string & {}; }).$type ===
      "testapis.edgecases.import_oneof_member_from_other_file.OneofMember1";
  },
  extensions: {
    protobufMessage: {
      fullName:
        "testapis.edgecases.import_oneof_member_from_other_file.OneofMember1",
      name: "OneofMember1",
      package: "testapis.edgecases.import_oneof_member_from_other_file",
    },
  },
});

export const OneofMember2$Ref = builder.objectRef<OneofMember2>("OneofMember2");
builder.objectType(OneofMember2$Ref, {
  name: "OneofMember2",
  fields: (t) => ({
    count: t.expose("count", {
      type: "Int",
      nullable: false,
      extensions: { protobufField: { name: "count", typeFullName: "int32" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as OneofMember2 | { $type: string & {}; }).$type ===
      "testapis.edgecases.import_oneof_member_from_other_file.OneofMember2";
  },
  extensions: {
    protobufMessage: {
      fullName:
        "testapis.edgecases.import_oneof_member_from_other_file.OneofMember2",
      name: "OneofMember2",
      package: "testapis.edgecases.import_oneof_member_from_other_file",
    },
  },
});

export type OneofMember1Input$Shape = {
  body: OneofMember1["body"];
};

export const OneofMember1Input$Ref: InputObjectRef<OneofMember1Input$Shape> =
  builder.inputRef<OneofMember1Input$Shape>("OneofMember1Input").implement(
    {
      fields: (t) => ({
        body: t.field({
          type: "String",
          required: true,
          extensions: {
            protobufField: { name: "body", typeFullName: "string" },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName:
            "testapis.edgecases.import_oneof_member_from_other_file.OneofMember1",
          name: "OneofMember1",
          package: "testapis.edgecases.import_oneof_member_from_other_file",
        },
      },
    },
  );

export type OneofMember1PartialInput$Shape = {
  body?: OneofMember1["body"] | null;
};

export const OneofMember1PartialInput$Ref: InputObjectRef<
  OneofMember1PartialInput$Shape
> = builder.inputRef<OneofMember1PartialInput$Shape>("OneofMember1PartialInput")
  .implement(
    {
      fields: (t) => ({
        body: t.field({
          type: "String",
          required: false,
          extensions: {
            protobufField: { name: "body", typeFullName: "string" },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName:
            "testapis.edgecases.import_oneof_member_from_other_file.OneofMember1",
          name: "OneofMember1",
          package: "testapis.edgecases.import_oneof_member_from_other_file",
        },
      },
    },
  );

export type OneofMember2Input$Shape = {
  count: OneofMember2["count"];
};

export const OneofMember2Input$Ref: InputObjectRef<OneofMember2Input$Shape> =
  builder.inputRef<OneofMember2Input$Shape>("OneofMember2Input").implement(
    {
      fields: (t) => ({
        count: t.field({
          type: "Int",
          required: true,
          extensions: {
            protobufField: { name: "count", typeFullName: "int32" },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName:
            "testapis.edgecases.import_oneof_member_from_other_file.OneofMember2",
          name: "OneofMember2",
          package: "testapis.edgecases.import_oneof_member_from_other_file",
        },
      },
    },
  );

export type OneofMember2PartialInput$Shape = {
  count?: OneofMember2["count"] | null;
};

export const OneofMember2PartialInput$Ref: InputObjectRef<
  OneofMember2PartialInput$Shape
> = builder.inputRef<OneofMember2PartialInput$Shape>("OneofMember2PartialInput")
  .implement(
    {
      fields: (t) => ({
        count: t.field({
          type: "Int",
          required: false,
          extensions: {
            protobufField: { name: "count", typeFullName: "int32" },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName:
            "testapis.edgecases.import_oneof_member_from_other_file.OneofMember2",
          name: "OneofMember2",
          package: "testapis.edgecases.import_oneof_member_from_other_file",
        },
      },
    },
  );
",
    "name": "testapis/edgecases/import_oneof_member_from_other_file/member.pb.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/edgecases/import_oneof_member_from_other_file/parent.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { OneofParent } from "@testapis/ts-proto/testapis/edgecases/import_oneof_member_from_other_file/parent";
import { builder } from "../../../builder";
import {
  OneofMember1$Ref,
  OneofMember1Input$Ref,
  OneofMember1Input$Shape,
  OneofMember1PartialInput$Ref,
  OneofMember1PartialInput$Shape,
  OneofMember2$Ref,
  OneofMember2Input$Ref,
  OneofMember2Input$Shape,
  OneofMember2PartialInput$Ref,
  OneofMember2PartialInput$Shape,
} from "./member.pb.pothos";

export const OneofParent$Ref = builder.objectRef<OneofParent>("OneofParent");
builder.objectType(OneofParent$Ref, {
  name: "OneofParent",
  fields: (t) => ({
    oneofField: t.field({
      type: OneofParentOneofField$Ref,
      nullable: true,
      resolve: (source) => {
        const value = source.member1 ?? source.member2;
        if (value == null) {
          return null;
        }
        return value;
      },
      extensions: { protobufField: { name: "oneof_field" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as OneofParent | { $type: string & {}; }).$type ===
      "testapis.edgecases.import_oneof_member_from_other_file.OneofParent";
  },
  extensions: {
    protobufMessage: {
      fullName:
        "testapis.edgecases.import_oneof_member_from_other_file.OneofParent",
      name: "OneofParent",
      package: "testapis.edgecases.import_oneof_member_from_other_file",
    },
  },
});

export type OneofParentInput$Shape = {
  member1?: OneofMember1Input$Shape | null;
  member2?: OneofMember2Input$Shape | null;
};

export const OneofParentInput$Ref: InputObjectRef<OneofParentInput$Shape> =
  builder.inputRef<OneofParentInput$Shape>("OneofParentInput").implement(
    {
      fields: (t) => ({
        member1: t.field({
          type: OneofMember1Input$Ref,
          required: false,
          extensions: {
            protobufField: {
              name: "member1",
              typeFullName:
                "testapis.edgecases.import_oneof_member_from_other_file.OneofMember1",
            },
          },
        }),
        member2: t.field({
          type: OneofMember2Input$Ref,
          required: false,
          extensions: {
            protobufField: {
              name: "member2",
              typeFullName:
                "testapis.edgecases.import_oneof_member_from_other_file.OneofMember2",
            },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName:
            "testapis.edgecases.import_oneof_member_from_other_file.OneofParent",
          name: "OneofParent",
          package: "testapis.edgecases.import_oneof_member_from_other_file",
        },
      },
    },
  );

export type OneofParentPartialInput$Shape = {
  member1?: OneofMember1PartialInput$Shape | null;
  member2?: OneofMember2PartialInput$Shape | null;
};

export const OneofParentPartialInput$Ref: InputObjectRef<
  OneofParentPartialInput$Shape
> = builder.inputRef<OneofParentPartialInput$Shape>("OneofParentPartialInput")
  .implement(
    {
      fields: (t) => ({
        member1: t.field({
          type: OneofMember1PartialInput$Ref,
          required: false,
          extensions: {
            protobufField: {
              name: "member1",
              typeFullName:
                "testapis.edgecases.import_oneof_member_from_other_file.OneofMember1",
            },
          },
        }),
        member2: t.field({
          type: OneofMember2PartialInput$Ref,
          required: false,
          extensions: {
            protobufField: {
              name: "member2",
              typeFullName:
                "testapis.edgecases.import_oneof_member_from_other_file.OneofMember2",
            },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName:
            "testapis.edgecases.import_oneof_member_from_other_file.OneofParent",
          name: "OneofParent",
          package: "testapis.edgecases.import_oneof_member_from_other_file",
        },
      },
    },
  );

export const OneofParentOneofField$Ref = builder.unionType(
  "OneofParentOneofField",
  {
    types: [OneofMember1$Ref, OneofMember2$Ref],
    extensions: {
      protobufOneof: {
        fullName:
          "testapis.edgecases.import_oneof_member_from_other_file.OneofParent.oneof_field",
        name: "oneof_field",
        messageName: "OneofParent",
        package: "testapis.edgecases.import_oneof_member_from_other_file",
        fields: [{
          name: "member1",
          type:
            "testapis.edgecases.import_oneof_member_from_other_file.OneofMember1",
        }, {
          name: "member2",
          type:
            "testapis.edgecases.import_oneof_member_from_other_file.OneofMember2",
        }],
      },
    },
  },
);
",
    "name": "testapis/edgecases/import_oneof_member_from_other_file/parent.pb.pothos.ts",
  },
]
`;

exports[`'testapis.edgecases.import_oneof_member_from_other_file' > generates files by plugin 'without import prefix' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/edgecases/import_oneof_member_from_other_file/member.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { builder } from "../../../builder";
import {
  OneofMember1,
  OneofMember2,
} from "./testapis/edgecases/import_oneof_member_from_other_file/member";

export const OneofMember1$Ref = builder.objectRef<OneofMember1>("OneofMember1");
builder.objectType(OneofMember1$Ref, {
  name: "OneofMember1",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as OneofMember1 | { $type: string & {}; }).$type ===
      "testapis.edgecases.import_oneof_member_from_other_file.OneofMember1";
  },
  extensions: {
    protobufMessage: {
      fullName:
        "testapis.edgecases.import_oneof_member_from_other_file.OneofMember1",
      name: "OneofMember1",
      package: "testapis.edgecases.import_oneof_member_from_other_file",
    },
  },
});

export const OneofMember2$Ref = builder.objectRef<OneofMember2>("OneofMember2");
builder.objectType(OneofMember2$Ref, {
  name: "OneofMember2",
  fields: (t) => ({
    count: t.expose("count", {
      type: "Int",
      nullable: false,
      extensions: { protobufField: { name: "count", typeFullName: "int32" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as OneofMember2 | { $type: string & {}; }).$type ===
      "testapis.edgecases.import_oneof_member_from_other_file.OneofMember2";
  },
  extensions: {
    protobufMessage: {
      fullName:
        "testapis.edgecases.import_oneof_member_from_other_file.OneofMember2",
      name: "OneofMember2",
      package: "testapis.edgecases.import_oneof_member_from_other_file",
    },
  },
});

export type OneofMember1Input$Shape = {
  body: OneofMember1["body"];
};

export const OneofMember1Input$Ref: InputObjectRef<OneofMember1Input$Shape> =
  builder.inputRef<OneofMember1Input$Shape>("OneofMember1Input").implement(
    {
      fields: (t) => ({
        body: t.field({
          type: "String",
          required: true,
          extensions: {
            protobufField: { name: "body", typeFullName: "string" },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName:
            "testapis.edgecases.import_oneof_member_from_other_file.OneofMember1",
          name: "OneofMember1",
          package: "testapis.edgecases.import_oneof_member_from_other_file",
        },
      },
    },
  );

export type OneofMember2Input$Shape = {
  count: OneofMember2["count"];
};

export const OneofMember2Input$Ref: InputObjectRef<OneofMember2Input$Shape> =
  builder.inputRef<OneofMember2Input$Shape>("OneofMember2Input").implement(
    {
      fields: (t) => ({
        count: t.field({
          type: "Int",
          required: true,
          extensions: {
            protobufField: { name: "count", typeFullName: "int32" },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName:
            "testapis.edgecases.import_oneof_member_from_other_file.OneofMember2",
          name: "OneofMember2",
          package: "testapis.edgecases.import_oneof_member_from_other_file",
        },
      },
    },
  );
",
    "name": "testapis/edgecases/import_oneof_member_from_other_file/member.pb.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/edgecases/import_oneof_member_from_other_file/parent.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { builder } from "../../../builder";
import {
  OneofMember1$Ref,
  OneofMember1Input$Ref,
  OneofMember1Input$Shape,
  OneofMember2$Ref,
  OneofMember2Input$Ref,
  OneofMember2Input$Shape,
} from "./member.pb.pothos";
import { OneofParent } from "./testapis/edgecases/import_oneof_member_from_other_file/parent";

export const OneofParent$Ref = builder.objectRef<OneofParent>("OneofParent");
builder.objectType(OneofParent$Ref, {
  name: "OneofParent",
  fields: (t) => ({
    oneofField: t.field({
      type: OneofParentOneofField$Ref,
      nullable: true,
      resolve: (source) => {
        const value = source.member1 ?? source.member2;
        if (value == null) {
          return null;
        }
        return value;
      },
      extensions: { protobufField: { name: "oneof_field" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as OneofParent | { $type: string & {}; }).$type ===
      "testapis.edgecases.import_oneof_member_from_other_file.OneofParent";
  },
  extensions: {
    protobufMessage: {
      fullName:
        "testapis.edgecases.import_oneof_member_from_other_file.OneofParent",
      name: "OneofParent",
      package: "testapis.edgecases.import_oneof_member_from_other_file",
    },
  },
});

export type OneofParentInput$Shape = {
  member1?: OneofMember1Input$Shape | null;
  member2?: OneofMember2Input$Shape | null;
};

export const OneofParentInput$Ref: InputObjectRef<OneofParentInput$Shape> =
  builder.inputRef<OneofParentInput$Shape>("OneofParentInput").implement(
    {
      fields: (t) => ({
        member1: t.field({
          type: OneofMember1Input$Ref,
          required: false,
          extensions: {
            protobufField: {
              name: "member1",
              typeFullName:
                "testapis.edgecases.import_oneof_member_from_other_file.OneofMember1",
            },
          },
        }),
        member2: t.field({
          type: OneofMember2Input$Ref,
          required: false,
          extensions: {
            protobufField: {
              name: "member2",
              typeFullName:
                "testapis.edgecases.import_oneof_member_from_other_file.OneofMember2",
            },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName:
            "testapis.edgecases.import_oneof_member_from_other_file.OneofParent",
          name: "OneofParent",
          package: "testapis.edgecases.import_oneof_member_from_other_file",
        },
      },
    },
  );

export const OneofParentOneofField$Ref = builder.unionType(
  "OneofParentOneofField",
  {
    types: [OneofMember1$Ref, OneofMember2$Ref],
    extensions: {
      protobufOneof: {
        fullName:
          "testapis.edgecases.import_oneof_member_from_other_file.OneofParent.oneof_field",
        name: "oneof_field",
        messageName: "OneofParent",
        package: "testapis.edgecases.import_oneof_member_from_other_file",
        fields: [{
          name: "member1",
          type:
            "testapis.edgecases.import_oneof_member_from_other_file.OneofMember1",
        }, {
          name: "member2",
          type:
            "testapis.edgecases.import_oneof_member_from_other_file.OneofMember2",
        }],
      },
    },
  },
);
",
    "name": "testapis/edgecases/import_oneof_member_from_other_file/parent.pb.pothos.ts",
  },
]
`;

exports[`'testapis.edgecases.import_squashed_union' > generates files by plugin 'with import prefix' 1`] = `[]`;

exports[`'testapis.edgecases.import_squashed_union' > generates files by plugin 'with partial inputs' 1`] = `[]`;

exports[`'testapis.edgecases.import_squashed_union' > generates files by plugin 'without import prefix' 1`] = `[]`;

exports[`'testapis.edgecases.import_squashed_union.pkg1' > generates files by plugin 'with import prefix' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/edgecases/import_squashed_union/pkg1/types.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { OneofMessage1 } from "@testapis/ts-proto/testapis/edgecases/import_squashed_union/pkg1/types";
import { builder } from "../../../../builder";

export const OneofMessage1$Ref = builder.objectRef<OneofMessage1>(
  "OneofMessage1",
);
builder.objectType(OneofMessage1$Ref, {
  name: "OneofMessage1",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as OneofMessage1 | { $type: string & {}; }).$type ===
      "testapis.edgecases.import_squashed_union.pkg1.OneofMessage1";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.edgecases.import_squashed_union.pkg1.OneofMessage1",
      name: "OneofMessage1",
      package: "testapis.edgecases.import_squashed_union.pkg1",
    },
  },
});

export type OneofMessage1Input$Shape = {
  body: OneofMessage1["body"];
};

export const OneofMessage1Input$Ref: InputObjectRef<OneofMessage1Input$Shape> =
  builder.inputRef<OneofMessage1Input$Shape>("OneofMessage1Input").implement(
    {
      fields: (t) => ({
        body: t.field({
          type: "String",
          required: true,
          extensions: {
            protobufField: { name: "body", typeFullName: "string" },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName:
            "testapis.edgecases.import_squashed_union.pkg1.OneofMessage1",
          name: "OneofMessage1",
          package: "testapis.edgecases.import_squashed_union.pkg1",
        },
      },
    },
  );

export type SquashedOneofInput$Shape = {
  msg1?: OneofMessage1Input$Shape | null;
};

export const SquashedOneofInput$Ref: InputObjectRef<SquashedOneofInput$Shape> =
  builder.inputRef<SquashedOneofInput$Shape>("SquashedOneofInput").implement(
    {
      fields: (t) => ({
        msg1: t.field({
          type: OneofMessage1Input$Ref,
          required: false,
          extensions: {
            protobufField: {
              name: "msg1",
              typeFullName:
                "testapis.edgecases.import_squashed_union.pkg1.OneofMessage1",
            },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName:
            "testapis.edgecases.import_squashed_union.pkg1.SquashedOneof",
          name: "SquashedOneof",
          package: "testapis.edgecases.import_squashed_union.pkg1",
          options: { "[graphql.object_type]": { squashUnion: true } },
        },
      },
    },
  );

export const SquashedOneof$Ref = builder.unionType("SquashedOneof", {
  types: [OneofMessage1$Ref],
  extensions: {
    protobufOneof: {
      fullName: "testapis.edgecases.import_squashed_union.pkg1.SquashedOneof",
      name: "SquashedOneof",
      package: "testapis.edgecases.import_squashed_union.pkg1",
      fields: [{
        name: "msg1",
        type: "testapis.edgecases.import_squashed_union.pkg1.OneofMessage1",
        options: { "[graphql.object_type]": { squashUnion: true } },
      }],
    },
  },
});
",
    "name": "testapis/edgecases/import_squashed_union/pkg1/types.pb.pothos.ts",
  },
]
`;

exports[`'testapis.edgecases.import_squashed_union.pkg1' > generates files by plugin 'with partial inputs' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/edgecases/import_squashed_union/pkg1/types.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { OneofMessage1 } from "@testapis/ts-proto/testapis/edgecases/import_squashed_union/pkg1/types";
import { builder } from "../../../../builder";

export const OneofMessage1$Ref = builder.objectRef<OneofMessage1>(
  "OneofMessage1",
);
builder.objectType(OneofMessage1$Ref, {
  name: "OneofMessage1",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as OneofMessage1 | { $type: string & {}; }).$type ===
      "testapis.edgecases.import_squashed_union.pkg1.OneofMessage1";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.edgecases.import_squashed_union.pkg1.OneofMessage1",
      name: "OneofMessage1",
      package: "testapis.edgecases.import_squashed_union.pkg1",
    },
  },
});

export type OneofMessage1Input$Shape = {
  body: OneofMessage1["body"];
};

export const OneofMessage1Input$Ref: InputObjectRef<OneofMessage1Input$Shape> =
  builder.inputRef<OneofMessage1Input$Shape>("OneofMessage1Input").implement(
    {
      fields: (t) => ({
        body: t.field({
          type: "String",
          required: true,
          extensions: {
            protobufField: { name: "body", typeFullName: "string" },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName:
            "testapis.edgecases.import_squashed_union.pkg1.OneofMessage1",
          name: "OneofMessage1",
          package: "testapis.edgecases.import_squashed_union.pkg1",
        },
      },
    },
  );

export type OneofMessage1PartialInput$Shape = {
  body?: OneofMessage1["body"] | null;
};

export const OneofMessage1PartialInput$Ref: InputObjectRef<
  OneofMessage1PartialInput$Shape
> = builder.inputRef<OneofMessage1PartialInput$Shape>(
  "OneofMessage1PartialInput",
).implement(
  {
    fields: (t) => ({
      body: t.field({
        type: "String",
        required: false,
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.edgecases.import_squashed_union.pkg1.OneofMessage1",
        name: "OneofMessage1",
        package: "testapis.edgecases.import_squashed_union.pkg1",
      },
    },
  },
);

export type SquashedOneofInput$Shape = {
  msg1?: OneofMessage1Input$Shape | null;
};

export const SquashedOneofInput$Ref: InputObjectRef<SquashedOneofInput$Shape> =
  builder.inputRef<SquashedOneofInput$Shape>("SquashedOneofInput").implement(
    {
      fields: (t) => ({
        msg1: t.field({
          type: OneofMessage1Input$Ref,
          required: false,
          extensions: {
            protobufField: {
              name: "msg1",
              typeFullName:
                "testapis.edgecases.import_squashed_union.pkg1.OneofMessage1",
            },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName:
            "testapis.edgecases.import_squashed_union.pkg1.SquashedOneof",
          name: "SquashedOneof",
          package: "testapis.edgecases.import_squashed_union.pkg1",
          options: { "[graphql.object_type]": { squashUnion: true } },
        },
      },
    },
  );

export type SquashedOneofPartialInput$Shape = {
  msg1?: OneofMessage1PartialInput$Shape | null;
};

export const SquashedOneofPartialInput$Ref: InputObjectRef<
  SquashedOneofPartialInput$Shape
> = builder.inputRef<SquashedOneofPartialInput$Shape>(
  "SquashedOneofPartialInput",
).implement(
  {
    fields: (t) => ({
      msg1: t.field({
        type: OneofMessage1PartialInput$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "msg1",
            typeFullName:
              "testapis.edgecases.import_squashed_union.pkg1.OneofMessage1",
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.edgecases.import_squashed_union.pkg1.SquashedOneof",
        name: "SquashedOneof",
        package: "testapis.edgecases.import_squashed_union.pkg1",
        options: { "[graphql.object_type]": { squashUnion: true } },
      },
    },
  },
);

export const SquashedOneof$Ref = builder.unionType("SquashedOneof", {
  types: [OneofMessage1$Ref],
  extensions: {
    protobufOneof: {
      fullName: "testapis.edgecases.import_squashed_union.pkg1.SquashedOneof",
      name: "SquashedOneof",
      package: "testapis.edgecases.import_squashed_union.pkg1",
      fields: [{
        name: "msg1",
        type: "testapis.edgecases.import_squashed_union.pkg1.OneofMessage1",
        options: { "[graphql.object_type]": { squashUnion: true } },
      }],
    },
  },
});
",
    "name": "testapis/edgecases/import_squashed_union/pkg1/types.pb.pothos.ts",
  },
]
`;

exports[`'testapis.edgecases.import_squashed_union.pkg1' > generates files by plugin 'without import prefix' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/edgecases/import_squashed_union/pkg1/types.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { builder } from "../../../../builder";
import { OneofMessage1 } from "./testapis/edgecases/import_squashed_union/pkg1/types";

export const OneofMessage1$Ref = builder.objectRef<OneofMessage1>(
  "OneofMessage1",
);
builder.objectType(OneofMessage1$Ref, {
  name: "OneofMessage1",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as OneofMessage1 | { $type: string & {}; }).$type ===
      "testapis.edgecases.import_squashed_union.pkg1.OneofMessage1";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.edgecases.import_squashed_union.pkg1.OneofMessage1",
      name: "OneofMessage1",
      package: "testapis.edgecases.import_squashed_union.pkg1",
    },
  },
});

export type OneofMessage1Input$Shape = {
  body: OneofMessage1["body"];
};

export const OneofMessage1Input$Ref: InputObjectRef<OneofMessage1Input$Shape> =
  builder.inputRef<OneofMessage1Input$Shape>("OneofMessage1Input").implement(
    {
      fields: (t) => ({
        body: t.field({
          type: "String",
          required: true,
          extensions: {
            protobufField: { name: "body", typeFullName: "string" },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName:
            "testapis.edgecases.import_squashed_union.pkg1.OneofMessage1",
          name: "OneofMessage1",
          package: "testapis.edgecases.import_squashed_union.pkg1",
        },
      },
    },
  );

export type SquashedOneofInput$Shape = {
  msg1?: OneofMessage1Input$Shape | null;
};

export const SquashedOneofInput$Ref: InputObjectRef<SquashedOneofInput$Shape> =
  builder.inputRef<SquashedOneofInput$Shape>("SquashedOneofInput").implement(
    {
      fields: (t) => ({
        msg1: t.field({
          type: OneofMessage1Input$Ref,
          required: false,
          extensions: {
            protobufField: {
              name: "msg1",
              typeFullName:
                "testapis.edgecases.import_squashed_union.pkg1.OneofMessage1",
            },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName:
            "testapis.edgecases.import_squashed_union.pkg1.SquashedOneof",
          name: "SquashedOneof",
          package: "testapis.edgecases.import_squashed_union.pkg1",
          options: { "[graphql.object_type]": { squashUnion: true } },
        },
      },
    },
  );

export const SquashedOneof$Ref = builder.unionType("SquashedOneof", {
  types: [OneofMessage1$Ref],
  extensions: {
    protobufOneof: {
      fullName: "testapis.edgecases.import_squashed_union.pkg1.SquashedOneof",
      name: "SquashedOneof",
      package: "testapis.edgecases.import_squashed_union.pkg1",
      fields: [{
        name: "msg1",
        type: "testapis.edgecases.import_squashed_union.pkg1.OneofMessage1",
        options: { "[graphql.object_type]": { squashUnion: true } },
      }],
    },
  },
});
",
    "name": "testapis/edgecases/import_squashed_union/pkg1/types.pb.pothos.ts",
  },
]
`;

exports[`'testapis.edgecases.import_squashed_union.pkg2' > generates files by plugin 'with import prefix' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/edgecases/import_squashed_union/pkg2/types.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { Message } from "@testapis/ts-proto/testapis/edgecases/import_squashed_union/pkg2/types";
import { builder } from "../../../../builder";
import {
  SquashedOneof$Ref,
  SquashedOneofInput$Ref,
  SquashedOneofInput$Shape,
} from "../pkg1/types.pb.pothos";

export const Message$Ref = builder.objectRef<Message>("Message");
builder.objectType(Message$Ref, {
  name: "Message",
  fields: (t) => ({
    msg: t.field({
      type: SquashedOneof$Ref,
      nullable: true,
      resolve: (source) => {
        const value = source.msg?.msg1;
        if (value == null) {
          return null;
        }
        return value;
      },
      extensions: {
        protobufField: {
          name: "msg",
          typeFullName:
            "testapis.edgecases.import_squashed_union.pkg1.SquashedOneof",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as Message | { $type: string & {}; }).$type ===
      "testapis.edgecases.import_squashed_union.pkg2.Message";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.edgecases.import_squashed_union.pkg2.Message",
      name: "Message",
      package: "testapis.edgecases.import_squashed_union.pkg2",
    },
  },
});

export type MessageInput$Shape = {
  msg?: SquashedOneofInput$Shape | null;
};

export const MessageInput$Ref: InputObjectRef<MessageInput$Shape> = builder
  .inputRef<MessageInput$Shape>("MessageInput").implement(
    {
      fields: (t) => ({
        msg: t.field({
          type: SquashedOneofInput$Ref,
          required: false,
          extensions: {
            protobufField: {
              name: "msg",
              typeFullName:
                "testapis.edgecases.import_squashed_union.pkg1.SquashedOneof",
            },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.edgecases.import_squashed_union.pkg2.Message",
          name: "Message",
          package: "testapis.edgecases.import_squashed_union.pkg2",
        },
      },
    },
  );
",
    "name": "testapis/edgecases/import_squashed_union/pkg2/types.pb.pothos.ts",
  },
]
`;

exports[`'testapis.edgecases.import_squashed_union.pkg2' > generates files by plugin 'with partial inputs' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/edgecases/import_squashed_union/pkg2/types.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { Message } from "@testapis/ts-proto/testapis/edgecases/import_squashed_union/pkg2/types";
import { builder } from "../../../../builder";
import {
  SquashedOneof$Ref,
  SquashedOneofInput$Ref,
  SquashedOneofInput$Shape,
  SquashedOneofPartialInput$Ref,
  SquashedOneofPartialInput$Shape,
} from "../pkg1/types.pb.pothos";

export const Message$Ref = builder.objectRef<Message>("Message");
builder.objectType(Message$Ref, {
  name: "Message",
  fields: (t) => ({
    msg: t.field({
      type: SquashedOneof$Ref,
      nullable: true,
      resolve: (source) => {
        const value = source.msg?.msg1;
        if (value == null) {
          return null;
        }
        return value;
      },
      extensions: {
        protobufField: {
          name: "msg",
          typeFullName:
            "testapis.edgecases.import_squashed_union.pkg1.SquashedOneof",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as Message | { $type: string & {}; }).$type ===
      "testapis.edgecases.import_squashed_union.pkg2.Message";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.edgecases.import_squashed_union.pkg2.Message",
      name: "Message",
      package: "testapis.edgecases.import_squashed_union.pkg2",
    },
  },
});

export type MessageInput$Shape = {
  msg?: SquashedOneofInput$Shape | null;
};

export const MessageInput$Ref: InputObjectRef<MessageInput$Shape> = builder
  .inputRef<MessageInput$Shape>("MessageInput").implement(
    {
      fields: (t) => ({
        msg: t.field({
          type: SquashedOneofInput$Ref,
          required: false,
          extensions: {
            protobufField: {
              name: "msg",
              typeFullName:
                "testapis.edgecases.import_squashed_union.pkg1.SquashedOneof",
            },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.edgecases.import_squashed_union.pkg2.Message",
          name: "Message",
          package: "testapis.edgecases.import_squashed_union.pkg2",
        },
      },
    },
  );

export type MessagePartialInput$Shape = {
  msg?: SquashedOneofPartialInput$Shape | null;
};

export const MessagePartialInput$Ref: InputObjectRef<
  MessagePartialInput$Shape
> = builder.inputRef<MessagePartialInput$Shape>("MessagePartialInput")
  .implement(
    {
      fields: (t) => ({
        msg: t.field({
          type: SquashedOneofPartialInput$Ref,
          required: false,
          extensions: {
            protobufField: {
              name: "msg",
              typeFullName:
                "testapis.edgecases.import_squashed_union.pkg1.SquashedOneof",
            },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.edgecases.import_squashed_union.pkg2.Message",
          name: "Message",
          package: "testapis.edgecases.import_squashed_union.pkg2",
        },
      },
    },
  );
",
    "name": "testapis/edgecases/import_squashed_union/pkg2/types.pb.pothos.ts",
  },
]
`;

exports[`'testapis.edgecases.import_squashed_union.pkg2' > generates files by plugin 'without import prefix' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/edgecases/import_squashed_union/pkg2/types.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { builder } from "../../../../builder";
import {
  SquashedOneof$Ref,
  SquashedOneofInput$Ref,
  SquashedOneofInput$Shape,
} from "../pkg1/types.pb.pothos";
import { Message } from "./testapis/edgecases/import_squashed_union/pkg2/types";

export const Message$Ref = builder.objectRef<Message>("Message");
builder.objectType(Message$Ref, {
  name: "Message",
  fields: (t) => ({
    msg: t.field({
      type: SquashedOneof$Ref,
      nullable: true,
      resolve: (source) => {
        const value = source.msg?.msg1;
        if (value == null) {
          return null;
        }
        return value;
      },
      extensions: {
        protobufField: {
          name: "msg",
          typeFullName:
            "testapis.edgecases.import_squashed_union.pkg1.SquashedOneof",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as Message | { $type: string & {}; }).$type ===
      "testapis.edgecases.import_squashed_union.pkg2.Message";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.edgecases.import_squashed_union.pkg2.Message",
      name: "Message",
      package: "testapis.edgecases.import_squashed_union.pkg2",
    },
  },
});

export type MessageInput$Shape = {
  msg?: SquashedOneofInput$Shape | null;
};

export const MessageInput$Ref: InputObjectRef<MessageInput$Shape> = builder
  .inputRef<MessageInput$Shape>("MessageInput").implement(
    {
      fields: (t) => ({
        msg: t.field({
          type: SquashedOneofInput$Ref,
          required: false,
          extensions: {
            protobufField: {
              name: "msg",
              typeFullName:
                "testapis.edgecases.import_squashed_union.pkg1.SquashedOneof",
            },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.edgecases.import_squashed_union.pkg2.Message",
          name: "Message",
          package: "testapis.edgecases.import_squashed_union.pkg2",
        },
      },
    },
  );
",
    "name": "testapis/edgecases/import_squashed_union/pkg2/types.pb.pothos.ts",
  },
]
`;

exports[`'testapis.empty_types' > generates files by plugin 'with import prefix' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/empty_types/empty.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { EmptyMessage } from "@testapis/ts-proto/testapis/empty_types/empty";
import { builder } from "../../builder";

export const EmptyMessage$Ref = builder.objectRef<EmptyMessage>("EmptyMessage");
builder.objectType(EmptyMessage$Ref, {
  name: "EmptyMessage",
  fields: (t) => ({
    _: t.field({
      type: "Boolean",
      nullable: true,
      description: "noop field",
      resolve: () => true,
    }),
  }),
  isTypeOf: (source) => {
    return (source as EmptyMessage | { $type: string & {}; }).$type ===
      "testapis.empty_types.EmptyMessage";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.empty_types.EmptyMessage",
      name: "EmptyMessage",
      package: "testapis.empty_types",
    },
  },
});

export type EmptyMessageInput$Shape = {};

export const EmptyMessageInput$Ref: InputObjectRef<EmptyMessageInput$Shape> =
  builder.inputRef<EmptyMessageInput$Shape>("EmptyMessageInput").implement(
    {
      fields: (t) => ({
        _: t.field({
          type: "Boolean",
          required: false,
          description: "noop field",
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.empty_types.EmptyMessage",
          name: "EmptyMessage",
          package: "testapis.empty_types",
        },
      },
    },
  );
",
    "name": "testapis/empty_types/empty.pb.pothos.ts",
  },
]
`;

exports[`'testapis.empty_types' > generates files by plugin 'with partial inputs' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/empty_types/empty.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { EmptyMessage } from "@testapis/ts-proto/testapis/empty_types/empty";
import { builder } from "../../builder";

export const EmptyMessage$Ref = builder.objectRef<EmptyMessage>("EmptyMessage");
builder.objectType(EmptyMessage$Ref, {
  name: "EmptyMessage",
  fields: (t) => ({
    _: t.field({
      type: "Boolean",
      nullable: true,
      description: "noop field",
      resolve: () => true,
    }),
  }),
  isTypeOf: (source) => {
    return (source as EmptyMessage | { $type: string & {}; }).$type ===
      "testapis.empty_types.EmptyMessage";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.empty_types.EmptyMessage",
      name: "EmptyMessage",
      package: "testapis.empty_types",
    },
  },
});

export type EmptyMessageInput$Shape = {};

export const EmptyMessageInput$Ref: InputObjectRef<EmptyMessageInput$Shape> =
  builder.inputRef<EmptyMessageInput$Shape>("EmptyMessageInput").implement(
    {
      fields: (t) => ({
        _: t.field({
          type: "Boolean",
          required: false,
          description: "noop field",
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.empty_types.EmptyMessage",
          name: "EmptyMessage",
          package: "testapis.empty_types",
        },
      },
    },
  );

export type EmptyMessagePartialInput$Shape = {};

export const EmptyMessagePartialInput$Ref: InputObjectRef<
  EmptyMessagePartialInput$Shape
> = builder.inputRef<EmptyMessagePartialInput$Shape>("EmptyMessagePartialInput")
  .implement(
    {
      fields: (t) => ({
        _: t.field({
          type: "Boolean",
          required: false,
          description: "noop field",
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.empty_types.EmptyMessage",
          name: "EmptyMessage",
          package: "testapis.empty_types",
        },
      },
    },
  );
",
    "name": "testapis/empty_types/empty.pb.pothos.ts",
  },
]
`;

exports[`'testapis.empty_types' > generates files by plugin 'without import prefix' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/empty_types/empty.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { builder } from "../../builder";
import { EmptyMessage } from "./testapis/empty_types/empty";

export const EmptyMessage$Ref = builder.objectRef<EmptyMessage>("EmptyMessage");
builder.objectType(EmptyMessage$Ref, {
  name: "EmptyMessage",
  fields: (t) => ({
    _: t.field({
      type: "Boolean",
      nullable: true,
      description: "noop field",
      resolve: () => true,
    }),
  }),
  isTypeOf: (source) => {
    return (source as EmptyMessage | { $type: string & {}; }).$type ===
      "testapis.empty_types.EmptyMessage";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.empty_types.EmptyMessage",
      name: "EmptyMessage",
      package: "testapis.empty_types",
    },
  },
});

export type EmptyMessageInput$Shape = {};

export const EmptyMessageInput$Ref: InputObjectRef<EmptyMessageInput$Shape> =
  builder.inputRef<EmptyMessageInput$Shape>("EmptyMessageInput").implement(
    {
      fields: (t) => ({
        _: t.field({
          type: "Boolean",
          required: false,
          description: "noop field",
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.empty_types.EmptyMessage",
          name: "EmptyMessage",
          package: "testapis.empty_types",
        },
      },
    },
  );
",
    "name": "testapis/empty_types/empty.pb.pothos.ts",
  },
]
`;

exports[`'testapis.enums' > generates files by plugin 'with import prefix' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/enums/enums.proto

/* eslint-disable */

import { EnumRef, InputObjectRef } from "@pothos/core";
import {
  MessageWithEnums,
  MyEnum,
  MyEnumWithoutUnspecified,
} from "@testapis/ts-proto/testapis/enums/enums";
import { builder } from "../../builder";

export const MessageWithEnums$Ref = builder.objectRef<MessageWithEnums>(
  "MessageWithEnums",
);
builder.objectType(MessageWithEnums$Ref, {
  name: "MessageWithEnums",
  fields: (t) => ({
    requiredMyEnum: t.field({
      type: MyEnum$Ref,
      nullable: false,
      description: "Required.",
      resolve: (source) => {
        if (source.requiredMyEnum === MyEnum.MY_ENUM_UNSPECIFIED) {
          throw new Error(
            "requiredMyEnum is required field. But got unspecified.",
          );
        }

        return source.requiredMyEnum;
      },
      extensions: {
        protobufField: {
          name: "required_my_enum",
          typeFullName: "testapi.enums.MyEnum",
        },
      },
    }),
    optionalMyEnum: t.field({
      type: MyEnum$Ref,
      nullable: true,
      description: "Optional.",
      resolve: (source) => {
        if (source.optionalMyEnum === MyEnum.MY_ENUM_UNSPECIFIED) {
          return null;
        }

        return source.optionalMyEnum;
      },
      extensions: {
        protobufField: {
          name: "optional_my_enum",
          typeFullName: "testapi.enums.MyEnum",
        },
      },
    }),
    requiredMyEnumWithoutUnspecified: t.field({
      type: MyEnumWithoutUnspecified$Ref,
      nullable: false,
      description: "Required.",
      resolve: (source) => {
        return source.requiredMyEnumWithoutUnspecified;
      },
      extensions: {
        protobufField: {
          name: "required_my_enum_without_unspecified",
          typeFullName: "testapi.enums.MyEnumWithoutUnspecified",
        },
      },
    }),
    optionalMyEnumWithoutUnspecified: t.field({
      type: MyEnumWithoutUnspecified$Ref,
      nullable: true,
      description: "Optional.",
      resolve: (source) => {
        return source.optionalMyEnumWithoutUnspecified;
      },
      extensions: {
        protobufField: {
          name: "optional_my_enum_without_unspecified",
          typeFullName: "testapi.enums.MyEnumWithoutUnspecified",
        },
      },
    }),
    requiredMyEnums: t.field({
      type: [MyEnum$Ref],
      nullable: { list: false, items: false },
      description: "Required.",
      resolve: (source) => {
        return source.requiredMyEnums.map((item) => {
          if (item === MyEnum.MY_ENUM_UNSPECIFIED) {
            throw new Error(
              "requiredMyEnums is required field. But got unspecified.",
            );
          }

          return item;
        });
      },
      extensions: {
        protobufField: {
          name: "required_my_enums",
          typeFullName: "testapi.enums.MyEnum",
        },
      },
    }),
    optionalMyEnums: t.field({
      type: [MyEnum$Ref],
      nullable: { list: true, items: false },
      description: "Optional.",
      resolve: (source) => {
        return source.optionalMyEnums.map((item) => {
          if (item === MyEnum.MY_ENUM_UNSPECIFIED) {
            throw new Error(
              "optionalMyEnums is required field. But got unspecified.",
            );
          }

          return item;
        });
      },
      extensions: {
        protobufField: {
          name: "optional_my_enums",
          typeFullName: "testapi.enums.MyEnum",
        },
      },
    }),
    requiredMyEnumWithoutUnspecifieds: t.field({
      type: [MyEnumWithoutUnspecified$Ref],
      nullable: { list: false, items: false },
      description: "Required.",
      resolve: (source) => {
        return source.requiredMyEnumWithoutUnspecifieds;
      },
      extensions: {
        protobufField: {
          name: "required_my_enum_without_unspecifieds",
          typeFullName: "testapi.enums.MyEnumWithoutUnspecified",
        },
      },
    }),
    optionalMyEnumWithoutUnspecifieds: t.field({
      type: [MyEnumWithoutUnspecified$Ref],
      nullable: { list: true, items: false },
      description: "Optional.",
      resolve: (source) => {
        return source.optionalMyEnumWithoutUnspecifieds;
      },
      extensions: {
        protobufField: {
          name: "optional_my_enum_without_unspecifieds",
          typeFullName: "testapi.enums.MyEnumWithoutUnspecified",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as MessageWithEnums | { $type: string & {}; }).$type ===
      "testapi.enums.MessageWithEnums";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapi.enums.MessageWithEnums",
      name: "MessageWithEnums",
      package: "testapi.enums",
    },
  },
});

export type MessageWithEnumsInput$Shape = {
  requiredMyEnum: MessageWithEnums["requiredMyEnum"];
  optionalMyEnum?: MessageWithEnums["optionalMyEnum"] | null;
  requiredMyEnumWithoutUnspecified:
    MessageWithEnums["requiredMyEnumWithoutUnspecified"];
  optionalMyEnumWithoutUnspecified?:
    | MessageWithEnums["optionalMyEnumWithoutUnspecified"]
    | null;
  requiredMyEnums: MessageWithEnums["requiredMyEnums"];
  optionalMyEnums?: MessageWithEnums["optionalMyEnums"] | null;
  requiredMyEnumWithoutUnspecifieds:
    MessageWithEnums["requiredMyEnumWithoutUnspecifieds"];
  optionalMyEnumWithoutUnspecifieds?:
    | MessageWithEnums["optionalMyEnumWithoutUnspecifieds"]
    | null;
};

export const MessageWithEnumsInput$Ref: InputObjectRef<
  MessageWithEnumsInput$Shape
> = builder.inputRef<MessageWithEnumsInput$Shape>("MessageWithEnumsInput")
  .implement(
    {
      fields: (t) => ({
        requiredMyEnum: t.field({
          type: MyEnum$Ref,
          required: true,
          description: "Required.",
          extensions: {
            protobufField: {
              name: "required_my_enum",
              typeFullName: "testapi.enums.MyEnum",
            },
          },
        }),
        optionalMyEnum: t.field({
          type: MyEnum$Ref,
          required: false,
          description: "Optional.",
          extensions: {
            protobufField: {
              name: "optional_my_enum",
              typeFullName: "testapi.enums.MyEnum",
            },
          },
        }),
        requiredMyEnumWithoutUnspecified: t.field({
          type: MyEnumWithoutUnspecified$Ref,
          required: true,
          description: "Required.",
          extensions: {
            protobufField: {
              name: "required_my_enum_without_unspecified",
              typeFullName: "testapi.enums.MyEnumWithoutUnspecified",
            },
          },
        }),
        optionalMyEnumWithoutUnspecified: t.field({
          type: MyEnumWithoutUnspecified$Ref,
          required: false,
          description: "Optional.",
          extensions: {
            protobufField: {
              name: "optional_my_enum_without_unspecified",
              typeFullName: "testapi.enums.MyEnumWithoutUnspecified",
            },
          },
        }),
        requiredMyEnums: t.field({
          type: [MyEnum$Ref],
          required: { list: true, items: true },
          description: "Required.",
          extensions: {
            protobufField: {
              name: "required_my_enums",
              typeFullName: "testapi.enums.MyEnum",
            },
          },
        }),
        optionalMyEnums: t.field({
          type: [MyEnum$Ref],
          required: { list: false, items: true },
          description: "Optional.",
          extensions: {
            protobufField: {
              name: "optional_my_enums",
              typeFullName: "testapi.enums.MyEnum",
            },
          },
        }),
        requiredMyEnumWithoutUnspecifieds: t.field({
          type: [MyEnumWithoutUnspecified$Ref],
          required: { list: true, items: true },
          description: "Required.",
          extensions: {
            protobufField: {
              name: "required_my_enum_without_unspecifieds",
              typeFullName: "testapi.enums.MyEnumWithoutUnspecified",
            },
          },
        }),
        optionalMyEnumWithoutUnspecifieds: t.field({
          type: [MyEnumWithoutUnspecified$Ref],
          required: { list: false, items: true },
          description: "Optional.",
          extensions: {
            protobufField: {
              name: "optional_my_enum_without_unspecifieds",
              typeFullName: "testapi.enums.MyEnumWithoutUnspecified",
            },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapi.enums.MessageWithEnums",
          name: "MessageWithEnums",
          package: "testapi.enums",
        },
      },
    },
  );

export const MyEnum$Ref: EnumRef<MyEnum, MyEnum> = builder.enumType("MyEnum", {
  values: {
    FOO: {
      value: 1,
      extensions: { protobufEnumValue: { name: "MY_ENUM_FOO" } },
    },
    BAR: {
      description: "This is Bar.",
      value: 2,
      extensions: { protobufEnumValue: { name: "MY_ENUM_BAR" } },
    },
    BAZ: {
      value: 3,
      extensions: { protobufEnumValue: { name: "MY_ENUM_BAZ" } },
    },
  } as const,
  extensions: {
    protobufEnum: {
      name: "MyEnum",
      fullName: "testapi.enums.MyEnum",
      package: "testapi.enums",
    },
  },
});

export const MyEnumWithoutUnspecified$Ref: EnumRef<
  MyEnumWithoutUnspecified,
  MyEnumWithoutUnspecified
> = builder.enumType("MyEnumWithoutUnspecified", {
  values: {
    FOO: {
      value: 0,
      extensions: {
        protobufEnumValue: { name: "MY_ENUM_WITHOUT_UNSPECIFIED_FOO" },
      },
    },
    BAR: {
      value: 1,
      extensions: {
        protobufEnumValue: { name: "MY_ENUM_WITHOUT_UNSPECIFIED_BAR" },
      },
    },
    BAZ: {
      value: 2,
      extensions: {
        protobufEnumValue: { name: "MY_ENUM_WITHOUT_UNSPECIFIED_BAZ" },
      },
    },
  } as const,
  extensions: {
    protobufEnum: {
      name: "MyEnumWithoutUnspecified",
      fullName: "testapi.enums.MyEnumWithoutUnspecified",
      package: "testapi.enums",
    },
  },
});
",
    "name": "testapis/enums/enums.pb.pothos.ts",
  },
]
`;

exports[`'testapis.enums' > generates files by plugin 'with partial inputs' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/enums/enums.proto

/* eslint-disable */

import { EnumRef, InputObjectRef } from "@pothos/core";
import {
  MessageWithEnums,
  MyEnum,
  MyEnumWithoutUnspecified,
} from "@testapis/ts-proto/testapis/enums/enums";
import { builder } from "../../builder";

export const MessageWithEnums$Ref = builder.objectRef<MessageWithEnums>(
  "MessageWithEnums",
);
builder.objectType(MessageWithEnums$Ref, {
  name: "MessageWithEnums",
  fields: (t) => ({
    requiredMyEnum: t.field({
      type: MyEnum$Ref,
      nullable: false,
      description: "Required.",
      resolve: (source) => {
        if (source.requiredMyEnum === MyEnum.MY_ENUM_UNSPECIFIED) {
          throw new Error(
            "requiredMyEnum is required field. But got unspecified.",
          );
        }

        return source.requiredMyEnum;
      },
      extensions: {
        protobufField: {
          name: "required_my_enum",
          typeFullName: "testapi.enums.MyEnum",
        },
      },
    }),
    optionalMyEnum: t.field({
      type: MyEnum$Ref,
      nullable: true,
      description: "Optional.",
      resolve: (source) => {
        if (source.optionalMyEnum === MyEnum.MY_ENUM_UNSPECIFIED) {
          return null;
        }

        return source.optionalMyEnum;
      },
      extensions: {
        protobufField: {
          name: "optional_my_enum",
          typeFullName: "testapi.enums.MyEnum",
        },
      },
    }),
    requiredMyEnumWithoutUnspecified: t.field({
      type: MyEnumWithoutUnspecified$Ref,
      nullable: false,
      description: "Required.",
      resolve: (source) => {
        return source.requiredMyEnumWithoutUnspecified;
      },
      extensions: {
        protobufField: {
          name: "required_my_enum_without_unspecified",
          typeFullName: "testapi.enums.MyEnumWithoutUnspecified",
        },
      },
    }),
    optionalMyEnumWithoutUnspecified: t.field({
      type: MyEnumWithoutUnspecified$Ref,
      nullable: true,
      description: "Optional.",
      resolve: (source) => {
        return source.optionalMyEnumWithoutUnspecified;
      },
      extensions: {
        protobufField: {
          name: "optional_my_enum_without_unspecified",
          typeFullName: "testapi.enums.MyEnumWithoutUnspecified",
        },
      },
    }),
    requiredMyEnums: t.field({
      type: [MyEnum$Ref],
      nullable: { list: false, items: false },
      description: "Required.",
      resolve: (source) => {
        return source.requiredMyEnums.map((item) => {
          if (item === MyEnum.MY_ENUM_UNSPECIFIED) {
            throw new Error(
              "requiredMyEnums is required field. But got unspecified.",
            );
          }

          return item;
        });
      },
      extensions: {
        protobufField: {
          name: "required_my_enums",
          typeFullName: "testapi.enums.MyEnum",
        },
      },
    }),
    optionalMyEnums: t.field({
      type: [MyEnum$Ref],
      nullable: { list: true, items: false },
      description: "Optional.",
      resolve: (source) => {
        return source.optionalMyEnums.map((item) => {
          if (item === MyEnum.MY_ENUM_UNSPECIFIED) {
            throw new Error(
              "optionalMyEnums is required field. But got unspecified.",
            );
          }

          return item;
        });
      },
      extensions: {
        protobufField: {
          name: "optional_my_enums",
          typeFullName: "testapi.enums.MyEnum",
        },
      },
    }),
    requiredMyEnumWithoutUnspecifieds: t.field({
      type: [MyEnumWithoutUnspecified$Ref],
      nullable: { list: false, items: false },
      description: "Required.",
      resolve: (source) => {
        return source.requiredMyEnumWithoutUnspecifieds;
      },
      extensions: {
        protobufField: {
          name: "required_my_enum_without_unspecifieds",
          typeFullName: "testapi.enums.MyEnumWithoutUnspecified",
        },
      },
    }),
    optionalMyEnumWithoutUnspecifieds: t.field({
      type: [MyEnumWithoutUnspecified$Ref],
      nullable: { list: true, items: false },
      description: "Optional.",
      resolve: (source) => {
        return source.optionalMyEnumWithoutUnspecifieds;
      },
      extensions: {
        protobufField: {
          name: "optional_my_enum_without_unspecifieds",
          typeFullName: "testapi.enums.MyEnumWithoutUnspecified",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as MessageWithEnums | { $type: string & {}; }).$type ===
      "testapi.enums.MessageWithEnums";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapi.enums.MessageWithEnums",
      name: "MessageWithEnums",
      package: "testapi.enums",
    },
  },
});

export type MessageWithEnumsInput$Shape = {
  requiredMyEnum: MessageWithEnums["requiredMyEnum"];
  optionalMyEnum?: MessageWithEnums["optionalMyEnum"] | null;
  requiredMyEnumWithoutUnspecified:
    MessageWithEnums["requiredMyEnumWithoutUnspecified"];
  optionalMyEnumWithoutUnspecified?:
    | MessageWithEnums["optionalMyEnumWithoutUnspecified"]
    | null;
  requiredMyEnums: MessageWithEnums["requiredMyEnums"];
  optionalMyEnums?: MessageWithEnums["optionalMyEnums"] | null;
  requiredMyEnumWithoutUnspecifieds:
    MessageWithEnums["requiredMyEnumWithoutUnspecifieds"];
  optionalMyEnumWithoutUnspecifieds?:
    | MessageWithEnums["optionalMyEnumWithoutUnspecifieds"]
    | null;
};

export const MessageWithEnumsInput$Ref: InputObjectRef<
  MessageWithEnumsInput$Shape
> = builder.inputRef<MessageWithEnumsInput$Shape>("MessageWithEnumsInput")
  .implement(
    {
      fields: (t) => ({
        requiredMyEnum: t.field({
          type: MyEnum$Ref,
          required: true,
          description: "Required.",
          extensions: {
            protobufField: {
              name: "required_my_enum",
              typeFullName: "testapi.enums.MyEnum",
            },
          },
        }),
        optionalMyEnum: t.field({
          type: MyEnum$Ref,
          required: false,
          description: "Optional.",
          extensions: {
            protobufField: {
              name: "optional_my_enum",
              typeFullName: "testapi.enums.MyEnum",
            },
          },
        }),
        requiredMyEnumWithoutUnspecified: t.field({
          type: MyEnumWithoutUnspecified$Ref,
          required: true,
          description: "Required.",
          extensions: {
            protobufField: {
              name: "required_my_enum_without_unspecified",
              typeFullName: "testapi.enums.MyEnumWithoutUnspecified",
            },
          },
        }),
        optionalMyEnumWithoutUnspecified: t.field({
          type: MyEnumWithoutUnspecified$Ref,
          required: false,
          description: "Optional.",
          extensions: {
            protobufField: {
              name: "optional_my_enum_without_unspecified",
              typeFullName: "testapi.enums.MyEnumWithoutUnspecified",
            },
          },
        }),
        requiredMyEnums: t.field({
          type: [MyEnum$Ref],
          required: { list: true, items: true },
          description: "Required.",
          extensions: {
            protobufField: {
              name: "required_my_enums",
              typeFullName: "testapi.enums.MyEnum",
            },
          },
        }),
        optionalMyEnums: t.field({
          type: [MyEnum$Ref],
          required: { list: false, items: true },
          description: "Optional.",
          extensions: {
            protobufField: {
              name: "optional_my_enums",
              typeFullName: "testapi.enums.MyEnum",
            },
          },
        }),
        requiredMyEnumWithoutUnspecifieds: t.field({
          type: [MyEnumWithoutUnspecified$Ref],
          required: { list: true, items: true },
          description: "Required.",
          extensions: {
            protobufField: {
              name: "required_my_enum_without_unspecifieds",
              typeFullName: "testapi.enums.MyEnumWithoutUnspecified",
            },
          },
        }),
        optionalMyEnumWithoutUnspecifieds: t.field({
          type: [MyEnumWithoutUnspecified$Ref],
          required: { list: false, items: true },
          description: "Optional.",
          extensions: {
            protobufField: {
              name: "optional_my_enum_without_unspecifieds",
              typeFullName: "testapi.enums.MyEnumWithoutUnspecified",
            },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapi.enums.MessageWithEnums",
          name: "MessageWithEnums",
          package: "testapi.enums",
        },
      },
    },
  );

export type MessageWithEnumsPartialInput$Shape = {
  requiredMyEnum?: MessageWithEnums["requiredMyEnum"] | null;
  optionalMyEnum?: MessageWithEnums["optionalMyEnum"] | null;
  requiredMyEnumWithoutUnspecified?:
    | MessageWithEnums["requiredMyEnumWithoutUnspecified"]
    | null;
  optionalMyEnumWithoutUnspecified?:
    | MessageWithEnums["optionalMyEnumWithoutUnspecified"]
    | null;
  requiredMyEnums?: MessageWithEnums["requiredMyEnums"] | null;
  optionalMyEnums?: MessageWithEnums["optionalMyEnums"] | null;
  requiredMyEnumWithoutUnspecifieds?:
    | MessageWithEnums["requiredMyEnumWithoutUnspecifieds"]
    | null;
  optionalMyEnumWithoutUnspecifieds?:
    | MessageWithEnums["optionalMyEnumWithoutUnspecifieds"]
    | null;
};

export const MessageWithEnumsPartialInput$Ref: InputObjectRef<
  MessageWithEnumsPartialInput$Shape
> = builder.inputRef<MessageWithEnumsPartialInput$Shape>(
  "MessageWithEnumsPartialInput",
).implement(
  {
    fields: (t) => ({
      requiredMyEnum: t.field({
        type: MyEnum$Ref,
        required: false,
        description: "Required.",
        extensions: {
          protobufField: {
            name: "required_my_enum",
            typeFullName: "testapi.enums.MyEnum",
          },
        },
      }),
      optionalMyEnum: t.field({
        type: MyEnum$Ref,
        required: false,
        description: "Optional.",
        extensions: {
          protobufField: {
            name: "optional_my_enum",
            typeFullName: "testapi.enums.MyEnum",
          },
        },
      }),
      requiredMyEnumWithoutUnspecified: t.field({
        type: MyEnumWithoutUnspecified$Ref,
        required: false,
        description: "Required.",
        extensions: {
          protobufField: {
            name: "required_my_enum_without_unspecified",
            typeFullName: "testapi.enums.MyEnumWithoutUnspecified",
          },
        },
      }),
      optionalMyEnumWithoutUnspecified: t.field({
        type: MyEnumWithoutUnspecified$Ref,
        required: false,
        description: "Optional.",
        extensions: {
          protobufField: {
            name: "optional_my_enum_without_unspecified",
            typeFullName: "testapi.enums.MyEnumWithoutUnspecified",
          },
        },
      }),
      requiredMyEnums: t.field({
        type: [MyEnum$Ref],
        required: { list: false, items: true },
        description: "Required.",
        extensions: {
          protobufField: {
            name: "required_my_enums",
            typeFullName: "testapi.enums.MyEnum",
          },
        },
      }),
      optionalMyEnums: t.field({
        type: [MyEnum$Ref],
        required: { list: false, items: true },
        description: "Optional.",
        extensions: {
          protobufField: {
            name: "optional_my_enums",
            typeFullName: "testapi.enums.MyEnum",
          },
        },
      }),
      requiredMyEnumWithoutUnspecifieds: t.field({
        type: [MyEnumWithoutUnspecified$Ref],
        required: { list: false, items: true },
        description: "Required.",
        extensions: {
          protobufField: {
            name: "required_my_enum_without_unspecifieds",
            typeFullName: "testapi.enums.MyEnumWithoutUnspecified",
          },
        },
      }),
      optionalMyEnumWithoutUnspecifieds: t.field({
        type: [MyEnumWithoutUnspecified$Ref],
        required: { list: false, items: true },
        description: "Optional.",
        extensions: {
          protobufField: {
            name: "optional_my_enum_without_unspecifieds",
            typeFullName: "testapi.enums.MyEnumWithoutUnspecified",
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapi.enums.MessageWithEnums",
        name: "MessageWithEnums",
        package: "testapi.enums",
      },
    },
  },
);

export const MyEnum$Ref: EnumRef<MyEnum, MyEnum> = builder.enumType("MyEnum", {
  values: {
    FOO: {
      value: 1,
      extensions: { protobufEnumValue: { name: "MY_ENUM_FOO" } },
    },
    BAR: {
      description: "This is Bar.",
      value: 2,
      extensions: { protobufEnumValue: { name: "MY_ENUM_BAR" } },
    },
    BAZ: {
      value: 3,
      extensions: { protobufEnumValue: { name: "MY_ENUM_BAZ" } },
    },
  } as const,
  extensions: {
    protobufEnum: {
      name: "MyEnum",
      fullName: "testapi.enums.MyEnum",
      package: "testapi.enums",
    },
  },
});

export const MyEnumWithoutUnspecified$Ref: EnumRef<
  MyEnumWithoutUnspecified,
  MyEnumWithoutUnspecified
> = builder.enumType("MyEnumWithoutUnspecified", {
  values: {
    FOO: {
      value: 0,
      extensions: {
        protobufEnumValue: { name: "MY_ENUM_WITHOUT_UNSPECIFIED_FOO" },
      },
    },
    BAR: {
      value: 1,
      extensions: {
        protobufEnumValue: { name: "MY_ENUM_WITHOUT_UNSPECIFIED_BAR" },
      },
    },
    BAZ: {
      value: 2,
      extensions: {
        protobufEnumValue: { name: "MY_ENUM_WITHOUT_UNSPECIFIED_BAZ" },
      },
    },
  } as const,
  extensions: {
    protobufEnum: {
      name: "MyEnumWithoutUnspecified",
      fullName: "testapi.enums.MyEnumWithoutUnspecified",
      package: "testapi.enums",
    },
  },
});
",
    "name": "testapis/enums/enums.pb.pothos.ts",
  },
]
`;

exports[`'testapis.enums' > generates files by plugin 'without import prefix' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/enums/enums.proto

/* eslint-disable */

import { EnumRef, InputObjectRef } from "@pothos/core";
import { builder } from "../../builder";
import {
  MessageWithEnums,
  MyEnum,
  MyEnumWithoutUnspecified,
} from "./testapis/enums/enums";

export const MessageWithEnums$Ref = builder.objectRef<MessageWithEnums>(
  "MessageWithEnums",
);
builder.objectType(MessageWithEnums$Ref, {
  name: "MessageWithEnums",
  fields: (t) => ({
    requiredMyEnum: t.field({
      type: MyEnum$Ref,
      nullable: false,
      description: "Required.",
      resolve: (source) => {
        if (source.requiredMyEnum === MyEnum.MY_ENUM_UNSPECIFIED) {
          throw new Error(
            "requiredMyEnum is required field. But got unspecified.",
          );
        }

        return source.requiredMyEnum;
      },
      extensions: {
        protobufField: {
          name: "required_my_enum",
          typeFullName: "testapi.enums.MyEnum",
        },
      },
    }),
    optionalMyEnum: t.field({
      type: MyEnum$Ref,
      nullable: true,
      description: "Optional.",
      resolve: (source) => {
        if (source.optionalMyEnum === MyEnum.MY_ENUM_UNSPECIFIED) {
          return null;
        }

        return source.optionalMyEnum;
      },
      extensions: {
        protobufField: {
          name: "optional_my_enum",
          typeFullName: "testapi.enums.MyEnum",
        },
      },
    }),
    requiredMyEnumWithoutUnspecified: t.field({
      type: MyEnumWithoutUnspecified$Ref,
      nullable: false,
      description: "Required.",
      resolve: (source) => {
        return source.requiredMyEnumWithoutUnspecified;
      },
      extensions: {
        protobufField: {
          name: "required_my_enum_without_unspecified",
          typeFullName: "testapi.enums.MyEnumWithoutUnspecified",
        },
      },
    }),
    optionalMyEnumWithoutUnspecified: t.field({
      type: MyEnumWithoutUnspecified$Ref,
      nullable: true,
      description: "Optional.",
      resolve: (source) => {
        return source.optionalMyEnumWithoutUnspecified;
      },
      extensions: {
        protobufField: {
          name: "optional_my_enum_without_unspecified",
          typeFullName: "testapi.enums.MyEnumWithoutUnspecified",
        },
      },
    }),
    requiredMyEnums: t.field({
      type: [MyEnum$Ref],
      nullable: { list: false, items: false },
      description: "Required.",
      resolve: (source) => {
        return source.requiredMyEnums.map((item) => {
          if (item === MyEnum.MY_ENUM_UNSPECIFIED) {
            throw new Error(
              "requiredMyEnums is required field. But got unspecified.",
            );
          }

          return item;
        });
      },
      extensions: {
        protobufField: {
          name: "required_my_enums",
          typeFullName: "testapi.enums.MyEnum",
        },
      },
    }),
    optionalMyEnums: t.field({
      type: [MyEnum$Ref],
      nullable: { list: true, items: false },
      description: "Optional.",
      resolve: (source) => {
        return source.optionalMyEnums.map((item) => {
          if (item === MyEnum.MY_ENUM_UNSPECIFIED) {
            throw new Error(
              "optionalMyEnums is required field. But got unspecified.",
            );
          }

          return item;
        });
      },
      extensions: {
        protobufField: {
          name: "optional_my_enums",
          typeFullName: "testapi.enums.MyEnum",
        },
      },
    }),
    requiredMyEnumWithoutUnspecifieds: t.field({
      type: [MyEnumWithoutUnspecified$Ref],
      nullable: { list: false, items: false },
      description: "Required.",
      resolve: (source) => {
        return source.requiredMyEnumWithoutUnspecifieds;
      },
      extensions: {
        protobufField: {
          name: "required_my_enum_without_unspecifieds",
          typeFullName: "testapi.enums.MyEnumWithoutUnspecified",
        },
      },
    }),
    optionalMyEnumWithoutUnspecifieds: t.field({
      type: [MyEnumWithoutUnspecified$Ref],
      nullable: { list: true, items: false },
      description: "Optional.",
      resolve: (source) => {
        return source.optionalMyEnumWithoutUnspecifieds;
      },
      extensions: {
        protobufField: {
          name: "optional_my_enum_without_unspecifieds",
          typeFullName: "testapi.enums.MyEnumWithoutUnspecified",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as MessageWithEnums | { $type: string & {}; }).$type ===
      "testapi.enums.MessageWithEnums";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapi.enums.MessageWithEnums",
      name: "MessageWithEnums",
      package: "testapi.enums",
    },
  },
});

export type MessageWithEnumsInput$Shape = {
  requiredMyEnum: MessageWithEnums["requiredMyEnum"];
  optionalMyEnum?: MessageWithEnums["optionalMyEnum"] | null;
  requiredMyEnumWithoutUnspecified:
    MessageWithEnums["requiredMyEnumWithoutUnspecified"];
  optionalMyEnumWithoutUnspecified?:
    | MessageWithEnums["optionalMyEnumWithoutUnspecified"]
    | null;
  requiredMyEnums: MessageWithEnums["requiredMyEnums"];
  optionalMyEnums?: MessageWithEnums["optionalMyEnums"] | null;
  requiredMyEnumWithoutUnspecifieds:
    MessageWithEnums["requiredMyEnumWithoutUnspecifieds"];
  optionalMyEnumWithoutUnspecifieds?:
    | MessageWithEnums["optionalMyEnumWithoutUnspecifieds"]
    | null;
};

export const MessageWithEnumsInput$Ref: InputObjectRef<
  MessageWithEnumsInput$Shape
> = builder.inputRef<MessageWithEnumsInput$Shape>("MessageWithEnumsInput")
  .implement(
    {
      fields: (t) => ({
        requiredMyEnum: t.field({
          type: MyEnum$Ref,
          required: true,
          description: "Required.",
          extensions: {
            protobufField: {
              name: "required_my_enum",
              typeFullName: "testapi.enums.MyEnum",
            },
          },
        }),
        optionalMyEnum: t.field({
          type: MyEnum$Ref,
          required: false,
          description: "Optional.",
          extensions: {
            protobufField: {
              name: "optional_my_enum",
              typeFullName: "testapi.enums.MyEnum",
            },
          },
        }),
        requiredMyEnumWithoutUnspecified: t.field({
          type: MyEnumWithoutUnspecified$Ref,
          required: true,
          description: "Required.",
          extensions: {
            protobufField: {
              name: "required_my_enum_without_unspecified",
              typeFullName: "testapi.enums.MyEnumWithoutUnspecified",
            },
          },
        }),
        optionalMyEnumWithoutUnspecified: t.field({
          type: MyEnumWithoutUnspecified$Ref,
          required: false,
          description: "Optional.",
          extensions: {
            protobufField: {
              name: "optional_my_enum_without_unspecified",
              typeFullName: "testapi.enums.MyEnumWithoutUnspecified",
            },
          },
        }),
        requiredMyEnums: t.field({
          type: [MyEnum$Ref],
          required: { list: true, items: true },
          description: "Required.",
          extensions: {
            protobufField: {
              name: "required_my_enums",
              typeFullName: "testapi.enums.MyEnum",
            },
          },
        }),
        optionalMyEnums: t.field({
          type: [MyEnum$Ref],
          required: { list: false, items: true },
          description: "Optional.",
          extensions: {
            protobufField: {
              name: "optional_my_enums",
              typeFullName: "testapi.enums.MyEnum",
            },
          },
        }),
        requiredMyEnumWithoutUnspecifieds: t.field({
          type: [MyEnumWithoutUnspecified$Ref],
          required: { list: true, items: true },
          description: "Required.",
          extensions: {
            protobufField: {
              name: "required_my_enum_without_unspecifieds",
              typeFullName: "testapi.enums.MyEnumWithoutUnspecified",
            },
          },
        }),
        optionalMyEnumWithoutUnspecifieds: t.field({
          type: [MyEnumWithoutUnspecified$Ref],
          required: { list: false, items: true },
          description: "Optional.",
          extensions: {
            protobufField: {
              name: "optional_my_enum_without_unspecifieds",
              typeFullName: "testapi.enums.MyEnumWithoutUnspecified",
            },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapi.enums.MessageWithEnums",
          name: "MessageWithEnums",
          package: "testapi.enums",
        },
      },
    },
  );

export const MyEnum$Ref: EnumRef<MyEnum, MyEnum> = builder.enumType("MyEnum", {
  values: {
    FOO: {
      value: 1,
      extensions: { protobufEnumValue: { name: "MY_ENUM_FOO" } },
    },
    BAR: {
      description: "This is Bar.",
      value: 2,
      extensions: { protobufEnumValue: { name: "MY_ENUM_BAR" } },
    },
    BAZ: {
      value: 3,
      extensions: { protobufEnumValue: { name: "MY_ENUM_BAZ" } },
    },
  } as const,
  extensions: {
    protobufEnum: {
      name: "MyEnum",
      fullName: "testapi.enums.MyEnum",
      package: "testapi.enums",
    },
  },
});

export const MyEnumWithoutUnspecified$Ref: EnumRef<
  MyEnumWithoutUnspecified,
  MyEnumWithoutUnspecified
> = builder.enumType("MyEnumWithoutUnspecified", {
  values: {
    FOO: {
      value: 0,
      extensions: {
        protobufEnumValue: { name: "MY_ENUM_WITHOUT_UNSPECIFIED_FOO" },
      },
    },
    BAR: {
      value: 1,
      extensions: {
        protobufEnumValue: { name: "MY_ENUM_WITHOUT_UNSPECIFIED_BAR" },
      },
    },
    BAZ: {
      value: 2,
      extensions: {
        protobufEnumValue: { name: "MY_ENUM_WITHOUT_UNSPECIFIED_BAZ" },
      },
    },
  } as const,
  extensions: {
    protobufEnum: {
      name: "MyEnumWithoutUnspecified",
      fullName: "testapi.enums.MyEnumWithoutUnspecified",
      package: "testapi.enums",
    },
  },
});
",
    "name": "testapis/enums/enums.pb.pothos.ts",
  },
]
`;

exports[`'testapis.extensions' > generates files by plugin 'with import prefix' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/extensions/extensions.proto

/* eslint-disable */

import { EnumRef, InputObjectRef } from "@pothos/core";
import {
  EnumWillRename,
  IgnoredMessage_NotIgnored,
  InterfaceMessage,
  InterfaceMessage_Type,
  MessageOnlyOutput,
  MessageWillRename,
  PrefixedEnum,
  PrefixedMessage,
  PrefixedMessage_InnerMessage,
  PrefixedMessage_InnerMessage2,
} from "@testapis/ts-proto/testapis/extensions/extensions";
import { builder } from "../../builder";

export const TestPrefixPrefixedMessage$Ref = builder.objectRef<PrefixedMessage>(
  "TestPrefixPrefixedMessage",
);
builder.objectType(TestPrefixPrefixedMessage$Ref, {
  name: "TestPrefixPrefixedMessage",
  fields: (t) => ({
    id: t.expose("id", {
      type: "String",
      nullable: false,
      description: "Output only.",
      extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
    }),
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
    prefixedEnum: t.field({
      type: TestPrefixPrefixedEnum$Ref,
      nullable: true,
      resolve: (source) => {
        if (source.prefixedEnum === PrefixedEnum.PREFIXED_ENUM_UNSPECIFIED) {
          return null;
        }

        if (source.prefixedEnum === PrefixedEnum.PREFIXED_IGNORED) {
          throw new Error("PREFIXED_IGNORED is ignored in GraphQL schema");
        }

        return source.prefixedEnum;
      },
      extensions: {
        protobufField: {
          name: "prefixed_enum",
          typeFullName: "testapis.extensions.PrefixedEnum",
        },
      },
    }),
    notIgnoredMessage: t.expose("notIgnoredMessage", {
      type: TestPrefixIgnoredMessageNotIgnored$Ref,
      nullable: true,
      extensions: {
        protobufField: {
          name: "not_ignored_message",
          typeFullName: "testapis.extensions.IgnoredMessage.NotIgnored",
        },
      },
    }),
    squashedMessage: t.field({
      type: TestPrefixPrefixedMessageSquashedMessage$Ref,
      nullable: true,
      resolve: (source) => {
        const value = source.squashedMessage?.oneofField ??
          source.squashedMessage?.oneofField2;
        if (value == null) {
          return null;
        }
        return value;
      },
      extensions: {
        protobufField: {
          name: "squashed_message",
          typeFullName: "testapis.extensions.PrefixedMessage.SquashedMessage",
        },
      },
    }),
    thisFieldWasRenamed: t.expose("thisFieldWillBeRenamed", {
      type: "String",
      nullable: false,
      extensions: {
        protobufField: {
          name: "this_field_will_be_renamed",
          typeFullName: "string",
          options: { "[graphql.field]": { name: "thisFieldWasRenamed" } },
        },
      },
    }),
    skipResolver: t.expose("skipResolver", {
      type: "String",
      nullable: false,
      extensions: {
        protobufField: {
          name: "skip_resolver",
          typeFullName: "string",
          options: { "[graphql.field]": { skipResolver: true } },
        },
      },
    }),
    squashedMessages: t.field({
      type: [TestPrefixPrefixedMessageSquashedMessage$Ref],
      nullable: { list: true, items: false },
      resolve: (source) => {
        return source.squashedMessages.map((item) => {
          const value = item?.oneofField ?? item?.oneofField2;
          if (value == null) {
            throw new Error("squashedMessages should not be null");
          }
          return value;
        });
      },
      extensions: {
        protobufField: {
          name: "squashed_messages",
          typeFullName: "testapis.extensions.PrefixedMessage.SquashedMessage",
        },
      },
    }),
    renamedMessage: t.expose("renamedMessage", {
      type: TestPrefixRenamedMessage$Ref,
      nullable: true,
      extensions: {
        protobufField: {
          name: "renamed_message",
          typeFullName: "testapis.extensions.MessageWillRename",
        },
      },
    }),
    renamedEnum: t.field({
      type: TestPrefixRenamedEnum$Ref,
      nullable: true,
      resolve: (source) => {
        if (
          source.renamedEnum === EnumWillRename.ENUM_WILL_RENAME_UNSPECIFIED
        ) {
          return null;
        }

        return source.renamedEnum;
      },
      extensions: {
        protobufField: {
          name: "renamed_enum",
          typeFullName: "testapis.extensions.EnumWillRename",
        },
      },
    }),
    partialIgnoreOneof: t.field({
      type: TestPrefixPrefixedMessagePartialIgnoreOneof$Ref,
      nullable: true,
      resolve: (source) => {
        const value = source.oneofNotIgnoredField;
        if (value == null) {
          return null;
        }
        return value;
      },
      extensions: { protobufField: { name: "partial_ignore_oneof" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as PrefixedMessage | { $type: string & {}; }).$type ===
      "testapis.extensions.PrefixedMessage";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.PrefixedMessage",
      name: "PrefixedMessage",
      package: "testapis.extensions",
    },
  },
});

export const TestPrefixRenamedMessage$Ref = builder.objectRef<
  MessageWillRename
>("TestPrefixRenamedMessage");
builder.objectType(TestPrefixRenamedMessage$Ref, {
  name: "TestPrefixRenamedMessage",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as MessageWillRename | { $type: string & {}; }).$type ===
      "testapis.extensions.MessageWillRename";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.MessageWillRename",
      name: "MessageWillRename",
      package: "testapis.extensions",
      options: { "[graphql.object_type]": { name: "RenamedMessage" } },
    },
  },
});

export const TestPrefixMessageOnlyOutput$Ref = builder.objectRef<
  MessageOnlyOutput
>("TestPrefixMessageOnlyOutput");
builder.objectType(TestPrefixMessageOnlyOutput$Ref, {
  name: "TestPrefixMessageOnlyOutput",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as MessageOnlyOutput | { $type: string & {}; }).$type ===
      "testapis.extensions.MessageOnlyOutput";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.MessageOnlyOutput",
      name: "MessageOnlyOutput",
      package: "testapis.extensions",
      options: { "[graphql.input_type]": { ignore: true } },
    },
  },
});

export const TestPrefixPrefixedMessageInnerMessage$Ref = builder.objectRef<
  PrefixedMessage_InnerMessage
>("TestPrefixPrefixedMessageInnerMessage");
builder.objectType(TestPrefixPrefixedMessageInnerMessage$Ref, {
  name: "TestPrefixPrefixedMessageInnerMessage",
  fields: (t) => ({
    id: t.expose("id", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
    }),
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as PrefixedMessage_InnerMessage | { $type: string & {}; })
      .$type ===
      "testapis.extensions.PrefixedMessage.InnerMessage";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.PrefixedMessage.InnerMessage",
      name: "InnerMessage",
      package: "testapis.extensions",
    },
  },
});

export const TestPrefixPrefixedMessageInnerMessage2$Ref = builder.objectRef<
  PrefixedMessage_InnerMessage2
>("TestPrefixPrefixedMessageInnerMessage2");
builder.objectType(TestPrefixPrefixedMessageInnerMessage2$Ref, {
  name: "TestPrefixPrefixedMessageInnerMessage2",
  fields: (t) => ({
    id: t.expose("id", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
    }),
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as PrefixedMessage_InnerMessage2 | { $type: string & {}; })
      .$type ===
      "testapis.extensions.PrefixedMessage.InnerMessage2";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.PrefixedMessage.InnerMessage2",
      name: "InnerMessage2",
      package: "testapis.extensions",
    },
  },
});

export const TestPrefixIgnoredMessageNotIgnored$Ref = builder.objectRef<
  IgnoredMessage_NotIgnored
>("TestPrefixIgnoredMessageNotIgnored");
builder.objectType(TestPrefixIgnoredMessageNotIgnored$Ref, {
  name: "TestPrefixIgnoredMessageNotIgnored",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as IgnoredMessage_NotIgnored | { $type: string & {}; })
      .$type ===
      "testapis.extensions.IgnoredMessage.NotIgnored";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.IgnoredMessage.NotIgnored",
      name: "NotIgnored",
      package: "testapis.extensions",
    },
  },
});

export type TestPrefixPrefixedMessageInput$Shape = {
  body: PrefixedMessage["body"];
  prefixedEnum?: PrefixedMessage["prefixedEnum"] | null;
  notIgnoredMessage?: TestPrefixIgnoredMessageNotIgnoredInput$Shape | null;
  squashedMessage?: TestPrefixPrefixedMessageSquashedMessageInput$Shape | null;
  thisFieldWasRenamed: PrefixedMessage["thisFieldWillBeRenamed"];
  oneofNotIgnoredField?:
    | TestPrefixPrefixedMessageInnerMessageInput$Shape
    | null;
  skipResolver: PrefixedMessage["skipResolver"];
  squashedMessages?:
    | Array<TestPrefixPrefixedMessageSquashedMessageInput$Shape>
    | null;
  renamedMessage?: TestPrefixRenamedMessageInput$Shape | null;
  renamedEnum?: PrefixedMessage["renamedEnum"] | null;
};

export const TestPrefixPrefixedMessageInput$Ref: InputObjectRef<
  TestPrefixPrefixedMessageInput$Shape
> = builder.inputRef<TestPrefixPrefixedMessageInput$Shape>(
  "TestPrefixPrefixedMessageInput",
).implement(
  {
    fields: (t) => ({
      body: t.field({
        type: "String",
        required: true,
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
      prefixedEnum: t.field({
        type: TestPrefixPrefixedEnum$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "prefixed_enum",
            typeFullName: "testapis.extensions.PrefixedEnum",
          },
        },
      }),
      notIgnoredMessage: t.field({
        type: TestPrefixIgnoredMessageNotIgnoredInput$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "not_ignored_message",
            typeFullName: "testapis.extensions.IgnoredMessage.NotIgnored",
          },
        },
      }),
      squashedMessage: t.field({
        type: TestPrefixPrefixedMessageSquashedMessageInput$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "squashed_message",
            typeFullName: "testapis.extensions.PrefixedMessage.SquashedMessage",
          },
        },
      }),
      thisFieldWasRenamed: t.field({
        type: "String",
        required: true,
        extensions: {
          protobufField: {
            name: "this_field_will_be_renamed",
            typeFullName: "string",
            options: { "[graphql.field]": { name: "thisFieldWasRenamed" } },
          },
        },
      }),
      oneofNotIgnoredField: t.field({
        type: TestPrefixPrefixedMessageInnerMessageInput$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "oneof_not_ignored_field",
            typeFullName: "testapis.extensions.PrefixedMessage.InnerMessage",
          },
        },
      }),
      skipResolver: t.field({
        type: "String",
        required: true,
        extensions: {
          protobufField: {
            name: "skip_resolver",
            typeFullName: "string",
            options: { "[graphql.field]": { skipResolver: true } },
          },
        },
      }),
      squashedMessages: t.field({
        type: [TestPrefixPrefixedMessageSquashedMessageInput$Ref],
        required: { list: false, items: true },
        extensions: {
          protobufField: {
            name: "squashed_messages",
            typeFullName: "testapis.extensions.PrefixedMessage.SquashedMessage",
          },
        },
      }),
      renamedMessage: t.field({
        type: TestPrefixRenamedMessageInput$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "renamed_message",
            typeFullName: "testapis.extensions.MessageWillRename",
          },
        },
      }),
      renamedEnum: t.field({
        type: TestPrefixRenamedEnum$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "renamed_enum",
            typeFullName: "testapis.extensions.EnumWillRename",
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.extensions.PrefixedMessage",
        name: "PrefixedMessage",
        package: "testapis.extensions",
      },
    },
  },
);

export type TestPrefixRenamedMessageInput$Shape = {
  body: MessageWillRename["body"];
};

export const TestPrefixRenamedMessageInput$Ref: InputObjectRef<
  TestPrefixRenamedMessageInput$Shape
> = builder.inputRef<TestPrefixRenamedMessageInput$Shape>(
  "TestPrefixRenamedMessageInput",
).implement(
  {
    fields: (t) => ({
      body: t.field({
        type: "String",
        required: true,
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.extensions.MessageWillRename",
        name: "MessageWillRename",
        package: "testapis.extensions",
        options: { "[graphql.object_type]": { name: "RenamedMessage" } },
      },
    },
  },
);

export type TestPrefixInterfaceMessageInput$Shape = {
  id: InterfaceMessage["id"];
};

export const TestPrefixInterfaceMessageInput$Ref: InputObjectRef<
  TestPrefixInterfaceMessageInput$Shape
> = builder.inputRef<TestPrefixInterfaceMessageInput$Shape>(
  "TestPrefixInterfaceMessageInput",
).implement(
  {
    fields: (t) => ({
      id: t.field({
        type: "String",
        required: true,
        extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.extensions.InterfaceMessage",
        name: "InterfaceMessage",
        package: "testapis.extensions",
        options: { "[graphql.object_type]": { interface: true } },
      },
    },
  },
);

export type TestPrefixPrefixedMessageInnerMessageInput$Shape = {
  id: PrefixedMessage_InnerMessage["id"];
  body: PrefixedMessage_InnerMessage["body"];
};

export const TestPrefixPrefixedMessageInnerMessageInput$Ref: InputObjectRef<
  TestPrefixPrefixedMessageInnerMessageInput$Shape
> = builder.inputRef<TestPrefixPrefixedMessageInnerMessageInput$Shape>(
  "TestPrefixPrefixedMessageInnerMessageInput",
).implement(
  {
    fields: (t) => ({
      id: t.field({
        type: "String",
        required: true,
        extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
      }),
      body: t.field({
        type: "String",
        required: true,
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.extensions.PrefixedMessage.InnerMessage",
        name: "InnerMessage",
        package: "testapis.extensions",
      },
    },
  },
);

export type TestPrefixPrefixedMessageInnerMessage2Input$Shape = {
  id: PrefixedMessage_InnerMessage2["id"];
  body: PrefixedMessage_InnerMessage2["body"];
};

export const TestPrefixPrefixedMessageInnerMessage2Input$Ref: InputObjectRef<
  TestPrefixPrefixedMessageInnerMessage2Input$Shape
> = builder.inputRef<TestPrefixPrefixedMessageInnerMessage2Input$Shape>(
  "TestPrefixPrefixedMessageInnerMessage2Input",
).implement(
  {
    fields: (t) => ({
      id: t.field({
        type: "String",
        required: true,
        extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
      }),
      body: t.field({
        type: "String",
        required: true,
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.extensions.PrefixedMessage.InnerMessage2",
        name: "InnerMessage2",
        package: "testapis.extensions",
      },
    },
  },
);

export type TestPrefixPrefixedMessageSquashedMessageInput$Shape = {
  oneofField?: TestPrefixPrefixedMessageInnerMessageInput$Shape | null;
  oneofField2?: TestPrefixPrefixedMessageInnerMessage2Input$Shape | null;
};

export const TestPrefixPrefixedMessageSquashedMessageInput$Ref: InputObjectRef<
  TestPrefixPrefixedMessageSquashedMessageInput$Shape
> = builder.inputRef<TestPrefixPrefixedMessageSquashedMessageInput$Shape>(
  "TestPrefixPrefixedMessageSquashedMessageInput",
).implement(
  {
    fields: (t) => ({
      oneofField: t.field({
        type: TestPrefixPrefixedMessageInnerMessageInput$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "oneof_field",
            typeFullName: "testapis.extensions.PrefixedMessage.InnerMessage",
          },
        },
      }),
      oneofField2: t.field({
        type: TestPrefixPrefixedMessageInnerMessage2Input$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "oneof_field_2",
            typeFullName: "testapis.extensions.PrefixedMessage.InnerMessage2",
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.extensions.PrefixedMessage.SquashedMessage",
        name: "SquashedMessage",
        package: "testapis.extensions",
        options: { "[graphql.object_type]": { squashUnion: true } },
      },
    },
  },
);

export type TestPrefixIgnoredMessageNotIgnoredInput$Shape = {
  body: IgnoredMessage_NotIgnored["body"];
};

export const TestPrefixIgnoredMessageNotIgnoredInput$Ref: InputObjectRef<
  TestPrefixIgnoredMessageNotIgnoredInput$Shape
> = builder.inputRef<TestPrefixIgnoredMessageNotIgnoredInput$Shape>(
  "TestPrefixIgnoredMessageNotIgnoredInput",
).implement(
  {
    fields: (t) => ({
      body: t.field({
        type: "String",
        required: true,
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.extensions.IgnoredMessage.NotIgnored",
        name: "NotIgnored",
        package: "testapis.extensions",
      },
    },
  },
);

export const TestPrefixInterfaceMessage$Ref = builder.interfaceRef<
  Pick<
    InterfaceMessage,
    "id"
  >
>("TestPrefixInterfaceMessage");
builder.interfaceType(TestPrefixInterfaceMessage$Ref, {
  name: "TestPrefixInterfaceMessage",
  fields: (t) => ({
    id: t.expose("id", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.InterfaceMessage",
      name: "InterfaceMessage",
      package: "testapis.extensions",
      options: { "[graphql.object_type]": { interface: true } },
    },
  },
});

export const TestPrefixPrefixedMessageSquashedMessage$Ref = builder.unionType(
  "TestPrefixPrefixedMessageSquashedMessage",
  {
    types: [
      TestPrefixPrefixedMessageInnerMessage$Ref,
      TestPrefixPrefixedMessageInnerMessage2$Ref,
    ],
    extensions: {
      protobufOneof: {
        fullName: "testapis.extensions.PrefixedMessage.SquashedMessage",
        name: "SquashedMessage",
        package: "testapis.extensions",
        fields: [{
          name: "oneof_field",
          type: "testapis.extensions.PrefixedMessage.InnerMessage",
          options: { "[graphql.object_type]": { squashUnion: true } },
        }, {
          name: "oneof_field_2",
          type: "testapis.extensions.PrefixedMessage.InnerMessage2",
          options: { "[graphql.object_type]": { squashUnion: true } },
        }],
      },
    },
  },
);

export const TestPrefixPrefixedMessagePartialIgnoreOneof$Ref = builder
  .unionType("TestPrefixPrefixedMessagePartialIgnoreOneof", {
    types: [TestPrefixPrefixedMessageInnerMessage$Ref],
    extensions: {
      protobufOneof: {
        fullName: "testapis.extensions.PrefixedMessage.partial_ignore_oneof",
        name: "partial_ignore_oneof",
        messageName: "PrefixedMessage",
        package: "testapis.extensions",
        fields: [{
          name: "oneof_not_ignored_field",
          type: "testapis.extensions.PrefixedMessage.InnerMessage",
        }],
      },
    },
  });

export const TestPrefixPrefixedEnum$Ref: EnumRef<PrefixedEnum, PrefixedEnum> =
  builder.enumType("TestPrefixPrefixedEnum", {
    values: {
      PREFIXED_FOO: {
        value: 1,
        extensions: { protobufEnumValue: { name: "PREFIXED_FOO" } },
      },
      PREFIXED_BAR: {
        value: 2,
        extensions: { protobufEnumValue: { name: "PREFIXED_BAR" } },
      },
    } as const,
    extensions: {
      protobufEnum: {
        name: "PrefixedEnum",
        fullName: "testapis.extensions.PrefixedEnum",
        package: "testapis.extensions",
      },
    },
  });

export const TestPrefixRenamedEnum$Ref: EnumRef<
  EnumWillRename,
  EnumWillRename
> = builder.enumType("TestPrefixRenamedEnum", {
  values: {
    FOO: {
      value: 1,
      extensions: { protobufEnumValue: { name: "ENUM_WILL_RENAME_FOO" } },
    },
    BAR: {
      value: 2,
      extensions: { protobufEnumValue: { name: "ENUM_WILL_RENAME_BAR" } },
    },
  } as const,
  extensions: {
    protobufEnum: {
      name: "EnumWillRename",
      fullName: "testapis.extensions.EnumWillRename",
      package: "testapis.extensions",
      options: { "[graphql.enum_type]": { name: "RenamedEnum" } },
    },
  },
});

export const TestPrefixInterfaceMessageType$Ref: EnumRef<
  InterfaceMessage_Type,
  InterfaceMessage_Type
> = builder.enumType("TestPrefixInterfaceMessageType", {
  values: {
    INNER: { value: 1, extensions: { protobufEnumValue: { name: "INNER" } } },
    INNER2: { value: 2, extensions: { protobufEnumValue: { name: "INNER2" } } },
  } as const,
  extensions: {
    protobufEnum: {
      name: "Type",
      fullName: "testapis.extensions.InterfaceMessage.Type",
      package: "testapis.extensions",
    },
  },
});
",
    "name": "testapis/extensions/extensions.pb.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/extensions/ignored.proto

/* eslint-disable */

export {};
",
    "name": "testapis/extensions/ignored.pb.pothos.ts",
  },
]
`;

exports[`'testapis.extensions' > generates files by plugin 'with partial inputs' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/extensions/extensions.proto

/* eslint-disable */

import { EnumRef, InputObjectRef } from "@pothos/core";
import {
  EnumWillRename,
  IgnoredMessage_NotIgnored,
  InterfaceMessage,
  InterfaceMessage_Type,
  MessageOnlyOutput,
  MessageWillRename,
  PrefixedEnum,
  PrefixedMessage,
  PrefixedMessage_InnerMessage,
  PrefixedMessage_InnerMessage2,
} from "@testapis/ts-proto/testapis/extensions/extensions";
import { builder } from "../../builder";

export const TestPrefixPrefixedMessage$Ref = builder.objectRef<PrefixedMessage>(
  "TestPrefixPrefixedMessage",
);
builder.objectType(TestPrefixPrefixedMessage$Ref, {
  name: "TestPrefixPrefixedMessage",
  fields: (t) => ({
    id: t.expose("id", {
      type: "String",
      nullable: false,
      description: "Output only.",
      extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
    }),
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
    prefixedEnum: t.field({
      type: TestPrefixPrefixedEnum$Ref,
      nullable: true,
      resolve: (source) => {
        if (source.prefixedEnum === PrefixedEnum.PREFIXED_ENUM_UNSPECIFIED) {
          return null;
        }

        if (source.prefixedEnum === PrefixedEnum.PREFIXED_IGNORED) {
          throw new Error("PREFIXED_IGNORED is ignored in GraphQL schema");
        }

        return source.prefixedEnum;
      },
      extensions: {
        protobufField: {
          name: "prefixed_enum",
          typeFullName: "testapis.extensions.PrefixedEnum",
        },
      },
    }),
    notIgnoredMessage: t.expose("notIgnoredMessage", {
      type: TestPrefixIgnoredMessageNotIgnored$Ref,
      nullable: true,
      extensions: {
        protobufField: {
          name: "not_ignored_message",
          typeFullName: "testapis.extensions.IgnoredMessage.NotIgnored",
        },
      },
    }),
    squashedMessage: t.field({
      type: TestPrefixPrefixedMessageSquashedMessage$Ref,
      nullable: true,
      resolve: (source) => {
        const value = source.squashedMessage?.oneofField ??
          source.squashedMessage?.oneofField2;
        if (value == null) {
          return null;
        }
        return value;
      },
      extensions: {
        protobufField: {
          name: "squashed_message",
          typeFullName: "testapis.extensions.PrefixedMessage.SquashedMessage",
        },
      },
    }),
    thisFieldWasRenamed: t.expose("thisFieldWillBeRenamed", {
      type: "String",
      nullable: false,
      extensions: {
        protobufField: {
          name: "this_field_will_be_renamed",
          typeFullName: "string",
          options: { "[graphql.field]": { name: "thisFieldWasRenamed" } },
        },
      },
    }),
    skipResolver: t.expose("skipResolver", {
      type: "String",
      nullable: false,
      extensions: {
        protobufField: {
          name: "skip_resolver",
          typeFullName: "string",
          options: { "[graphql.field]": { skipResolver: true } },
        },
      },
    }),
    squashedMessages: t.field({
      type: [TestPrefixPrefixedMessageSquashedMessage$Ref],
      nullable: { list: true, items: false },
      resolve: (source) => {
        return source.squashedMessages.map((item) => {
          const value = item?.oneofField ?? item?.oneofField2;
          if (value == null) {
            throw new Error("squashedMessages should not be null");
          }
          return value;
        });
      },
      extensions: {
        protobufField: {
          name: "squashed_messages",
          typeFullName: "testapis.extensions.PrefixedMessage.SquashedMessage",
        },
      },
    }),
    renamedMessage: t.expose("renamedMessage", {
      type: TestPrefixRenamedMessage$Ref,
      nullable: true,
      extensions: {
        protobufField: {
          name: "renamed_message",
          typeFullName: "testapis.extensions.MessageWillRename",
        },
      },
    }),
    renamedEnum: t.field({
      type: TestPrefixRenamedEnum$Ref,
      nullable: true,
      resolve: (source) => {
        if (
          source.renamedEnum === EnumWillRename.ENUM_WILL_RENAME_UNSPECIFIED
        ) {
          return null;
        }

        return source.renamedEnum;
      },
      extensions: {
        protobufField: {
          name: "renamed_enum",
          typeFullName: "testapis.extensions.EnumWillRename",
        },
      },
    }),
    partialIgnoreOneof: t.field({
      type: TestPrefixPrefixedMessagePartialIgnoreOneof$Ref,
      nullable: true,
      resolve: (source) => {
        const value = source.oneofNotIgnoredField;
        if (value == null) {
          return null;
        }
        return value;
      },
      extensions: { protobufField: { name: "partial_ignore_oneof" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as PrefixedMessage | { $type: string & {}; }).$type ===
      "testapis.extensions.PrefixedMessage";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.PrefixedMessage",
      name: "PrefixedMessage",
      package: "testapis.extensions",
    },
  },
});

export const TestPrefixRenamedMessage$Ref = builder.objectRef<
  MessageWillRename
>("TestPrefixRenamedMessage");
builder.objectType(TestPrefixRenamedMessage$Ref, {
  name: "TestPrefixRenamedMessage",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as MessageWillRename | { $type: string & {}; }).$type ===
      "testapis.extensions.MessageWillRename";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.MessageWillRename",
      name: "MessageWillRename",
      package: "testapis.extensions",
      options: { "[graphql.object_type]": { name: "RenamedMessage" } },
    },
  },
});

export const TestPrefixMessageOnlyOutput$Ref = builder.objectRef<
  MessageOnlyOutput
>("TestPrefixMessageOnlyOutput");
builder.objectType(TestPrefixMessageOnlyOutput$Ref, {
  name: "TestPrefixMessageOnlyOutput",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as MessageOnlyOutput | { $type: string & {}; }).$type ===
      "testapis.extensions.MessageOnlyOutput";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.MessageOnlyOutput",
      name: "MessageOnlyOutput",
      package: "testapis.extensions",
      options: { "[graphql.input_type]": { ignore: true } },
    },
  },
});

export const TestPrefixPrefixedMessageInnerMessage$Ref = builder.objectRef<
  PrefixedMessage_InnerMessage
>("TestPrefixPrefixedMessageInnerMessage");
builder.objectType(TestPrefixPrefixedMessageInnerMessage$Ref, {
  name: "TestPrefixPrefixedMessageInnerMessage",
  fields: (t) => ({
    id: t.expose("id", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
    }),
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as PrefixedMessage_InnerMessage | { $type: string & {}; })
      .$type ===
      "testapis.extensions.PrefixedMessage.InnerMessage";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.PrefixedMessage.InnerMessage",
      name: "InnerMessage",
      package: "testapis.extensions",
    },
  },
});

export const TestPrefixPrefixedMessageInnerMessage2$Ref = builder.objectRef<
  PrefixedMessage_InnerMessage2
>("TestPrefixPrefixedMessageInnerMessage2");
builder.objectType(TestPrefixPrefixedMessageInnerMessage2$Ref, {
  name: "TestPrefixPrefixedMessageInnerMessage2",
  fields: (t) => ({
    id: t.expose("id", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
    }),
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as PrefixedMessage_InnerMessage2 | { $type: string & {}; })
      .$type ===
      "testapis.extensions.PrefixedMessage.InnerMessage2";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.PrefixedMessage.InnerMessage2",
      name: "InnerMessage2",
      package: "testapis.extensions",
    },
  },
});

export const TestPrefixIgnoredMessageNotIgnored$Ref = builder.objectRef<
  IgnoredMessage_NotIgnored
>("TestPrefixIgnoredMessageNotIgnored");
builder.objectType(TestPrefixIgnoredMessageNotIgnored$Ref, {
  name: "TestPrefixIgnoredMessageNotIgnored",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as IgnoredMessage_NotIgnored | { $type: string & {}; })
      .$type ===
      "testapis.extensions.IgnoredMessage.NotIgnored";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.IgnoredMessage.NotIgnored",
      name: "NotIgnored",
      package: "testapis.extensions",
    },
  },
});

export type TestPrefixPrefixedMessageInput$Shape = {
  body: PrefixedMessage["body"];
  prefixedEnum?: PrefixedMessage["prefixedEnum"] | null;
  notIgnoredMessage?: TestPrefixIgnoredMessageNotIgnoredInput$Shape | null;
  squashedMessage?: TestPrefixPrefixedMessageSquashedMessageInput$Shape | null;
  thisFieldWasRenamed: PrefixedMessage["thisFieldWillBeRenamed"];
  oneofNotIgnoredField?:
    | TestPrefixPrefixedMessageInnerMessageInput$Shape
    | null;
  skipResolver: PrefixedMessage["skipResolver"];
  squashedMessages?:
    | Array<TestPrefixPrefixedMessageSquashedMessageInput$Shape>
    | null;
  renamedMessage?: TestPrefixRenamedMessageInput$Shape | null;
  renamedEnum?: PrefixedMessage["renamedEnum"] | null;
};

export const TestPrefixPrefixedMessageInput$Ref: InputObjectRef<
  TestPrefixPrefixedMessageInput$Shape
> = builder.inputRef<TestPrefixPrefixedMessageInput$Shape>(
  "TestPrefixPrefixedMessageInput",
).implement(
  {
    fields: (t) => ({
      body: t.field({
        type: "String",
        required: true,
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
      prefixedEnum: t.field({
        type: TestPrefixPrefixedEnum$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "prefixed_enum",
            typeFullName: "testapis.extensions.PrefixedEnum",
          },
        },
      }),
      notIgnoredMessage: t.field({
        type: TestPrefixIgnoredMessageNotIgnoredInput$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "not_ignored_message",
            typeFullName: "testapis.extensions.IgnoredMessage.NotIgnored",
          },
        },
      }),
      squashedMessage: t.field({
        type: TestPrefixPrefixedMessageSquashedMessageInput$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "squashed_message",
            typeFullName: "testapis.extensions.PrefixedMessage.SquashedMessage",
          },
        },
      }),
      thisFieldWasRenamed: t.field({
        type: "String",
        required: true,
        extensions: {
          protobufField: {
            name: "this_field_will_be_renamed",
            typeFullName: "string",
            options: { "[graphql.field]": { name: "thisFieldWasRenamed" } },
          },
        },
      }),
      oneofNotIgnoredField: t.field({
        type: TestPrefixPrefixedMessageInnerMessageInput$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "oneof_not_ignored_field",
            typeFullName: "testapis.extensions.PrefixedMessage.InnerMessage",
          },
        },
      }),
      skipResolver: t.field({
        type: "String",
        required: true,
        extensions: {
          protobufField: {
            name: "skip_resolver",
            typeFullName: "string",
            options: { "[graphql.field]": { skipResolver: true } },
          },
        },
      }),
      squashedMessages: t.field({
        type: [TestPrefixPrefixedMessageSquashedMessageInput$Ref],
        required: { list: false, items: true },
        extensions: {
          protobufField: {
            name: "squashed_messages",
            typeFullName: "testapis.extensions.PrefixedMessage.SquashedMessage",
          },
        },
      }),
      renamedMessage: t.field({
        type: TestPrefixRenamedMessageInput$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "renamed_message",
            typeFullName: "testapis.extensions.MessageWillRename",
          },
        },
      }),
      renamedEnum: t.field({
        type: TestPrefixRenamedEnum$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "renamed_enum",
            typeFullName: "testapis.extensions.EnumWillRename",
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.extensions.PrefixedMessage",
        name: "PrefixedMessage",
        package: "testapis.extensions",
      },
    },
  },
);

export type TestPrefixPrefixedMessagePartialInput$Shape = {
  body?: PrefixedMessage["body"] | null;
  prefixedEnum?: PrefixedMessage["prefixedEnum"] | null;
  notIgnoredMessage?:
    | TestPrefixIgnoredMessageNotIgnoredPartialInput$Shape
    | null;
  squashedMessage?:
    | TestPrefixPrefixedMessageSquashedMessagePartialInput$Shape
    | null;
  thisFieldWasRenamed?: PrefixedMessage["thisFieldWillBeRenamed"] | null;
  oneofNotIgnoredField?:
    | TestPrefixPrefixedMessageInnerMessagePartialInput$Shape
    | null;
  skipResolver?: PrefixedMessage["skipResolver"] | null;
  squashedMessages?:
    | Array<TestPrefixPrefixedMessageSquashedMessagePartialInput$Shape>
    | null;
  renamedMessage?: TestPrefixRenamedMessagePartialInput$Shape | null;
  renamedEnum?: PrefixedMessage["renamedEnum"] | null;
};

export const TestPrefixPrefixedMessagePartialInput$Ref: InputObjectRef<
  TestPrefixPrefixedMessagePartialInput$Shape
> = builder.inputRef<TestPrefixPrefixedMessagePartialInput$Shape>(
  "TestPrefixPrefixedMessagePartialInput",
).implement(
  {
    fields: (t) => ({
      body: t.field({
        type: "String",
        required: false,
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
      prefixedEnum: t.field({
        type: TestPrefixPrefixedEnum$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "prefixed_enum",
            typeFullName: "testapis.extensions.PrefixedEnum",
          },
        },
      }),
      notIgnoredMessage: t.field({
        type: TestPrefixIgnoredMessageNotIgnoredPartialInput$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "not_ignored_message",
            typeFullName: "testapis.extensions.IgnoredMessage.NotIgnored",
          },
        },
      }),
      squashedMessage: t.field({
        type: TestPrefixPrefixedMessageSquashedMessagePartialInput$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "squashed_message",
            typeFullName: "testapis.extensions.PrefixedMessage.SquashedMessage",
          },
        },
      }),
      thisFieldWasRenamed: t.field({
        type: "String",
        required: false,
        extensions: {
          protobufField: {
            name: "this_field_will_be_renamed",
            typeFullName: "string",
            options: { "[graphql.field]": { name: "thisFieldWasRenamed" } },
          },
        },
      }),
      oneofNotIgnoredField: t.field({
        type: TestPrefixPrefixedMessageInnerMessagePartialInput$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "oneof_not_ignored_field",
            typeFullName: "testapis.extensions.PrefixedMessage.InnerMessage",
          },
        },
      }),
      skipResolver: t.field({
        type: "String",
        required: false,
        extensions: {
          protobufField: {
            name: "skip_resolver",
            typeFullName: "string",
            options: { "[graphql.field]": { skipResolver: true } },
          },
        },
      }),
      squashedMessages: t.field({
        type: [TestPrefixPrefixedMessageSquashedMessagePartialInput$Ref],
        required: { list: false, items: true },
        extensions: {
          protobufField: {
            name: "squashed_messages",
            typeFullName: "testapis.extensions.PrefixedMessage.SquashedMessage",
          },
        },
      }),
      renamedMessage: t.field({
        type: TestPrefixRenamedMessagePartialInput$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "renamed_message",
            typeFullName: "testapis.extensions.MessageWillRename",
          },
        },
      }),
      renamedEnum: t.field({
        type: TestPrefixRenamedEnum$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "renamed_enum",
            typeFullName: "testapis.extensions.EnumWillRename",
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.extensions.PrefixedMessage",
        name: "PrefixedMessage",
        package: "testapis.extensions",
      },
    },
  },
);

export type TestPrefixRenamedMessageInput$Shape = {
  body: MessageWillRename["body"];
};

export const TestPrefixRenamedMessageInput$Ref: InputObjectRef<
  TestPrefixRenamedMessageInput$Shape
> = builder.inputRef<TestPrefixRenamedMessageInput$Shape>(
  "TestPrefixRenamedMessageInput",
).implement(
  {
    fields: (t) => ({
      body: t.field({
        type: "String",
        required: true,
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.extensions.MessageWillRename",
        name: "MessageWillRename",
        package: "testapis.extensions",
        options: { "[graphql.object_type]": { name: "RenamedMessage" } },
      },
    },
  },
);

export type TestPrefixRenamedMessagePartialInput$Shape = {
  body?: MessageWillRename["body"] | null;
};

export const TestPrefixRenamedMessagePartialInput$Ref: InputObjectRef<
  TestPrefixRenamedMessagePartialInput$Shape
> = builder.inputRef<TestPrefixRenamedMessagePartialInput$Shape>(
  "TestPrefixRenamedMessagePartialInput",
).implement(
  {
    fields: (t) => ({
      body: t.field({
        type: "String",
        required: false,
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.extensions.MessageWillRename",
        name: "MessageWillRename",
        package: "testapis.extensions",
        options: { "[graphql.object_type]": { name: "RenamedMessage" } },
      },
    },
  },
);

export type TestPrefixInterfaceMessageInput$Shape = {
  id: InterfaceMessage["id"];
};

export const TestPrefixInterfaceMessageInput$Ref: InputObjectRef<
  TestPrefixInterfaceMessageInput$Shape
> = builder.inputRef<TestPrefixInterfaceMessageInput$Shape>(
  "TestPrefixInterfaceMessageInput",
).implement(
  {
    fields: (t) => ({
      id: t.field({
        type: "String",
        required: true,
        extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.extensions.InterfaceMessage",
        name: "InterfaceMessage",
        package: "testapis.extensions",
        options: { "[graphql.object_type]": { interface: true } },
      },
    },
  },
);

export type TestPrefixInterfaceMessagePartialInput$Shape = {
  id?: InterfaceMessage["id"] | null;
};

export const TestPrefixInterfaceMessagePartialInput$Ref: InputObjectRef<
  TestPrefixInterfaceMessagePartialInput$Shape
> = builder.inputRef<TestPrefixInterfaceMessagePartialInput$Shape>(
  "TestPrefixInterfaceMessagePartialInput",
).implement(
  {
    fields: (t) => ({
      id: t.field({
        type: "String",
        required: false,
        extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.extensions.InterfaceMessage",
        name: "InterfaceMessage",
        package: "testapis.extensions",
        options: { "[graphql.object_type]": { interface: true } },
      },
    },
  },
);

export type TestPrefixPrefixedMessageInnerMessageInput$Shape = {
  id: PrefixedMessage_InnerMessage["id"];
  body: PrefixedMessage_InnerMessage["body"];
};

export const TestPrefixPrefixedMessageInnerMessageInput$Ref: InputObjectRef<
  TestPrefixPrefixedMessageInnerMessageInput$Shape
> = builder.inputRef<TestPrefixPrefixedMessageInnerMessageInput$Shape>(
  "TestPrefixPrefixedMessageInnerMessageInput",
).implement(
  {
    fields: (t) => ({
      id: t.field({
        type: "String",
        required: true,
        extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
      }),
      body: t.field({
        type: "String",
        required: true,
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.extensions.PrefixedMessage.InnerMessage",
        name: "InnerMessage",
        package: "testapis.extensions",
      },
    },
  },
);

export type TestPrefixPrefixedMessageInnerMessagePartialInput$Shape = {
  id?: PrefixedMessage_InnerMessage["id"] | null;
  body?: PrefixedMessage_InnerMessage["body"] | null;
};

export const TestPrefixPrefixedMessageInnerMessagePartialInput$Ref:
  InputObjectRef<TestPrefixPrefixedMessageInnerMessagePartialInput$Shape> =
    builder.inputRef<TestPrefixPrefixedMessageInnerMessagePartialInput$Shape>(
      "TestPrefixPrefixedMessageInnerMessagePartialInput",
    ).implement(
      {
        fields: (t) => ({
          id: t.field({
            type: "String",
            required: false,
            extensions: {
              protobufField: { name: "id", typeFullName: "uint64" },
            },
          }),
          body: t.field({
            type: "String",
            required: false,
            extensions: {
              protobufField: { name: "body", typeFullName: "string" },
            },
          }),
        }),
        extensions: {
          protobufMessage: {
            fullName: "testapis.extensions.PrefixedMessage.InnerMessage",
            name: "InnerMessage",
            package: "testapis.extensions",
          },
        },
      },
    );

export type TestPrefixPrefixedMessageInnerMessage2Input$Shape = {
  id: PrefixedMessage_InnerMessage2["id"];
  body: PrefixedMessage_InnerMessage2["body"];
};

export const TestPrefixPrefixedMessageInnerMessage2Input$Ref: InputObjectRef<
  TestPrefixPrefixedMessageInnerMessage2Input$Shape
> = builder.inputRef<TestPrefixPrefixedMessageInnerMessage2Input$Shape>(
  "TestPrefixPrefixedMessageInnerMessage2Input",
).implement(
  {
    fields: (t) => ({
      id: t.field({
        type: "String",
        required: true,
        extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
      }),
      body: t.field({
        type: "String",
        required: true,
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.extensions.PrefixedMessage.InnerMessage2",
        name: "InnerMessage2",
        package: "testapis.extensions",
      },
    },
  },
);

export type TestPrefixPrefixedMessageInnerMessage2PartialInput$Shape = {
  id?: PrefixedMessage_InnerMessage2["id"] | null;
  body?: PrefixedMessage_InnerMessage2["body"] | null;
};

export const TestPrefixPrefixedMessageInnerMessage2PartialInput$Ref:
  InputObjectRef<TestPrefixPrefixedMessageInnerMessage2PartialInput$Shape> =
    builder.inputRef<TestPrefixPrefixedMessageInnerMessage2PartialInput$Shape>(
      "TestPrefixPrefixedMessageInnerMessage2PartialInput",
    ).implement(
      {
        fields: (t) => ({
          id: t.field({
            type: "String",
            required: false,
            extensions: {
              protobufField: { name: "id", typeFullName: "uint64" },
            },
          }),
          body: t.field({
            type: "String",
            required: false,
            extensions: {
              protobufField: { name: "body", typeFullName: "string" },
            },
          }),
        }),
        extensions: {
          protobufMessage: {
            fullName: "testapis.extensions.PrefixedMessage.InnerMessage2",
            name: "InnerMessage2",
            package: "testapis.extensions",
          },
        },
      },
    );

export type TestPrefixPrefixedMessageSquashedMessageInput$Shape = {
  oneofField?: TestPrefixPrefixedMessageInnerMessageInput$Shape | null;
  oneofField2?: TestPrefixPrefixedMessageInnerMessage2Input$Shape | null;
};

export const TestPrefixPrefixedMessageSquashedMessageInput$Ref: InputObjectRef<
  TestPrefixPrefixedMessageSquashedMessageInput$Shape
> = builder.inputRef<TestPrefixPrefixedMessageSquashedMessageInput$Shape>(
  "TestPrefixPrefixedMessageSquashedMessageInput",
).implement(
  {
    fields: (t) => ({
      oneofField: t.field({
        type: TestPrefixPrefixedMessageInnerMessageInput$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "oneof_field",
            typeFullName: "testapis.extensions.PrefixedMessage.InnerMessage",
          },
        },
      }),
      oneofField2: t.field({
        type: TestPrefixPrefixedMessageInnerMessage2Input$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "oneof_field_2",
            typeFullName: "testapis.extensions.PrefixedMessage.InnerMessage2",
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.extensions.PrefixedMessage.SquashedMessage",
        name: "SquashedMessage",
        package: "testapis.extensions",
        options: { "[graphql.object_type]": { squashUnion: true } },
      },
    },
  },
);

export type TestPrefixPrefixedMessageSquashedMessagePartialInput$Shape = {
  oneofField?: TestPrefixPrefixedMessageInnerMessagePartialInput$Shape | null;
  oneofField2?: TestPrefixPrefixedMessageInnerMessage2PartialInput$Shape | null;
};

export const TestPrefixPrefixedMessageSquashedMessagePartialInput$Ref:
  InputObjectRef<TestPrefixPrefixedMessageSquashedMessagePartialInput$Shape> =
    builder.inputRef<
      TestPrefixPrefixedMessageSquashedMessagePartialInput$Shape
    >("TestPrefixPrefixedMessageSquashedMessagePartialInput").implement(
      {
        fields: (t) => ({
          oneofField: t.field({
            type: TestPrefixPrefixedMessageInnerMessagePartialInput$Ref,
            required: false,
            extensions: {
              protobufField: {
                name: "oneof_field",
                typeFullName:
                  "testapis.extensions.PrefixedMessage.InnerMessage",
              },
            },
          }),
          oneofField2: t.field({
            type: TestPrefixPrefixedMessageInnerMessage2PartialInput$Ref,
            required: false,
            extensions: {
              protobufField: {
                name: "oneof_field_2",
                typeFullName:
                  "testapis.extensions.PrefixedMessage.InnerMessage2",
              },
            },
          }),
        }),
        extensions: {
          protobufMessage: {
            fullName: "testapis.extensions.PrefixedMessage.SquashedMessage",
            name: "SquashedMessage",
            package: "testapis.extensions",
            options: { "[graphql.object_type]": { squashUnion: true } },
          },
        },
      },
    );

export type TestPrefixIgnoredMessageNotIgnoredInput$Shape = {
  body: IgnoredMessage_NotIgnored["body"];
};

export const TestPrefixIgnoredMessageNotIgnoredInput$Ref: InputObjectRef<
  TestPrefixIgnoredMessageNotIgnoredInput$Shape
> = builder.inputRef<TestPrefixIgnoredMessageNotIgnoredInput$Shape>(
  "TestPrefixIgnoredMessageNotIgnoredInput",
).implement(
  {
    fields: (t) => ({
      body: t.field({
        type: "String",
        required: true,
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.extensions.IgnoredMessage.NotIgnored",
        name: "NotIgnored",
        package: "testapis.extensions",
      },
    },
  },
);

export type TestPrefixIgnoredMessageNotIgnoredPartialInput$Shape = {
  body?: IgnoredMessage_NotIgnored["body"] | null;
};

export const TestPrefixIgnoredMessageNotIgnoredPartialInput$Ref: InputObjectRef<
  TestPrefixIgnoredMessageNotIgnoredPartialInput$Shape
> = builder.inputRef<TestPrefixIgnoredMessageNotIgnoredPartialInput$Shape>(
  "TestPrefixIgnoredMessageNotIgnoredPartialInput",
).implement(
  {
    fields: (t) => ({
      body: t.field({
        type: "String",
        required: false,
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.extensions.IgnoredMessage.NotIgnored",
        name: "NotIgnored",
        package: "testapis.extensions",
      },
    },
  },
);

export const TestPrefixInterfaceMessage$Ref = builder.interfaceRef<
  Pick<
    InterfaceMessage,
    "id"
  >
>("TestPrefixInterfaceMessage");
builder.interfaceType(TestPrefixInterfaceMessage$Ref, {
  name: "TestPrefixInterfaceMessage",
  fields: (t) => ({
    id: t.expose("id", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.InterfaceMessage",
      name: "InterfaceMessage",
      package: "testapis.extensions",
      options: { "[graphql.object_type]": { interface: true } },
    },
  },
});

export const TestPrefixPrefixedMessageSquashedMessage$Ref = builder.unionType(
  "TestPrefixPrefixedMessageSquashedMessage",
  {
    types: [
      TestPrefixPrefixedMessageInnerMessage$Ref,
      TestPrefixPrefixedMessageInnerMessage2$Ref,
    ],
    extensions: {
      protobufOneof: {
        fullName: "testapis.extensions.PrefixedMessage.SquashedMessage",
        name: "SquashedMessage",
        package: "testapis.extensions",
        fields: [{
          name: "oneof_field",
          type: "testapis.extensions.PrefixedMessage.InnerMessage",
          options: { "[graphql.object_type]": { squashUnion: true } },
        }, {
          name: "oneof_field_2",
          type: "testapis.extensions.PrefixedMessage.InnerMessage2",
          options: { "[graphql.object_type]": { squashUnion: true } },
        }],
      },
    },
  },
);

export const TestPrefixPrefixedMessagePartialIgnoreOneof$Ref = builder
  .unionType("TestPrefixPrefixedMessagePartialIgnoreOneof", {
    types: [TestPrefixPrefixedMessageInnerMessage$Ref],
    extensions: {
      protobufOneof: {
        fullName: "testapis.extensions.PrefixedMessage.partial_ignore_oneof",
        name: "partial_ignore_oneof",
        messageName: "PrefixedMessage",
        package: "testapis.extensions",
        fields: [{
          name: "oneof_not_ignored_field",
          type: "testapis.extensions.PrefixedMessage.InnerMessage",
        }],
      },
    },
  });

export const TestPrefixPrefixedEnum$Ref: EnumRef<PrefixedEnum, PrefixedEnum> =
  builder.enumType("TestPrefixPrefixedEnum", {
    values: {
      PREFIXED_FOO: {
        value: 1,
        extensions: { protobufEnumValue: { name: "PREFIXED_FOO" } },
      },
      PREFIXED_BAR: {
        value: 2,
        extensions: { protobufEnumValue: { name: "PREFIXED_BAR" } },
      },
    } as const,
    extensions: {
      protobufEnum: {
        name: "PrefixedEnum",
        fullName: "testapis.extensions.PrefixedEnum",
        package: "testapis.extensions",
      },
    },
  });

export const TestPrefixRenamedEnum$Ref: EnumRef<
  EnumWillRename,
  EnumWillRename
> = builder.enumType("TestPrefixRenamedEnum", {
  values: {
    FOO: {
      value: 1,
      extensions: { protobufEnumValue: { name: "ENUM_WILL_RENAME_FOO" } },
    },
    BAR: {
      value: 2,
      extensions: { protobufEnumValue: { name: "ENUM_WILL_RENAME_BAR" } },
    },
  } as const,
  extensions: {
    protobufEnum: {
      name: "EnumWillRename",
      fullName: "testapis.extensions.EnumWillRename",
      package: "testapis.extensions",
      options: { "[graphql.enum_type]": { name: "RenamedEnum" } },
    },
  },
});

export const TestPrefixInterfaceMessageType$Ref: EnumRef<
  InterfaceMessage_Type,
  InterfaceMessage_Type
> = builder.enumType("TestPrefixInterfaceMessageType", {
  values: {
    INNER: { value: 1, extensions: { protobufEnumValue: { name: "INNER" } } },
    INNER2: { value: 2, extensions: { protobufEnumValue: { name: "INNER2" } } },
  } as const,
  extensions: {
    protobufEnum: {
      name: "Type",
      fullName: "testapis.extensions.InterfaceMessage.Type",
      package: "testapis.extensions",
    },
  },
});
",
    "name": "testapis/extensions/extensions.pb.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/extensions/ignored.proto

/* eslint-disable */

export {};
",
    "name": "testapis/extensions/ignored.pb.pothos.ts",
  },
]
`;

exports[`'testapis.extensions' > generates files by plugin 'without import prefix' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/extensions/extensions.proto

/* eslint-disable */

import { EnumRef, InputObjectRef } from "@pothos/core";
import { builder } from "../../builder";
import {
  EnumWillRename,
  IgnoredMessage_NotIgnored,
  InterfaceMessage,
  InterfaceMessage_Type,
  MessageOnlyOutput,
  MessageWillRename,
  PrefixedEnum,
  PrefixedMessage,
  PrefixedMessage_InnerMessage,
  PrefixedMessage_InnerMessage2,
} from "./testapis/extensions/extensions";

export const TestPrefixPrefixedMessage$Ref = builder.objectRef<PrefixedMessage>(
  "TestPrefixPrefixedMessage",
);
builder.objectType(TestPrefixPrefixedMessage$Ref, {
  name: "TestPrefixPrefixedMessage",
  fields: (t) => ({
    id: t.expose("id", {
      type: "String",
      nullable: false,
      description: "Output only.",
      extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
    }),
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
    prefixedEnum: t.field({
      type: TestPrefixPrefixedEnum$Ref,
      nullable: true,
      resolve: (source) => {
        if (source.prefixedEnum === PrefixedEnum.PREFIXED_ENUM_UNSPECIFIED) {
          return null;
        }

        if (source.prefixedEnum === PrefixedEnum.PREFIXED_IGNORED) {
          throw new Error("PREFIXED_IGNORED is ignored in GraphQL schema");
        }

        return source.prefixedEnum;
      },
      extensions: {
        protobufField: {
          name: "prefixed_enum",
          typeFullName: "testapis.extensions.PrefixedEnum",
        },
      },
    }),
    notIgnoredMessage: t.expose("notIgnoredMessage", {
      type: TestPrefixIgnoredMessageNotIgnored$Ref,
      nullable: true,
      extensions: {
        protobufField: {
          name: "not_ignored_message",
          typeFullName: "testapis.extensions.IgnoredMessage.NotIgnored",
        },
      },
    }),
    squashedMessage: t.field({
      type: TestPrefixPrefixedMessageSquashedMessage$Ref,
      nullable: true,
      resolve: (source) => {
        const value = source.squashedMessage?.oneofField ??
          source.squashedMessage?.oneofField2;
        if (value == null) {
          return null;
        }
        return value;
      },
      extensions: {
        protobufField: {
          name: "squashed_message",
          typeFullName: "testapis.extensions.PrefixedMessage.SquashedMessage",
        },
      },
    }),
    thisFieldWasRenamed: t.expose("thisFieldWillBeRenamed", {
      type: "String",
      nullable: false,
      extensions: {
        protobufField: {
          name: "this_field_will_be_renamed",
          typeFullName: "string",
          options: { "[graphql.field]": { name: "thisFieldWasRenamed" } },
        },
      },
    }),
    skipResolver: t.expose("skipResolver", {
      type: "String",
      nullable: false,
      extensions: {
        protobufField: {
          name: "skip_resolver",
          typeFullName: "string",
          options: { "[graphql.field]": { skipResolver: true } },
        },
      },
    }),
    squashedMessages: t.field({
      type: [TestPrefixPrefixedMessageSquashedMessage$Ref],
      nullable: { list: true, items: false },
      resolve: (source) => {
        return source.squashedMessages.map((item) => {
          const value = item?.oneofField ?? item?.oneofField2;
          if (value == null) {
            throw new Error("squashedMessages should not be null");
          }
          return value;
        });
      },
      extensions: {
        protobufField: {
          name: "squashed_messages",
          typeFullName: "testapis.extensions.PrefixedMessage.SquashedMessage",
        },
      },
    }),
    renamedMessage: t.expose("renamedMessage", {
      type: TestPrefixRenamedMessage$Ref,
      nullable: true,
      extensions: {
        protobufField: {
          name: "renamed_message",
          typeFullName: "testapis.extensions.MessageWillRename",
        },
      },
    }),
    renamedEnum: t.field({
      type: TestPrefixRenamedEnum$Ref,
      nullable: true,
      resolve: (source) => {
        if (
          source.renamedEnum === EnumWillRename.ENUM_WILL_RENAME_UNSPECIFIED
        ) {
          return null;
        }

        return source.renamedEnum;
      },
      extensions: {
        protobufField: {
          name: "renamed_enum",
          typeFullName: "testapis.extensions.EnumWillRename",
        },
      },
    }),
    partialIgnoreOneof: t.field({
      type: TestPrefixPrefixedMessagePartialIgnoreOneof$Ref,
      nullable: true,
      resolve: (source) => {
        const value = source.oneofNotIgnoredField;
        if (value == null) {
          return null;
        }
        return value;
      },
      extensions: { protobufField: { name: "partial_ignore_oneof" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as PrefixedMessage | { $type: string & {}; }).$type ===
      "testapis.extensions.PrefixedMessage";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.PrefixedMessage",
      name: "PrefixedMessage",
      package: "testapis.extensions",
    },
  },
});

export const TestPrefixRenamedMessage$Ref = builder.objectRef<
  MessageWillRename
>("TestPrefixRenamedMessage");
builder.objectType(TestPrefixRenamedMessage$Ref, {
  name: "TestPrefixRenamedMessage",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as MessageWillRename | { $type: string & {}; }).$type ===
      "testapis.extensions.MessageWillRename";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.MessageWillRename",
      name: "MessageWillRename",
      package: "testapis.extensions",
      options: { "[graphql.object_type]": { name: "RenamedMessage" } },
    },
  },
});

export const TestPrefixMessageOnlyOutput$Ref = builder.objectRef<
  MessageOnlyOutput
>("TestPrefixMessageOnlyOutput");
builder.objectType(TestPrefixMessageOnlyOutput$Ref, {
  name: "TestPrefixMessageOnlyOutput",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as MessageOnlyOutput | { $type: string & {}; }).$type ===
      "testapis.extensions.MessageOnlyOutput";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.MessageOnlyOutput",
      name: "MessageOnlyOutput",
      package: "testapis.extensions",
      options: { "[graphql.input_type]": { ignore: true } },
    },
  },
});

export const TestPrefixPrefixedMessageInnerMessage$Ref = builder.objectRef<
  PrefixedMessage_InnerMessage
>("TestPrefixPrefixedMessageInnerMessage");
builder.objectType(TestPrefixPrefixedMessageInnerMessage$Ref, {
  name: "TestPrefixPrefixedMessageInnerMessage",
  fields: (t) => ({
    id: t.expose("id", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
    }),
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as PrefixedMessage_InnerMessage | { $type: string & {}; })
      .$type ===
      "testapis.extensions.PrefixedMessage.InnerMessage";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.PrefixedMessage.InnerMessage",
      name: "InnerMessage",
      package: "testapis.extensions",
    },
  },
});

export const TestPrefixPrefixedMessageInnerMessage2$Ref = builder.objectRef<
  PrefixedMessage_InnerMessage2
>("TestPrefixPrefixedMessageInnerMessage2");
builder.objectType(TestPrefixPrefixedMessageInnerMessage2$Ref, {
  name: "TestPrefixPrefixedMessageInnerMessage2",
  fields: (t) => ({
    id: t.expose("id", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
    }),
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as PrefixedMessage_InnerMessage2 | { $type: string & {}; })
      .$type ===
      "testapis.extensions.PrefixedMessage.InnerMessage2";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.PrefixedMessage.InnerMessage2",
      name: "InnerMessage2",
      package: "testapis.extensions",
    },
  },
});

export const TestPrefixIgnoredMessageNotIgnored$Ref = builder.objectRef<
  IgnoredMessage_NotIgnored
>("TestPrefixIgnoredMessageNotIgnored");
builder.objectType(TestPrefixIgnoredMessageNotIgnored$Ref, {
  name: "TestPrefixIgnoredMessageNotIgnored",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as IgnoredMessage_NotIgnored | { $type: string & {}; })
      .$type ===
      "testapis.extensions.IgnoredMessage.NotIgnored";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.IgnoredMessage.NotIgnored",
      name: "NotIgnored",
      package: "testapis.extensions",
    },
  },
});

export type TestPrefixPrefixedMessageInput$Shape = {
  body: PrefixedMessage["body"];
  prefixedEnum?: PrefixedMessage["prefixedEnum"] | null;
  notIgnoredMessage?: TestPrefixIgnoredMessageNotIgnoredInput$Shape | null;
  squashedMessage?: TestPrefixPrefixedMessageSquashedMessageInput$Shape | null;
  thisFieldWasRenamed: PrefixedMessage["thisFieldWillBeRenamed"];
  oneofNotIgnoredField?:
    | TestPrefixPrefixedMessageInnerMessageInput$Shape
    | null;
  skipResolver: PrefixedMessage["skipResolver"];
  squashedMessages?:
    | Array<TestPrefixPrefixedMessageSquashedMessageInput$Shape>
    | null;
  renamedMessage?: TestPrefixRenamedMessageInput$Shape | null;
  renamedEnum?: PrefixedMessage["renamedEnum"] | null;
};

export const TestPrefixPrefixedMessageInput$Ref: InputObjectRef<
  TestPrefixPrefixedMessageInput$Shape
> = builder.inputRef<TestPrefixPrefixedMessageInput$Shape>(
  "TestPrefixPrefixedMessageInput",
).implement(
  {
    fields: (t) => ({
      body: t.field({
        type: "String",
        required: true,
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
      prefixedEnum: t.field({
        type: TestPrefixPrefixedEnum$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "prefixed_enum",
            typeFullName: "testapis.extensions.PrefixedEnum",
          },
        },
      }),
      notIgnoredMessage: t.field({
        type: TestPrefixIgnoredMessageNotIgnoredInput$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "not_ignored_message",
            typeFullName: "testapis.extensions.IgnoredMessage.NotIgnored",
          },
        },
      }),
      squashedMessage: t.field({
        type: TestPrefixPrefixedMessageSquashedMessageInput$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "squashed_message",
            typeFullName: "testapis.extensions.PrefixedMessage.SquashedMessage",
          },
        },
      }),
      thisFieldWasRenamed: t.field({
        type: "String",
        required: true,
        extensions: {
          protobufField: {
            name: "this_field_will_be_renamed",
            typeFullName: "string",
            options: { "[graphql.field]": { name: "thisFieldWasRenamed" } },
          },
        },
      }),
      oneofNotIgnoredField: t.field({
        type: TestPrefixPrefixedMessageInnerMessageInput$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "oneof_not_ignored_field",
            typeFullName: "testapis.extensions.PrefixedMessage.InnerMessage",
          },
        },
      }),
      skipResolver: t.field({
        type: "String",
        required: true,
        extensions: {
          protobufField: {
            name: "skip_resolver",
            typeFullName: "string",
            options: { "[graphql.field]": { skipResolver: true } },
          },
        },
      }),
      squashedMessages: t.field({
        type: [TestPrefixPrefixedMessageSquashedMessageInput$Ref],
        required: { list: false, items: true },
        extensions: {
          protobufField: {
            name: "squashed_messages",
            typeFullName: "testapis.extensions.PrefixedMessage.SquashedMessage",
          },
        },
      }),
      renamedMessage: t.field({
        type: TestPrefixRenamedMessageInput$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "renamed_message",
            typeFullName: "testapis.extensions.MessageWillRename",
          },
        },
      }),
      renamedEnum: t.field({
        type: TestPrefixRenamedEnum$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "renamed_enum",
            typeFullName: "testapis.extensions.EnumWillRename",
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.extensions.PrefixedMessage",
        name: "PrefixedMessage",
        package: "testapis.extensions",
      },
    },
  },
);

export type TestPrefixRenamedMessageInput$Shape = {
  body: MessageWillRename["body"];
};

export const TestPrefixRenamedMessageInput$Ref: InputObjectRef<
  TestPrefixRenamedMessageInput$Shape
> = builder.inputRef<TestPrefixRenamedMessageInput$Shape>(
  "TestPrefixRenamedMessageInput",
).implement(
  {
    fields: (t) => ({
      body: t.field({
        type: "String",
        required: true,
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.extensions.MessageWillRename",
        name: "MessageWillRename",
        package: "testapis.extensions",
        options: { "[graphql.object_type]": { name: "RenamedMessage" } },
      },
    },
  },
);

export type TestPrefixInterfaceMessageInput$Shape = {
  id: InterfaceMessage["id"];
};

export const TestPrefixInterfaceMessageInput$Ref: InputObjectRef<
  TestPrefixInterfaceMessageInput$Shape
> = builder.inputRef<TestPrefixInterfaceMessageInput$Shape>(
  "TestPrefixInterfaceMessageInput",
).implement(
  {
    fields: (t) => ({
      id: t.field({
        type: "String",
        required: true,
        extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.extensions.InterfaceMessage",
        name: "InterfaceMessage",
        package: "testapis.extensions",
        options: { "[graphql.object_type]": { interface: true } },
      },
    },
  },
);

export type TestPrefixPrefixedMessageInnerMessageInput$Shape = {
  id: PrefixedMessage_InnerMessage["id"];
  body: PrefixedMessage_InnerMessage["body"];
};

export const TestPrefixPrefixedMessageInnerMessageInput$Ref: InputObjectRef<
  TestPrefixPrefixedMessageInnerMessageInput$Shape
> = builder.inputRef<TestPrefixPrefixedMessageInnerMessageInput$Shape>(
  "TestPrefixPrefixedMessageInnerMessageInput",
).implement(
  {
    fields: (t) => ({
      id: t.field({
        type: "String",
        required: true,
        extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
      }),
      body: t.field({
        type: "String",
        required: true,
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.extensions.PrefixedMessage.InnerMessage",
        name: "InnerMessage",
        package: "testapis.extensions",
      },
    },
  },
);

export type TestPrefixPrefixedMessageInnerMessage2Input$Shape = {
  id: PrefixedMessage_InnerMessage2["id"];
  body: PrefixedMessage_InnerMessage2["body"];
};

export const TestPrefixPrefixedMessageInnerMessage2Input$Ref: InputObjectRef<
  TestPrefixPrefixedMessageInnerMessage2Input$Shape
> = builder.inputRef<TestPrefixPrefixedMessageInnerMessage2Input$Shape>(
  "TestPrefixPrefixedMessageInnerMessage2Input",
).implement(
  {
    fields: (t) => ({
      id: t.field({
        type: "String",
        required: true,
        extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
      }),
      body: t.field({
        type: "String",
        required: true,
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.extensions.PrefixedMessage.InnerMessage2",
        name: "InnerMessage2",
        package: "testapis.extensions",
      },
    },
  },
);

export type TestPrefixPrefixedMessageSquashedMessageInput$Shape = {
  oneofField?: TestPrefixPrefixedMessageInnerMessageInput$Shape | null;
  oneofField2?: TestPrefixPrefixedMessageInnerMessage2Input$Shape | null;
};

export const TestPrefixPrefixedMessageSquashedMessageInput$Ref: InputObjectRef<
  TestPrefixPrefixedMessageSquashedMessageInput$Shape
> = builder.inputRef<TestPrefixPrefixedMessageSquashedMessageInput$Shape>(
  "TestPrefixPrefixedMessageSquashedMessageInput",
).implement(
  {
    fields: (t) => ({
      oneofField: t.field({
        type: TestPrefixPrefixedMessageInnerMessageInput$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "oneof_field",
            typeFullName: "testapis.extensions.PrefixedMessage.InnerMessage",
          },
        },
      }),
      oneofField2: t.field({
        type: TestPrefixPrefixedMessageInnerMessage2Input$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "oneof_field_2",
            typeFullName: "testapis.extensions.PrefixedMessage.InnerMessage2",
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.extensions.PrefixedMessage.SquashedMessage",
        name: "SquashedMessage",
        package: "testapis.extensions",
        options: { "[graphql.object_type]": { squashUnion: true } },
      },
    },
  },
);

export type TestPrefixIgnoredMessageNotIgnoredInput$Shape = {
  body: IgnoredMessage_NotIgnored["body"];
};

export const TestPrefixIgnoredMessageNotIgnoredInput$Ref: InputObjectRef<
  TestPrefixIgnoredMessageNotIgnoredInput$Shape
> = builder.inputRef<TestPrefixIgnoredMessageNotIgnoredInput$Shape>(
  "TestPrefixIgnoredMessageNotIgnoredInput",
).implement(
  {
    fields: (t) => ({
      body: t.field({
        type: "String",
        required: true,
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.extensions.IgnoredMessage.NotIgnored",
        name: "NotIgnored",
        package: "testapis.extensions",
      },
    },
  },
);

export const TestPrefixInterfaceMessage$Ref = builder.interfaceRef<
  Pick<
    InterfaceMessage,
    "id"
  >
>("TestPrefixInterfaceMessage");
builder.interfaceType(TestPrefixInterfaceMessage$Ref, {
  name: "TestPrefixInterfaceMessage",
  fields: (t) => ({
    id: t.expose("id", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.InterfaceMessage",
      name: "InterfaceMessage",
      package: "testapis.extensions",
      options: { "[graphql.object_type]": { interface: true } },
    },
  },
});

export const TestPrefixPrefixedMessageSquashedMessage$Ref = builder.unionType(
  "TestPrefixPrefixedMessageSquashedMessage",
  {
    types: [
      TestPrefixPrefixedMessageInnerMessage$Ref,
      TestPrefixPrefixedMessageInnerMessage2$Ref,
    ],
    extensions: {
      protobufOneof: {
        fullName: "testapis.extensions.PrefixedMessage.SquashedMessage",
        name: "SquashedMessage",
        package: "testapis.extensions",
        fields: [{
          name: "oneof_field",
          type: "testapis.extensions.PrefixedMessage.InnerMessage",
          options: { "[graphql.object_type]": { squashUnion: true } },
        }, {
          name: "oneof_field_2",
          type: "testapis.extensions.PrefixedMessage.InnerMessage2",
          options: { "[graphql.object_type]": { squashUnion: true } },
        }],
      },
    },
  },
);

export const TestPrefixPrefixedMessagePartialIgnoreOneof$Ref = builder
  .unionType("TestPrefixPrefixedMessagePartialIgnoreOneof", {
    types: [TestPrefixPrefixedMessageInnerMessage$Ref],
    extensions: {
      protobufOneof: {
        fullName: "testapis.extensions.PrefixedMessage.partial_ignore_oneof",
        name: "partial_ignore_oneof",
        messageName: "PrefixedMessage",
        package: "testapis.extensions",
        fields: [{
          name: "oneof_not_ignored_field",
          type: "testapis.extensions.PrefixedMessage.InnerMessage",
        }],
      },
    },
  });

export const TestPrefixPrefixedEnum$Ref: EnumRef<PrefixedEnum, PrefixedEnum> =
  builder.enumType("TestPrefixPrefixedEnum", {
    values: {
      PREFIXED_FOO: {
        value: 1,
        extensions: { protobufEnumValue: { name: "PREFIXED_FOO" } },
      },
      PREFIXED_BAR: {
        value: 2,
        extensions: { protobufEnumValue: { name: "PREFIXED_BAR" } },
      },
    } as const,
    extensions: {
      protobufEnum: {
        name: "PrefixedEnum",
        fullName: "testapis.extensions.PrefixedEnum",
        package: "testapis.extensions",
      },
    },
  });

export const TestPrefixRenamedEnum$Ref: EnumRef<
  EnumWillRename,
  EnumWillRename
> = builder.enumType("TestPrefixRenamedEnum", {
  values: {
    FOO: {
      value: 1,
      extensions: { protobufEnumValue: { name: "ENUM_WILL_RENAME_FOO" } },
    },
    BAR: {
      value: 2,
      extensions: { protobufEnumValue: { name: "ENUM_WILL_RENAME_BAR" } },
    },
  } as const,
  extensions: {
    protobufEnum: {
      name: "EnumWillRename",
      fullName: "testapis.extensions.EnumWillRename",
      package: "testapis.extensions",
      options: { "[graphql.enum_type]": { name: "RenamedEnum" } },
    },
  },
});

export const TestPrefixInterfaceMessageType$Ref: EnumRef<
  InterfaceMessage_Type,
  InterfaceMessage_Type
> = builder.enumType("TestPrefixInterfaceMessageType", {
  values: {
    INNER: { value: 1, extensions: { protobufEnumValue: { name: "INNER" } } },
    INNER2: { value: 2, extensions: { protobufEnumValue: { name: "INNER2" } } },
  } as const,
  extensions: {
    protobufEnum: {
      name: "Type",
      fullName: "testapis.extensions.InterfaceMessage.Type",
      package: "testapis.extensions",
    },
  },
});
",
    "name": "testapis/extensions/extensions.pb.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/extensions/ignored.proto

/* eslint-disable */

export {};
",
    "name": "testapis/extensions/ignored.pb.pothos.ts",
  },
]
`;

exports[`'testapis.extensions.field_nullability' > generates files by plugin 'with import prefix' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/extensions/field_nullability/nullability.proto

/* eslint-disable */

import { EnumRef, InputObjectRef } from "@pothos/core";
import {
  Message,
  Message_Status,
} from "@testapis/ts-proto/testapis/extensions/field_nullability/nullability";
import { builder } from "../../../builder";

export const Message$Ref = builder.objectRef<Message>("Message");
builder.objectType(Message$Ref, {
  name: "Message",
  fields: (t) => ({
    userId: t.expose("userId", {
      type: "String",
      nullable: false,
      description: "Required.",
      extensions: {
        protobufField: {
          name: "user_id",
          typeFullName: "uint64",
          options: {
            "[graphql.field]": {
              outputNullability: "NON_NULL",
              inputNullability: "NULLABLE",
              partialInputNullability: "NON_NULL",
            },
          },
        },
      },
    }),
    body: t.expose("body", {
      type: "String",
      nullable: false,
      description: "Required.",
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
    status: t.field({
      type: MessageStatus$Ref,
      nullable: true,
      description: "Required.",
      resolve: (source) => {
        if (source.status === Message_Status.STATUS_UNSPECIFIED) {
          return null;
        }

        return source.status;
      },
      extensions: {
        protobufField: {
          name: "status",
          typeFullName: "testapis.extensions.field_nullability.Message.Status",
          options: {
            "[graphql.field]": {
              outputNullability: "NULLABLE",
              inputNullability: "NULLABLE",
            },
          },
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as Message | { $type: string & {}; }).$type ===
      "testapis.extensions.field_nullability.Message";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.field_nullability.Message",
      name: "Message",
      package: "testapis.extensions.field_nullability",
    },
  },
});

export type MessageInput$Shape = {
  userId?: Message["userId"] | null;
  body: Message["body"];
  status?: Message["status"] | null;
};

export const MessageInput$Ref: InputObjectRef<MessageInput$Shape> = builder
  .inputRef<MessageInput$Shape>("MessageInput").implement(
    {
      fields: (t) => ({
        userId: t.field({
          type: "String",
          required: false,
          description: "Required.",
          extensions: {
            protobufField: {
              name: "user_id",
              typeFullName: "uint64",
              options: {
                "[graphql.field]": {
                  outputNullability: "NON_NULL",
                  inputNullability: "NULLABLE",
                  partialInputNullability: "NON_NULL",
                },
              },
            },
          },
        }),
        body: t.field({
          type: "String",
          required: true,
          description: "Required.",
          extensions: {
            protobufField: { name: "body", typeFullName: "string" },
          },
        }),
        status: t.field({
          type: MessageStatus$Ref,
          required: false,
          description: "Required.",
          extensions: {
            protobufField: {
              name: "status",
              typeFullName:
                "testapis.extensions.field_nullability.Message.Status",
              options: {
                "[graphql.field]": {
                  outputNullability: "NULLABLE",
                  inputNullability: "NULLABLE",
                },
              },
            },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.extensions.field_nullability.Message",
          name: "Message",
          package: "testapis.extensions.field_nullability",
        },
      },
    },
  );

export const MessageStatus$Ref: EnumRef<Message_Status, Message_Status> =
  builder.enumType("MessageStatus", {
    values: {
      DRAFT: { value: 1, extensions: { protobufEnumValue: { name: "DRAFT" } } },
      PUBLISHED: {
        value: 2,
        extensions: { protobufEnumValue: { name: "PUBLISHED" } },
      },
    } as const,
    extensions: {
      protobufEnum: {
        name: "Status",
        fullName: "testapis.extensions.field_nullability.Message.Status",
        package: "testapis.extensions.field_nullability",
      },
    },
  });
",
    "name": "testapis/extensions/field_nullability/nullability.pb.pothos.ts",
  },
]
`;

exports[`'testapis.extensions.field_nullability' > generates files by plugin 'with partial inputs' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/extensions/field_nullability/nullability.proto

/* eslint-disable */

import { EnumRef, InputObjectRef } from "@pothos/core";
import {
  Message,
  Message_Status,
} from "@testapis/ts-proto/testapis/extensions/field_nullability/nullability";
import { builder } from "../../../builder";

export const Message$Ref = builder.objectRef<Message>("Message");
builder.objectType(Message$Ref, {
  name: "Message",
  fields: (t) => ({
    userId: t.expose("userId", {
      type: "String",
      nullable: false,
      description: "Required.",
      extensions: {
        protobufField: {
          name: "user_id",
          typeFullName: "uint64",
          options: {
            "[graphql.field]": {
              outputNullability: "NON_NULL",
              inputNullability: "NULLABLE",
              partialInputNullability: "NON_NULL",
            },
          },
        },
      },
    }),
    body: t.expose("body", {
      type: "String",
      nullable: false,
      description: "Required.",
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
    status: t.field({
      type: MessageStatus$Ref,
      nullable: true,
      description: "Required.",
      resolve: (source) => {
        if (source.status === Message_Status.STATUS_UNSPECIFIED) {
          return null;
        }

        return source.status;
      },
      extensions: {
        protobufField: {
          name: "status",
          typeFullName: "testapis.extensions.field_nullability.Message.Status",
          options: {
            "[graphql.field]": {
              outputNullability: "NULLABLE",
              inputNullability: "NULLABLE",
            },
          },
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as Message | { $type: string & {}; }).$type ===
      "testapis.extensions.field_nullability.Message";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.field_nullability.Message",
      name: "Message",
      package: "testapis.extensions.field_nullability",
    },
  },
});

export type MessageInput$Shape = {
  userId?: Message["userId"] | null;
  body: Message["body"];
  status?: Message["status"] | null;
};

export const MessageInput$Ref: InputObjectRef<MessageInput$Shape> = builder
  .inputRef<MessageInput$Shape>("MessageInput").implement(
    {
      fields: (t) => ({
        userId: t.field({
          type: "String",
          required: false,
          description: "Required.",
          extensions: {
            protobufField: {
              name: "user_id",
              typeFullName: "uint64",
              options: {
                "[graphql.field]": {
                  outputNullability: "NON_NULL",
                  inputNullability: "NULLABLE",
                  partialInputNullability: "NON_NULL",
                },
              },
            },
          },
        }),
        body: t.field({
          type: "String",
          required: true,
          description: "Required.",
          extensions: {
            protobufField: { name: "body", typeFullName: "string" },
          },
        }),
        status: t.field({
          type: MessageStatus$Ref,
          required: false,
          description: "Required.",
          extensions: {
            protobufField: {
              name: "status",
              typeFullName:
                "testapis.extensions.field_nullability.Message.Status",
              options: {
                "[graphql.field]": {
                  outputNullability: "NULLABLE",
                  inputNullability: "NULLABLE",
                },
              },
            },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.extensions.field_nullability.Message",
          name: "Message",
          package: "testapis.extensions.field_nullability",
        },
      },
    },
  );

export type MessagePartialInput$Shape = {
  userId: Message["userId"];
  body?: Message["body"] | null;
  status?: Message["status"] | null;
};

export const MessagePartialInput$Ref: InputObjectRef<
  MessagePartialInput$Shape
> = builder.inputRef<MessagePartialInput$Shape>("MessagePartialInput")
  .implement(
    {
      fields: (t) => ({
        userId: t.field({
          type: "String",
          required: true,
          description: "Required.",
          extensions: {
            protobufField: {
              name: "user_id",
              typeFullName: "uint64",
              options: {
                "[graphql.field]": {
                  outputNullability: "NON_NULL",
                  inputNullability: "NULLABLE",
                  partialInputNullability: "NON_NULL",
                },
              },
            },
          },
        }),
        body: t.field({
          type: "String",
          required: false,
          description: "Required.",
          extensions: {
            protobufField: { name: "body", typeFullName: "string" },
          },
        }),
        status: t.field({
          type: MessageStatus$Ref,
          required: false,
          description: "Required.",
          extensions: {
            protobufField: {
              name: "status",
              typeFullName:
                "testapis.extensions.field_nullability.Message.Status",
              options: {
                "[graphql.field]": {
                  outputNullability: "NULLABLE",
                  inputNullability: "NULLABLE",
                },
              },
            },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.extensions.field_nullability.Message",
          name: "Message",
          package: "testapis.extensions.field_nullability",
        },
      },
    },
  );

export const MessageStatus$Ref: EnumRef<Message_Status, Message_Status> =
  builder.enumType("MessageStatus", {
    values: {
      DRAFT: { value: 1, extensions: { protobufEnumValue: { name: "DRAFT" } } },
      PUBLISHED: {
        value: 2,
        extensions: { protobufEnumValue: { name: "PUBLISHED" } },
      },
    } as const,
    extensions: {
      protobufEnum: {
        name: "Status",
        fullName: "testapis.extensions.field_nullability.Message.Status",
        package: "testapis.extensions.field_nullability",
      },
    },
  });
",
    "name": "testapis/extensions/field_nullability/nullability.pb.pothos.ts",
  },
]
`;

exports[`'testapis.extensions.field_nullability' > generates files by plugin 'without import prefix' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/extensions/field_nullability/nullability.proto

/* eslint-disable */

import { EnumRef, InputObjectRef } from "@pothos/core";
import { builder } from "../../../builder";
import {
  Message,
  Message_Status,
} from "./testapis/extensions/field_nullability/nullability";

export const Message$Ref = builder.objectRef<Message>("Message");
builder.objectType(Message$Ref, {
  name: "Message",
  fields: (t) => ({
    userId: t.expose("userId", {
      type: "String",
      nullable: false,
      description: "Required.",
      extensions: {
        protobufField: {
          name: "user_id",
          typeFullName: "uint64",
          options: {
            "[graphql.field]": {
              outputNullability: "NON_NULL",
              inputNullability: "NULLABLE",
              partialInputNullability: "NON_NULL",
            },
          },
        },
      },
    }),
    body: t.expose("body", {
      type: "String",
      nullable: false,
      description: "Required.",
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
    status: t.field({
      type: MessageStatus$Ref,
      nullable: true,
      description: "Required.",
      resolve: (source) => {
        if (source.status === Message_Status.STATUS_UNSPECIFIED) {
          return null;
        }

        return source.status;
      },
      extensions: {
        protobufField: {
          name: "status",
          typeFullName: "testapis.extensions.field_nullability.Message.Status",
          options: {
            "[graphql.field]": {
              outputNullability: "NULLABLE",
              inputNullability: "NULLABLE",
            },
          },
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as Message | { $type: string & {}; }).$type ===
      "testapis.extensions.field_nullability.Message";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.field_nullability.Message",
      name: "Message",
      package: "testapis.extensions.field_nullability",
    },
  },
});

export type MessageInput$Shape = {
  userId?: Message["userId"] | null;
  body: Message["body"];
  status?: Message["status"] | null;
};

export const MessageInput$Ref: InputObjectRef<MessageInput$Shape> = builder
  .inputRef<MessageInput$Shape>("MessageInput").implement(
    {
      fields: (t) => ({
        userId: t.field({
          type: "String",
          required: false,
          description: "Required.",
          extensions: {
            protobufField: {
              name: "user_id",
              typeFullName: "uint64",
              options: {
                "[graphql.field]": {
                  outputNullability: "NON_NULL",
                  inputNullability: "NULLABLE",
                  partialInputNullability: "NON_NULL",
                },
              },
            },
          },
        }),
        body: t.field({
          type: "String",
          required: true,
          description: "Required.",
          extensions: {
            protobufField: { name: "body", typeFullName: "string" },
          },
        }),
        status: t.field({
          type: MessageStatus$Ref,
          required: false,
          description: "Required.",
          extensions: {
            protobufField: {
              name: "status",
              typeFullName:
                "testapis.extensions.field_nullability.Message.Status",
              options: {
                "[graphql.field]": {
                  outputNullability: "NULLABLE",
                  inputNullability: "NULLABLE",
                },
              },
            },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.extensions.field_nullability.Message",
          name: "Message",
          package: "testapis.extensions.field_nullability",
        },
      },
    },
  );

export const MessageStatus$Ref: EnumRef<Message_Status, Message_Status> =
  builder.enumType("MessageStatus", {
    values: {
      DRAFT: { value: 1, extensions: { protobufEnumValue: { name: "DRAFT" } } },
      PUBLISHED: {
        value: 2,
        extensions: { protobufEnumValue: { name: "PUBLISHED" } },
      },
    } as const,
    extensions: {
      protobufEnum: {
        name: "Status",
        fullName: "testapis.extensions.field_nullability.Message.Status",
        package: "testapis.extensions.field_nullability",
      },
    },
  });
",
    "name": "testapis/extensions/field_nullability/nullability.pb.pothos.ts",
  },
]
`;

exports[`'testapis.extensions.no_partial' > generates files by plugin 'with import prefix' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/extensions/no_partial/no_partial.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import {
  NoPartialInputMessage,
  ParentMessage,
  PartialableInputMessage,
} from "@testapis/ts-proto/testapis/extensions/no_partial/no_partial";
import { builder } from "../../../builder";

export const ParentMessage$Ref = builder.objectRef<ParentMessage>(
  "ParentMessage",
);
builder.objectType(ParentMessage$Ref, {
  name: "ParentMessage",
  fields: (t) => ({
    partialableInputMessage: t.field({
      type: PartialableInputMessage$Ref,
      nullable: false,
      description: "Required.",
      resolve: (source) => {
        return source.partialableInputMessage!;
      },
      extensions: {
        protobufField: {
          name: "partialable_input_message",
          typeFullName:
            "testapis.extensions.no_partial.PartialableInputMessage",
        },
      },
    }),
    noPartialInputMessage: t.field({
      type: NoPartialInputMessage$Ref,
      nullable: false,
      description: "Required.",
      resolve: (source) => {
        return source.noPartialInputMessage!;
      },
      extensions: {
        protobufField: {
          name: "no_partial_input_message",
          typeFullName: "testapis.extensions.no_partial.NoPartialInputMessage",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as ParentMessage | { $type: string & {}; }).$type ===
      "testapis.extensions.no_partial.ParentMessage";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.no_partial.ParentMessage",
      name: "ParentMessage",
      package: "testapis.extensions.no_partial",
    },
  },
});

export const PartialableInputMessage$Ref = builder.objectRef<
  PartialableInputMessage
>("PartialableInputMessage");
builder.objectType(PartialableInputMessage$Ref, {
  name: "PartialableInputMessage",
  fields: (t) => ({
    id: t.expose("id", {
      type: "String",
      nullable: false,
      description: "Required.",
      extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
    }),
    body: t.expose("body", {
      type: "String",
      nullable: false,
      description: "Required.",
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as PartialableInputMessage | { $type: string & {}; })
      .$type ===
      "testapis.extensions.no_partial.PartialableInputMessage";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.no_partial.PartialableInputMessage",
      name: "PartialableInputMessage",
      package: "testapis.extensions.no_partial",
    },
  },
});

export const NoPartialInputMessage$Ref = builder.objectRef<
  NoPartialInputMessage
>("NoPartialInputMessage");
builder.objectType(NoPartialInputMessage$Ref, {
  name: "NoPartialInputMessage",
  fields: (t) => ({
    id: t.expose("id", {
      type: "String",
      nullable: false,
      description: "Required.",
      extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
    }),
    body: t.expose("body", {
      type: "String",
      nullable: false,
      description: "Required.",
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as NoPartialInputMessage | { $type: string & {}; }).$type ===
      "testapis.extensions.no_partial.NoPartialInputMessage";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.no_partial.NoPartialInputMessage",
      name: "NoPartialInputMessage",
      package: "testapis.extensions.no_partial",
      options: { "[graphql.input_type]": { noPartial: true } },
    },
  },
});

export type ParentMessageInput$Shape = {
  partialableInputMessage: PartialableInputMessageInput$Shape;
  noPartialInputMessage: NoPartialInputMessageInput$Shape;
};

export const ParentMessageInput$Ref: InputObjectRef<ParentMessageInput$Shape> =
  builder.inputRef<ParentMessageInput$Shape>("ParentMessageInput").implement(
    {
      fields: (t) => ({
        partialableInputMessage: t.field({
          type: PartialableInputMessageInput$Ref,
          required: true,
          description: "Required.",
          extensions: {
            protobufField: {
              name: "partialable_input_message",
              typeFullName:
                "testapis.extensions.no_partial.PartialableInputMessage",
            },
          },
        }),
        noPartialInputMessage: t.field({
          type: NoPartialInputMessageInput$Ref,
          required: true,
          description: "Required.",
          extensions: {
            protobufField: {
              name: "no_partial_input_message",
              typeFullName:
                "testapis.extensions.no_partial.NoPartialInputMessage",
            },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.extensions.no_partial.ParentMessage",
          name: "ParentMessage",
          package: "testapis.extensions.no_partial",
        },
      },
    },
  );

export type PartialableInputMessageInput$Shape = {
  id: PartialableInputMessage["id"];
  body: PartialableInputMessage["body"];
};

export const PartialableInputMessageInput$Ref: InputObjectRef<
  PartialableInputMessageInput$Shape
> = builder.inputRef<PartialableInputMessageInput$Shape>(
  "PartialableInputMessageInput",
).implement(
  {
    fields: (t) => ({
      id: t.field({
        type: "String",
        required: true,
        description: "Required.",
        extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
      }),
      body: t.field({
        type: "String",
        required: true,
        description: "Required.",
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.extensions.no_partial.PartialableInputMessage",
        name: "PartialableInputMessage",
        package: "testapis.extensions.no_partial",
      },
    },
  },
);

export type NoPartialInputMessageInput$Shape = {
  id: NoPartialInputMessage["id"];
  body: NoPartialInputMessage["body"];
};

export const NoPartialInputMessageInput$Ref: InputObjectRef<
  NoPartialInputMessageInput$Shape
> = builder.inputRef<NoPartialInputMessageInput$Shape>(
  "NoPartialInputMessageInput",
).implement(
  {
    fields: (t) => ({
      id: t.field({
        type: "String",
        required: true,
        description: "Required.",
        extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
      }),
      body: t.field({
        type: "String",
        required: true,
        description: "Required.",
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.extensions.no_partial.NoPartialInputMessage",
        name: "NoPartialInputMessage",
        package: "testapis.extensions.no_partial",
        options: { "[graphql.input_type]": { noPartial: true } },
      },
    },
  },
);
",
    "name": "testapis/extensions/no_partial/no_partial.pb.pothos.ts",
  },
]
`;

exports[`'testapis.extensions.no_partial' > generates files by plugin 'with partial inputs' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/extensions/no_partial/no_partial.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import {
  NoPartialInputMessage,
  ParentMessage,
  PartialableInputMessage,
} from "@testapis/ts-proto/testapis/extensions/no_partial/no_partial";
import { builder } from "../../../builder";

export const ParentMessage$Ref = builder.objectRef<ParentMessage>(
  "ParentMessage",
);
builder.objectType(ParentMessage$Ref, {
  name: "ParentMessage",
  fields: (t) => ({
    partialableInputMessage: t.field({
      type: PartialableInputMessage$Ref,
      nullable: false,
      description: "Required.",
      resolve: (source) => {
        return source.partialableInputMessage!;
      },
      extensions: {
        protobufField: {
          name: "partialable_input_message",
          typeFullName:
            "testapis.extensions.no_partial.PartialableInputMessage",
        },
      },
    }),
    noPartialInputMessage: t.field({
      type: NoPartialInputMessage$Ref,
      nullable: false,
      description: "Required.",
      resolve: (source) => {
        return source.noPartialInputMessage!;
      },
      extensions: {
        protobufField: {
          name: "no_partial_input_message",
          typeFullName: "testapis.extensions.no_partial.NoPartialInputMessage",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as ParentMessage | { $type: string & {}; }).$type ===
      "testapis.extensions.no_partial.ParentMessage";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.no_partial.ParentMessage",
      name: "ParentMessage",
      package: "testapis.extensions.no_partial",
    },
  },
});

export const PartialableInputMessage$Ref = builder.objectRef<
  PartialableInputMessage
>("PartialableInputMessage");
builder.objectType(PartialableInputMessage$Ref, {
  name: "PartialableInputMessage",
  fields: (t) => ({
    id: t.expose("id", {
      type: "String",
      nullable: false,
      description: "Required.",
      extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
    }),
    body: t.expose("body", {
      type: "String",
      nullable: false,
      description: "Required.",
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as PartialableInputMessage | { $type: string & {}; })
      .$type ===
      "testapis.extensions.no_partial.PartialableInputMessage";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.no_partial.PartialableInputMessage",
      name: "PartialableInputMessage",
      package: "testapis.extensions.no_partial",
    },
  },
});

export const NoPartialInputMessage$Ref = builder.objectRef<
  NoPartialInputMessage
>("NoPartialInputMessage");
builder.objectType(NoPartialInputMessage$Ref, {
  name: "NoPartialInputMessage",
  fields: (t) => ({
    id: t.expose("id", {
      type: "String",
      nullable: false,
      description: "Required.",
      extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
    }),
    body: t.expose("body", {
      type: "String",
      nullable: false,
      description: "Required.",
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as NoPartialInputMessage | { $type: string & {}; }).$type ===
      "testapis.extensions.no_partial.NoPartialInputMessage";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.no_partial.NoPartialInputMessage",
      name: "NoPartialInputMessage",
      package: "testapis.extensions.no_partial",
      options: { "[graphql.input_type]": { noPartial: true } },
    },
  },
});

export type ParentMessageInput$Shape = {
  partialableInputMessage: PartialableInputMessageInput$Shape;
  noPartialInputMessage: NoPartialInputMessageInput$Shape;
};

export const ParentMessageInput$Ref: InputObjectRef<ParentMessageInput$Shape> =
  builder.inputRef<ParentMessageInput$Shape>("ParentMessageInput").implement(
    {
      fields: (t) => ({
        partialableInputMessage: t.field({
          type: PartialableInputMessageInput$Ref,
          required: true,
          description: "Required.",
          extensions: {
            protobufField: {
              name: "partialable_input_message",
              typeFullName:
                "testapis.extensions.no_partial.PartialableInputMessage",
            },
          },
        }),
        noPartialInputMessage: t.field({
          type: NoPartialInputMessageInput$Ref,
          required: true,
          description: "Required.",
          extensions: {
            protobufField: {
              name: "no_partial_input_message",
              typeFullName:
                "testapis.extensions.no_partial.NoPartialInputMessage",
            },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.extensions.no_partial.ParentMessage",
          name: "ParentMessage",
          package: "testapis.extensions.no_partial",
        },
      },
    },
  );

export type ParentMessagePartialInput$Shape = {
  partialableInputMessage?: PartialableInputMessagePartialInput$Shape | null;
  noPartialInputMessage?: NoPartialInputMessageInput$Shape | null;
};

export const ParentMessagePartialInput$Ref: InputObjectRef<
  ParentMessagePartialInput$Shape
> = builder.inputRef<ParentMessagePartialInput$Shape>(
  "ParentMessagePartialInput",
).implement(
  {
    fields: (t) => ({
      partialableInputMessage: t.field({
        type: PartialableInputMessagePartialInput$Ref,
        required: false,
        description: "Required.",
        extensions: {
          protobufField: {
            name: "partialable_input_message",
            typeFullName:
              "testapis.extensions.no_partial.PartialableInputMessage",
          },
        },
      }),
      noPartialInputMessage: t.field({
        type: NoPartialInputMessageInput$Ref,
        required: false,
        description: "Required.",
        extensions: {
          protobufField: {
            name: "no_partial_input_message",
            typeFullName:
              "testapis.extensions.no_partial.NoPartialInputMessage",
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.extensions.no_partial.ParentMessage",
        name: "ParentMessage",
        package: "testapis.extensions.no_partial",
      },
    },
  },
);

export type PartialableInputMessageInput$Shape = {
  id: PartialableInputMessage["id"];
  body: PartialableInputMessage["body"];
};

export const PartialableInputMessageInput$Ref: InputObjectRef<
  PartialableInputMessageInput$Shape
> = builder.inputRef<PartialableInputMessageInput$Shape>(
  "PartialableInputMessageInput",
).implement(
  {
    fields: (t) => ({
      id: t.field({
        type: "String",
        required: true,
        description: "Required.",
        extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
      }),
      body: t.field({
        type: "String",
        required: true,
        description: "Required.",
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.extensions.no_partial.PartialableInputMessage",
        name: "PartialableInputMessage",
        package: "testapis.extensions.no_partial",
      },
    },
  },
);

export type PartialableInputMessagePartialInput$Shape = {
  id?: PartialableInputMessage["id"] | null;
  body?: PartialableInputMessage["body"] | null;
};

export const PartialableInputMessagePartialInput$Ref: InputObjectRef<
  PartialableInputMessagePartialInput$Shape
> = builder.inputRef<PartialableInputMessagePartialInput$Shape>(
  "PartialableInputMessagePartialInput",
).implement(
  {
    fields: (t) => ({
      id: t.field({
        type: "String",
        required: false,
        description: "Required.",
        extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
      }),
      body: t.field({
        type: "String",
        required: false,
        description: "Required.",
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.extensions.no_partial.PartialableInputMessage",
        name: "PartialableInputMessage",
        package: "testapis.extensions.no_partial",
      },
    },
  },
);

export type NoPartialInputMessageInput$Shape = {
  id: NoPartialInputMessage["id"];
  body: NoPartialInputMessage["body"];
};

export const NoPartialInputMessageInput$Ref: InputObjectRef<
  NoPartialInputMessageInput$Shape
> = builder.inputRef<NoPartialInputMessageInput$Shape>(
  "NoPartialInputMessageInput",
).implement(
  {
    fields: (t) => ({
      id: t.field({
        type: "String",
        required: true,
        description: "Required.",
        extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
      }),
      body: t.field({
        type: "String",
        required: true,
        description: "Required.",
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.extensions.no_partial.NoPartialInputMessage",
        name: "NoPartialInputMessage",
        package: "testapis.extensions.no_partial",
        options: { "[graphql.input_type]": { noPartial: true } },
      },
    },
  },
);
",
    "name": "testapis/extensions/no_partial/no_partial.pb.pothos.ts",
  },
]
`;

exports[`'testapis.extensions.no_partial' > generates files by plugin 'without import prefix' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/extensions/no_partial/no_partial.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { builder } from "../../../builder";
import {
  NoPartialInputMessage,
  ParentMessage,
  PartialableInputMessage,
} from "./testapis/extensions/no_partial/no_partial";

export const ParentMessage$Ref = builder.objectRef<ParentMessage>(
  "ParentMessage",
);
builder.objectType(ParentMessage$Ref, {
  name: "ParentMessage",
  fields: (t) => ({
    partialableInputMessage: t.field({
      type: PartialableInputMessage$Ref,
      nullable: false,
      description: "Required.",
      resolve: (source) => {
        return source.partialableInputMessage!;
      },
      extensions: {
        protobufField: {
          name: "partialable_input_message",
          typeFullName:
            "testapis.extensions.no_partial.PartialableInputMessage",
        },
      },
    }),
    noPartialInputMessage: t.field({
      type: NoPartialInputMessage$Ref,
      nullable: false,
      description: "Required.",
      resolve: (source) => {
        return source.noPartialInputMessage!;
      },
      extensions: {
        protobufField: {
          name: "no_partial_input_message",
          typeFullName: "testapis.extensions.no_partial.NoPartialInputMessage",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as ParentMessage | { $type: string & {}; }).$type ===
      "testapis.extensions.no_partial.ParentMessage";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.no_partial.ParentMessage",
      name: "ParentMessage",
      package: "testapis.extensions.no_partial",
    },
  },
});

export const PartialableInputMessage$Ref = builder.objectRef<
  PartialableInputMessage
>("PartialableInputMessage");
builder.objectType(PartialableInputMessage$Ref, {
  name: "PartialableInputMessage",
  fields: (t) => ({
    id: t.expose("id", {
      type: "String",
      nullable: false,
      description: "Required.",
      extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
    }),
    body: t.expose("body", {
      type: "String",
      nullable: false,
      description: "Required.",
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as PartialableInputMessage | { $type: string & {}; })
      .$type ===
      "testapis.extensions.no_partial.PartialableInputMessage";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.no_partial.PartialableInputMessage",
      name: "PartialableInputMessage",
      package: "testapis.extensions.no_partial",
    },
  },
});

export const NoPartialInputMessage$Ref = builder.objectRef<
  NoPartialInputMessage
>("NoPartialInputMessage");
builder.objectType(NoPartialInputMessage$Ref, {
  name: "NoPartialInputMessage",
  fields: (t) => ({
    id: t.expose("id", {
      type: "String",
      nullable: false,
      description: "Required.",
      extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
    }),
    body: t.expose("body", {
      type: "String",
      nullable: false,
      description: "Required.",
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as NoPartialInputMessage | { $type: string & {}; }).$type ===
      "testapis.extensions.no_partial.NoPartialInputMessage";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.no_partial.NoPartialInputMessage",
      name: "NoPartialInputMessage",
      package: "testapis.extensions.no_partial",
      options: { "[graphql.input_type]": { noPartial: true } },
    },
  },
});

export type ParentMessageInput$Shape = {
  partialableInputMessage: PartialableInputMessageInput$Shape;
  noPartialInputMessage: NoPartialInputMessageInput$Shape;
};

export const ParentMessageInput$Ref: InputObjectRef<ParentMessageInput$Shape> =
  builder.inputRef<ParentMessageInput$Shape>("ParentMessageInput").implement(
    {
      fields: (t) => ({
        partialableInputMessage: t.field({
          type: PartialableInputMessageInput$Ref,
          required: true,
          description: "Required.",
          extensions: {
            protobufField: {
              name: "partialable_input_message",
              typeFullName:
                "testapis.extensions.no_partial.PartialableInputMessage",
            },
          },
        }),
        noPartialInputMessage: t.field({
          type: NoPartialInputMessageInput$Ref,
          required: true,
          description: "Required.",
          extensions: {
            protobufField: {
              name: "no_partial_input_message",
              typeFullName:
                "testapis.extensions.no_partial.NoPartialInputMessage",
            },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.extensions.no_partial.ParentMessage",
          name: "ParentMessage",
          package: "testapis.extensions.no_partial",
        },
      },
    },
  );

export type PartialableInputMessageInput$Shape = {
  id: PartialableInputMessage["id"];
  body: PartialableInputMessage["body"];
};

export const PartialableInputMessageInput$Ref: InputObjectRef<
  PartialableInputMessageInput$Shape
> = builder.inputRef<PartialableInputMessageInput$Shape>(
  "PartialableInputMessageInput",
).implement(
  {
    fields: (t) => ({
      id: t.field({
        type: "String",
        required: true,
        description: "Required.",
        extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
      }),
      body: t.field({
        type: "String",
        required: true,
        description: "Required.",
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.extensions.no_partial.PartialableInputMessage",
        name: "PartialableInputMessage",
        package: "testapis.extensions.no_partial",
      },
    },
  },
);

export type NoPartialInputMessageInput$Shape = {
  id: NoPartialInputMessage["id"];
  body: NoPartialInputMessage["body"];
};

export const NoPartialInputMessageInput$Ref: InputObjectRef<
  NoPartialInputMessageInput$Shape
> = builder.inputRef<NoPartialInputMessageInput$Shape>(
  "NoPartialInputMessageInput",
).implement(
  {
    fields: (t) => ({
      id: t.field({
        type: "String",
        required: true,
        description: "Required.",
        extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
      }),
      body: t.field({
        type: "String",
        required: true,
        description: "Required.",
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.extensions.no_partial.NoPartialInputMessage",
        name: "NoPartialInputMessage",
        package: "testapis.extensions.no_partial",
        options: { "[graphql.input_type]": { noPartial: true } },
      },
    },
  },
);
",
    "name": "testapis/extensions/no_partial/no_partial.pb.pothos.ts",
  },
]
`;

exports[`'testapis.field_behavior' > generates files by plugin 'with import prefix' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/field_behavior/comments.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import {
  FieldBehaviorComentsMessage,
  FieldBehaviorComentsMessage_Post,
} from "@testapis/ts-proto/testapis/field_behavior/comments";
import { builder } from "../../builder";

export const FieldBehaviorComentsMessage$Ref = builder.objectRef<
  FieldBehaviorComentsMessage
>("FieldBehaviorComentsMessage");
builder.objectType(FieldBehaviorComentsMessage$Ref, {
  name: "FieldBehaviorComentsMessage",
  fields: (t) => ({
    requiredField: t.field({
      type: FieldBehaviorComentsMessagePost$Ref,
      nullable: false,
      description: "Required.",
      resolve: (source) => {
        return source.requiredField!;
      },
      extensions: {
        protobufField: {
          name: "required_field",
          typeFullName:
            "testapis.field_behavior.FieldBehaviorComentsMessage.Post",
        },
      },
    }),
    requiredOutputOnlyField: t.field({
      type: FieldBehaviorComentsMessagePost$Ref,
      nullable: false,
      description: "Required. Output only.",
      resolve: (source) => {
        return source.requiredOutputOnlyField!;
      },
      extensions: {
        protobufField: {
          name: "required_output_only_field",
          typeFullName:
            "testapis.field_behavior.FieldBehaviorComentsMessage.Post",
        },
      },
    }),
    outputOnlyRequiredField: t.field({
      type: FieldBehaviorComentsMessagePost$Ref,
      nullable: false,
      description: "Output only. Required.",
      resolve: (source) => {
        return source.outputOnlyRequiredField!;
      },
      extensions: {
        protobufField: {
          name: "output_only_required_field",
          typeFullName:
            "testapis.field_behavior.FieldBehaviorComentsMessage.Post",
        },
      },
    }),
    outputOnlyField: t.expose("outputOnlyField", {
      type: FieldBehaviorComentsMessagePost$Ref,
      nullable: true,
      description: "Output only.",
      extensions: {
        protobufField: {
          name: "output_only_field",
          typeFullName:
            "testapis.field_behavior.FieldBehaviorComentsMessage.Post",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as FieldBehaviorComentsMessage | { $type: string & {}; })
      .$type ===
      "testapis.field_behavior.FieldBehaviorComentsMessage";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.field_behavior.FieldBehaviorComentsMessage",
      name: "FieldBehaviorComentsMessage",
      package: "testapis.field_behavior",
    },
  },
});

export const FieldBehaviorComentsMessagePost$Ref = builder.objectRef<
  FieldBehaviorComentsMessage_Post
>("FieldBehaviorComentsMessagePost");
builder.objectType(FieldBehaviorComentsMessagePost$Ref, {
  name: "FieldBehaviorComentsMessagePost",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as FieldBehaviorComentsMessage_Post | {
      $type: string & {};
    }).$type ===
      "testapis.field_behavior.FieldBehaviorComentsMessage.Post";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.field_behavior.FieldBehaviorComentsMessage.Post",
      name: "Post",
      package: "testapis.field_behavior",
    },
  },
});

export type FieldBehaviorComentsMessageInput$Shape = {
  requiredField: FieldBehaviorComentsMessagePostInput$Shape;
  requiredInputOnlyField: FieldBehaviorComentsMessagePostInput$Shape;
  inputOnlyRequiredField: FieldBehaviorComentsMessagePostInput$Shape;
  inputOnlyField?: FieldBehaviorComentsMessagePostInput$Shape | null;
};

export const FieldBehaviorComentsMessageInput$Ref: InputObjectRef<
  FieldBehaviorComentsMessageInput$Shape
> = builder.inputRef<FieldBehaviorComentsMessageInput$Shape>(
  "FieldBehaviorComentsMessageInput",
).implement(
  {
    fields: (t) => ({
      requiredField: t.field({
        type: FieldBehaviorComentsMessagePostInput$Ref,
        required: true,
        description: "Required.",
        extensions: {
          protobufField: {
            name: "required_field",
            typeFullName:
              "testapis.field_behavior.FieldBehaviorComentsMessage.Post",
          },
        },
      }),
      requiredInputOnlyField: t.field({
        type: FieldBehaviorComentsMessagePostInput$Ref,
        required: true,
        description: "Required. Input only.",
        extensions: {
          protobufField: {
            name: "required_input_only_field",
            typeFullName:
              "testapis.field_behavior.FieldBehaviorComentsMessage.Post",
          },
        },
      }),
      inputOnlyRequiredField: t.field({
        type: FieldBehaviorComentsMessagePostInput$Ref,
        required: true,
        description: "Input only. Required.",
        extensions: {
          protobufField: {
            name: "input_only_required_field",
            typeFullName:
              "testapis.field_behavior.FieldBehaviorComentsMessage.Post",
          },
        },
      }),
      inputOnlyField: t.field({
        type: FieldBehaviorComentsMessagePostInput$Ref,
        required: false,
        description: "Input only.",
        extensions: {
          protobufField: {
            name: "input_only_field",
            typeFullName:
              "testapis.field_behavior.FieldBehaviorComentsMessage.Post",
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.field_behavior.FieldBehaviorComentsMessage",
        name: "FieldBehaviorComentsMessage",
        package: "testapis.field_behavior",
      },
    },
  },
);

export type FieldBehaviorComentsMessagePostInput$Shape = {
  body: FieldBehaviorComentsMessage_Post["body"];
};

export const FieldBehaviorComentsMessagePostInput$Ref: InputObjectRef<
  FieldBehaviorComentsMessagePostInput$Shape
> = builder.inputRef<FieldBehaviorComentsMessagePostInput$Shape>(
  "FieldBehaviorComentsMessagePostInput",
).implement(
  {
    fields: (t) => ({
      body: t.field({
        type: "String",
        required: true,
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.field_behavior.FieldBehaviorComentsMessage.Post",
        name: "Post",
        package: "testapis.field_behavior",
      },
    },
  },
);
",
    "name": "testapis/field_behavior/comments.pb.pothos.ts",
  },
]
`;

exports[`'testapis.field_behavior' > generates files by plugin 'with partial inputs' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/field_behavior/comments.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import {
  FieldBehaviorComentsMessage,
  FieldBehaviorComentsMessage_Post,
} from "@testapis/ts-proto/testapis/field_behavior/comments";
import { builder } from "../../builder";

export const FieldBehaviorComentsMessage$Ref = builder.objectRef<
  FieldBehaviorComentsMessage
>("FieldBehaviorComentsMessage");
builder.objectType(FieldBehaviorComentsMessage$Ref, {
  name: "FieldBehaviorComentsMessage",
  fields: (t) => ({
    requiredField: t.field({
      type: FieldBehaviorComentsMessagePost$Ref,
      nullable: false,
      description: "Required.",
      resolve: (source) => {
        return source.requiredField!;
      },
      extensions: {
        protobufField: {
          name: "required_field",
          typeFullName:
            "testapis.field_behavior.FieldBehaviorComentsMessage.Post",
        },
      },
    }),
    requiredOutputOnlyField: t.field({
      type: FieldBehaviorComentsMessagePost$Ref,
      nullable: false,
      description: "Required. Output only.",
      resolve: (source) => {
        return source.requiredOutputOnlyField!;
      },
      extensions: {
        protobufField: {
          name: "required_output_only_field",
          typeFullName:
            "testapis.field_behavior.FieldBehaviorComentsMessage.Post",
        },
      },
    }),
    outputOnlyRequiredField: t.field({
      type: FieldBehaviorComentsMessagePost$Ref,
      nullable: false,
      description: "Output only. Required.",
      resolve: (source) => {
        return source.outputOnlyRequiredField!;
      },
      extensions: {
        protobufField: {
          name: "output_only_required_field",
          typeFullName:
            "testapis.field_behavior.FieldBehaviorComentsMessage.Post",
        },
      },
    }),
    outputOnlyField: t.expose("outputOnlyField", {
      type: FieldBehaviorComentsMessagePost$Ref,
      nullable: true,
      description: "Output only.",
      extensions: {
        protobufField: {
          name: "output_only_field",
          typeFullName:
            "testapis.field_behavior.FieldBehaviorComentsMessage.Post",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as FieldBehaviorComentsMessage | { $type: string & {}; })
      .$type ===
      "testapis.field_behavior.FieldBehaviorComentsMessage";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.field_behavior.FieldBehaviorComentsMessage",
      name: "FieldBehaviorComentsMessage",
      package: "testapis.field_behavior",
    },
  },
});

export const FieldBehaviorComentsMessagePost$Ref = builder.objectRef<
  FieldBehaviorComentsMessage_Post
>("FieldBehaviorComentsMessagePost");
builder.objectType(FieldBehaviorComentsMessagePost$Ref, {
  name: "FieldBehaviorComentsMessagePost",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as FieldBehaviorComentsMessage_Post | {
      $type: string & {};
    }).$type ===
      "testapis.field_behavior.FieldBehaviorComentsMessage.Post";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.field_behavior.FieldBehaviorComentsMessage.Post",
      name: "Post",
      package: "testapis.field_behavior",
    },
  },
});

export type FieldBehaviorComentsMessageInput$Shape = {
  requiredField: FieldBehaviorComentsMessagePostInput$Shape;
  requiredInputOnlyField: FieldBehaviorComentsMessagePostInput$Shape;
  inputOnlyRequiredField: FieldBehaviorComentsMessagePostInput$Shape;
  inputOnlyField?: FieldBehaviorComentsMessagePostInput$Shape | null;
};

export const FieldBehaviorComentsMessageInput$Ref: InputObjectRef<
  FieldBehaviorComentsMessageInput$Shape
> = builder.inputRef<FieldBehaviorComentsMessageInput$Shape>(
  "FieldBehaviorComentsMessageInput",
).implement(
  {
    fields: (t) => ({
      requiredField: t.field({
        type: FieldBehaviorComentsMessagePostInput$Ref,
        required: true,
        description: "Required.",
        extensions: {
          protobufField: {
            name: "required_field",
            typeFullName:
              "testapis.field_behavior.FieldBehaviorComentsMessage.Post",
          },
        },
      }),
      requiredInputOnlyField: t.field({
        type: FieldBehaviorComentsMessagePostInput$Ref,
        required: true,
        description: "Required. Input only.",
        extensions: {
          protobufField: {
            name: "required_input_only_field",
            typeFullName:
              "testapis.field_behavior.FieldBehaviorComentsMessage.Post",
          },
        },
      }),
      inputOnlyRequiredField: t.field({
        type: FieldBehaviorComentsMessagePostInput$Ref,
        required: true,
        description: "Input only. Required.",
        extensions: {
          protobufField: {
            name: "input_only_required_field",
            typeFullName:
              "testapis.field_behavior.FieldBehaviorComentsMessage.Post",
          },
        },
      }),
      inputOnlyField: t.field({
        type: FieldBehaviorComentsMessagePostInput$Ref,
        required: false,
        description: "Input only.",
        extensions: {
          protobufField: {
            name: "input_only_field",
            typeFullName:
              "testapis.field_behavior.FieldBehaviorComentsMessage.Post",
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.field_behavior.FieldBehaviorComentsMessage",
        name: "FieldBehaviorComentsMessage",
        package: "testapis.field_behavior",
      },
    },
  },
);

export type FieldBehaviorComentsMessagePartialInput$Shape = {
  requiredField?: FieldBehaviorComentsMessagePostPartialInput$Shape | null;
  requiredInputOnlyField?:
    | FieldBehaviorComentsMessagePostPartialInput$Shape
    | null;
  inputOnlyRequiredField?:
    | FieldBehaviorComentsMessagePostPartialInput$Shape
    | null;
  inputOnlyField?: FieldBehaviorComentsMessagePostPartialInput$Shape | null;
};

export const FieldBehaviorComentsMessagePartialInput$Ref: InputObjectRef<
  FieldBehaviorComentsMessagePartialInput$Shape
> = builder.inputRef<FieldBehaviorComentsMessagePartialInput$Shape>(
  "FieldBehaviorComentsMessagePartialInput",
).implement(
  {
    fields: (t) => ({
      requiredField: t.field({
        type: FieldBehaviorComentsMessagePostPartialInput$Ref,
        required: false,
        description: "Required.",
        extensions: {
          protobufField: {
            name: "required_field",
            typeFullName:
              "testapis.field_behavior.FieldBehaviorComentsMessage.Post",
          },
        },
      }),
      requiredInputOnlyField: t.field({
        type: FieldBehaviorComentsMessagePostPartialInput$Ref,
        required: false,
        description: "Required. Input only.",
        extensions: {
          protobufField: {
            name: "required_input_only_field",
            typeFullName:
              "testapis.field_behavior.FieldBehaviorComentsMessage.Post",
          },
        },
      }),
      inputOnlyRequiredField: t.field({
        type: FieldBehaviorComentsMessagePostPartialInput$Ref,
        required: false,
        description: "Input only. Required.",
        extensions: {
          protobufField: {
            name: "input_only_required_field",
            typeFullName:
              "testapis.field_behavior.FieldBehaviorComentsMessage.Post",
          },
        },
      }),
      inputOnlyField: t.field({
        type: FieldBehaviorComentsMessagePostPartialInput$Ref,
        required: false,
        description: "Input only.",
        extensions: {
          protobufField: {
            name: "input_only_field",
            typeFullName:
              "testapis.field_behavior.FieldBehaviorComentsMessage.Post",
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.field_behavior.FieldBehaviorComentsMessage",
        name: "FieldBehaviorComentsMessage",
        package: "testapis.field_behavior",
      },
    },
  },
);

export type FieldBehaviorComentsMessagePostInput$Shape = {
  body: FieldBehaviorComentsMessage_Post["body"];
};

export const FieldBehaviorComentsMessagePostInput$Ref: InputObjectRef<
  FieldBehaviorComentsMessagePostInput$Shape
> = builder.inputRef<FieldBehaviorComentsMessagePostInput$Shape>(
  "FieldBehaviorComentsMessagePostInput",
).implement(
  {
    fields: (t) => ({
      body: t.field({
        type: "String",
        required: true,
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.field_behavior.FieldBehaviorComentsMessage.Post",
        name: "Post",
        package: "testapis.field_behavior",
      },
    },
  },
);

export type FieldBehaviorComentsMessagePostPartialInput$Shape = {
  body?: FieldBehaviorComentsMessage_Post["body"] | null;
};

export const FieldBehaviorComentsMessagePostPartialInput$Ref: InputObjectRef<
  FieldBehaviorComentsMessagePostPartialInput$Shape
> = builder.inputRef<FieldBehaviorComentsMessagePostPartialInput$Shape>(
  "FieldBehaviorComentsMessagePostPartialInput",
).implement(
  {
    fields: (t) => ({
      body: t.field({
        type: "String",
        required: false,
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.field_behavior.FieldBehaviorComentsMessage.Post",
        name: "Post",
        package: "testapis.field_behavior",
      },
    },
  },
);
",
    "name": "testapis/field_behavior/comments.pb.pothos.ts",
  },
]
`;

exports[`'testapis.field_behavior' > generates files by plugin 'without import prefix' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/field_behavior/comments.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { builder } from "../../builder";
import {
  FieldBehaviorComentsMessage,
  FieldBehaviorComentsMessage_Post,
} from "./testapis/field_behavior/comments";

export const FieldBehaviorComentsMessage$Ref = builder.objectRef<
  FieldBehaviorComentsMessage
>("FieldBehaviorComentsMessage");
builder.objectType(FieldBehaviorComentsMessage$Ref, {
  name: "FieldBehaviorComentsMessage",
  fields: (t) => ({
    requiredField: t.field({
      type: FieldBehaviorComentsMessagePost$Ref,
      nullable: false,
      description: "Required.",
      resolve: (source) => {
        return source.requiredField!;
      },
      extensions: {
        protobufField: {
          name: "required_field",
          typeFullName:
            "testapis.field_behavior.FieldBehaviorComentsMessage.Post",
        },
      },
    }),
    requiredOutputOnlyField: t.field({
      type: FieldBehaviorComentsMessagePost$Ref,
      nullable: false,
      description: "Required. Output only.",
      resolve: (source) => {
        return source.requiredOutputOnlyField!;
      },
      extensions: {
        protobufField: {
          name: "required_output_only_field",
          typeFullName:
            "testapis.field_behavior.FieldBehaviorComentsMessage.Post",
        },
      },
    }),
    outputOnlyRequiredField: t.field({
      type: FieldBehaviorComentsMessagePost$Ref,
      nullable: false,
      description: "Output only. Required.",
      resolve: (source) => {
        return source.outputOnlyRequiredField!;
      },
      extensions: {
        protobufField: {
          name: "output_only_required_field",
          typeFullName:
            "testapis.field_behavior.FieldBehaviorComentsMessage.Post",
        },
      },
    }),
    outputOnlyField: t.expose("outputOnlyField", {
      type: FieldBehaviorComentsMessagePost$Ref,
      nullable: true,
      description: "Output only.",
      extensions: {
        protobufField: {
          name: "output_only_field",
          typeFullName:
            "testapis.field_behavior.FieldBehaviorComentsMessage.Post",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as FieldBehaviorComentsMessage | { $type: string & {}; })
      .$type ===
      "testapis.field_behavior.FieldBehaviorComentsMessage";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.field_behavior.FieldBehaviorComentsMessage",
      name: "FieldBehaviorComentsMessage",
      package: "testapis.field_behavior",
    },
  },
});

export const FieldBehaviorComentsMessagePost$Ref = builder.objectRef<
  FieldBehaviorComentsMessage_Post
>("FieldBehaviorComentsMessagePost");
builder.objectType(FieldBehaviorComentsMessagePost$Ref, {
  name: "FieldBehaviorComentsMessagePost",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as FieldBehaviorComentsMessage_Post | {
      $type: string & {};
    }).$type ===
      "testapis.field_behavior.FieldBehaviorComentsMessage.Post";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.field_behavior.FieldBehaviorComentsMessage.Post",
      name: "Post",
      package: "testapis.field_behavior",
    },
  },
});

export type FieldBehaviorComentsMessageInput$Shape = {
  requiredField: FieldBehaviorComentsMessagePostInput$Shape;
  requiredInputOnlyField: FieldBehaviorComentsMessagePostInput$Shape;
  inputOnlyRequiredField: FieldBehaviorComentsMessagePostInput$Shape;
  inputOnlyField?: FieldBehaviorComentsMessagePostInput$Shape | null;
};

export const FieldBehaviorComentsMessageInput$Ref: InputObjectRef<
  FieldBehaviorComentsMessageInput$Shape
> = builder.inputRef<FieldBehaviorComentsMessageInput$Shape>(
  "FieldBehaviorComentsMessageInput",
).implement(
  {
    fields: (t) => ({
      requiredField: t.field({
        type: FieldBehaviorComentsMessagePostInput$Ref,
        required: true,
        description: "Required.",
        extensions: {
          protobufField: {
            name: "required_field",
            typeFullName:
              "testapis.field_behavior.FieldBehaviorComentsMessage.Post",
          },
        },
      }),
      requiredInputOnlyField: t.field({
        type: FieldBehaviorComentsMessagePostInput$Ref,
        required: true,
        description: "Required. Input only.",
        extensions: {
          protobufField: {
            name: "required_input_only_field",
            typeFullName:
              "testapis.field_behavior.FieldBehaviorComentsMessage.Post",
          },
        },
      }),
      inputOnlyRequiredField: t.field({
        type: FieldBehaviorComentsMessagePostInput$Ref,
        required: true,
        description: "Input only. Required.",
        extensions: {
          protobufField: {
            name: "input_only_required_field",
            typeFullName:
              "testapis.field_behavior.FieldBehaviorComentsMessage.Post",
          },
        },
      }),
      inputOnlyField: t.field({
        type: FieldBehaviorComentsMessagePostInput$Ref,
        required: false,
        description: "Input only.",
        extensions: {
          protobufField: {
            name: "input_only_field",
            typeFullName:
              "testapis.field_behavior.FieldBehaviorComentsMessage.Post",
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.field_behavior.FieldBehaviorComentsMessage",
        name: "FieldBehaviorComentsMessage",
        package: "testapis.field_behavior",
      },
    },
  },
);

export type FieldBehaviorComentsMessagePostInput$Shape = {
  body: FieldBehaviorComentsMessage_Post["body"];
};

export const FieldBehaviorComentsMessagePostInput$Ref: InputObjectRef<
  FieldBehaviorComentsMessagePostInput$Shape
> = builder.inputRef<FieldBehaviorComentsMessagePostInput$Shape>(
  "FieldBehaviorComentsMessagePostInput",
).implement(
  {
    fields: (t) => ({
      body: t.field({
        type: "String",
        required: true,
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.field_behavior.FieldBehaviorComentsMessage.Post",
        name: "Post",
        package: "testapis.field_behavior",
      },
    },
  },
);
",
    "name": "testapis/field_behavior/comments.pb.pothos.ts",
  },
]
`;

exports[`'testapis.multipkgs' > generates files by plugin 'with import prefix' 1`] = `[]`;

exports[`'testapis.multipkgs' > generates files by plugin 'with partial inputs' 1`] = `[]`;

exports[`'testapis.multipkgs' > generates files by plugin 'without import prefix' 1`] = `[]`;

exports[`'testapis.multipkgs.subpkg1' > generates files by plugin 'with import prefix' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/multipkgs/subpkg1/types.proto

/* eslint-disable */

import { EnumRef, InputObjectRef } from "@pothos/core";
import {
  SubpkgEnum,
  SubpkgMessage,
} from "@testapis/ts-proto/testapis/multipkgs/subpkg1/types";
import { builder } from "../../../builder";

export const SubpkgMessage$Ref = builder.objectRef<SubpkgMessage>(
  "SubpkgMessage",
);
builder.objectType(SubpkgMessage$Ref, {
  name: "SubpkgMessage",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as SubpkgMessage | { $type: string & {}; }).$type ===
      "testapis.multipkgs.subpkg1.SubpkgMessage";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.multipkgs.subpkg1.SubpkgMessage",
      name: "SubpkgMessage",
      package: "testapis.multipkgs.subpkg1",
    },
  },
});

export type SubpkgMessageInput$Shape = {
  body: SubpkgMessage["body"];
};

export const SubpkgMessageInput$Ref: InputObjectRef<SubpkgMessageInput$Shape> =
  builder.inputRef<SubpkgMessageInput$Shape>("SubpkgMessageInput").implement(
    {
      fields: (t) => ({
        body: t.field({
          type: "String",
          required: true,
          extensions: {
            protobufField: { name: "body", typeFullName: "string" },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.multipkgs.subpkg1.SubpkgMessage",
          name: "SubpkgMessage",
          package: "testapis.multipkgs.subpkg1",
        },
      },
    },
  );

export const SubpkgEnum$Ref: EnumRef<SubpkgEnum, SubpkgEnum> = builder.enumType(
  "SubpkgEnum",
  {
    values: {
      FOO: { value: 1, extensions: { protobufEnumValue: { name: "FOO" } } },
      BAR: { value: 2, extensions: { protobufEnumValue: { name: "BAR" } } },
    } as const,
    extensions: {
      protobufEnum: {
        name: "SubpkgEnum",
        fullName: "testapis.multipkgs.subpkg1.SubpkgEnum",
        package: "testapis.multipkgs.subpkg1",
      },
    },
  },
);
",
    "name": "testapis/multipkgs/subpkg1/types.pb.pothos.ts",
  },
]
`;

exports[`'testapis.multipkgs.subpkg1' > generates files by plugin 'with partial inputs' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/multipkgs/subpkg1/types.proto

/* eslint-disable */

import { EnumRef, InputObjectRef } from "@pothos/core";
import {
  SubpkgEnum,
  SubpkgMessage,
} from "@testapis/ts-proto/testapis/multipkgs/subpkg1/types";
import { builder } from "../../../builder";

export const SubpkgMessage$Ref = builder.objectRef<SubpkgMessage>(
  "SubpkgMessage",
);
builder.objectType(SubpkgMessage$Ref, {
  name: "SubpkgMessage",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as SubpkgMessage | { $type: string & {}; }).$type ===
      "testapis.multipkgs.subpkg1.SubpkgMessage";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.multipkgs.subpkg1.SubpkgMessage",
      name: "SubpkgMessage",
      package: "testapis.multipkgs.subpkg1",
    },
  },
});

export type SubpkgMessageInput$Shape = {
  body: SubpkgMessage["body"];
};

export const SubpkgMessageInput$Ref: InputObjectRef<SubpkgMessageInput$Shape> =
  builder.inputRef<SubpkgMessageInput$Shape>("SubpkgMessageInput").implement(
    {
      fields: (t) => ({
        body: t.field({
          type: "String",
          required: true,
          extensions: {
            protobufField: { name: "body", typeFullName: "string" },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.multipkgs.subpkg1.SubpkgMessage",
          name: "SubpkgMessage",
          package: "testapis.multipkgs.subpkg1",
        },
      },
    },
  );

export type SubpkgMessagePartialInput$Shape = {
  body?: SubpkgMessage["body"] | null;
};

export const SubpkgMessagePartialInput$Ref: InputObjectRef<
  SubpkgMessagePartialInput$Shape
> = builder.inputRef<SubpkgMessagePartialInput$Shape>(
  "SubpkgMessagePartialInput",
).implement(
  {
    fields: (t) => ({
      body: t.field({
        type: "String",
        required: false,
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.multipkgs.subpkg1.SubpkgMessage",
        name: "SubpkgMessage",
        package: "testapis.multipkgs.subpkg1",
      },
    },
  },
);

export const SubpkgEnum$Ref: EnumRef<SubpkgEnum, SubpkgEnum> = builder.enumType(
  "SubpkgEnum",
  {
    values: {
      FOO: { value: 1, extensions: { protobufEnumValue: { name: "FOO" } } },
      BAR: { value: 2, extensions: { protobufEnumValue: { name: "BAR" } } },
    } as const,
    extensions: {
      protobufEnum: {
        name: "SubpkgEnum",
        fullName: "testapis.multipkgs.subpkg1.SubpkgEnum",
        package: "testapis.multipkgs.subpkg1",
      },
    },
  },
);
",
    "name": "testapis/multipkgs/subpkg1/types.pb.pothos.ts",
  },
]
`;

exports[`'testapis.multipkgs.subpkg1' > generates files by plugin 'without import prefix' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/multipkgs/subpkg1/types.proto

/* eslint-disable */

import { EnumRef, InputObjectRef } from "@pothos/core";
import { builder } from "../../../builder";
import { SubpkgEnum, SubpkgMessage } from "./testapis/multipkgs/subpkg1/types";

export const SubpkgMessage$Ref = builder.objectRef<SubpkgMessage>(
  "SubpkgMessage",
);
builder.objectType(SubpkgMessage$Ref, {
  name: "SubpkgMessage",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as SubpkgMessage | { $type: string & {}; }).$type ===
      "testapis.multipkgs.subpkg1.SubpkgMessage";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.multipkgs.subpkg1.SubpkgMessage",
      name: "SubpkgMessage",
      package: "testapis.multipkgs.subpkg1",
    },
  },
});

export type SubpkgMessageInput$Shape = {
  body: SubpkgMessage["body"];
};

export const SubpkgMessageInput$Ref: InputObjectRef<SubpkgMessageInput$Shape> =
  builder.inputRef<SubpkgMessageInput$Shape>("SubpkgMessageInput").implement(
    {
      fields: (t) => ({
        body: t.field({
          type: "String",
          required: true,
          extensions: {
            protobufField: { name: "body", typeFullName: "string" },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.multipkgs.subpkg1.SubpkgMessage",
          name: "SubpkgMessage",
          package: "testapis.multipkgs.subpkg1",
        },
      },
    },
  );

export const SubpkgEnum$Ref: EnumRef<SubpkgEnum, SubpkgEnum> = builder.enumType(
  "SubpkgEnum",
  {
    values: {
      FOO: { value: 1, extensions: { protobufEnumValue: { name: "FOO" } } },
      BAR: { value: 2, extensions: { protobufEnumValue: { name: "BAR" } } },
    } as const,
    extensions: {
      protobufEnum: {
        name: "SubpkgEnum",
        fullName: "testapis.multipkgs.subpkg1.SubpkgEnum",
        package: "testapis.multipkgs.subpkg1",
      },
    },
  },
);
",
    "name": "testapis/multipkgs/subpkg1/types.pb.pothos.ts",
  },
]
`;

exports[`'testapis.multipkgs.subpkg2' > generates files by plugin 'with import prefix' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/multipkgs/subpkg2/types.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { SubpkgEnum } from "@testapis/ts-proto/testapis/multipkgs/subpkg1/types";
import { MessageWithSubpkg } from "@testapis/ts-proto/testapis/multipkgs/subpkg2/types";
import { builder } from "../../../builder";
import {
  SubpkgEnum$Ref,
  SubpkgMessage$Ref,
  SubpkgMessageInput$Ref,
  SubpkgMessageInput$Shape,
} from "../subpkg1/types.pb.pothos";

export const MessageWithSubpkg$Ref = builder.objectRef<MessageWithSubpkg>(
  "MessageWithSubpkg",
);
builder.objectType(MessageWithSubpkg$Ref, {
  name: "MessageWithSubpkg",
  fields: (t) => ({
    message: t.expose("message", {
      type: SubpkgMessage$Ref,
      nullable: true,
      extensions: {
        protobufField: {
          name: "message",
          typeFullName: "testapis.multipkgs.subpkg1.SubpkgMessage",
        },
      },
    }),
    enum: t.field({
      type: SubpkgEnum$Ref,
      nullable: true,
      resolve: (source) => {
        if (source.enum === SubpkgEnum.SUBPKG_ENUM_UNSPECIFIED) {
          return null;
        }

        return source.enum;
      },
      extensions: {
        protobufField: {
          name: "enum",
          typeFullName: "testapis.multipkgs.subpkg1.SubpkgEnum",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as MessageWithSubpkg | { $type: string & {}; }).$type ===
      "testapis.multipkgs.subpkg1.MessageWithSubpkg";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.multipkgs.subpkg1.MessageWithSubpkg",
      name: "MessageWithSubpkg",
      package: "testapis.multipkgs.subpkg1",
    },
  },
});

export type MessageWithSubpkgInput$Shape = {
  message?: SubpkgMessageInput$Shape | null;
  enum?: MessageWithSubpkg["enum"] | null;
};

export const MessageWithSubpkgInput$Ref: InputObjectRef<
  MessageWithSubpkgInput$Shape
> = builder.inputRef<MessageWithSubpkgInput$Shape>("MessageWithSubpkgInput")
  .implement(
    {
      fields: (t) => ({
        message: t.field({
          type: SubpkgMessageInput$Ref,
          required: false,
          extensions: {
            protobufField: {
              name: "message",
              typeFullName: "testapis.multipkgs.subpkg1.SubpkgMessage",
            },
          },
        }),
        enum: t.field({
          type: SubpkgEnum$Ref,
          required: false,
          extensions: {
            protobufField: {
              name: "enum",
              typeFullName: "testapis.multipkgs.subpkg1.SubpkgEnum",
            },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.multipkgs.subpkg1.MessageWithSubpkg",
          name: "MessageWithSubpkg",
          package: "testapis.multipkgs.subpkg1",
        },
      },
    },
  );
",
    "name": "testapis/multipkgs/subpkg2/types.pb.pothos.ts",
  },
]
`;

exports[`'testapis.multipkgs.subpkg2' > generates files by plugin 'with partial inputs' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/multipkgs/subpkg2/types.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { SubpkgEnum } from "@testapis/ts-proto/testapis/multipkgs/subpkg1/types";
import { MessageWithSubpkg } from "@testapis/ts-proto/testapis/multipkgs/subpkg2/types";
import { builder } from "../../../builder";
import {
  SubpkgEnum$Ref,
  SubpkgMessage$Ref,
  SubpkgMessageInput$Ref,
  SubpkgMessageInput$Shape,
  SubpkgMessagePartialInput$Ref,
  SubpkgMessagePartialInput$Shape,
} from "../subpkg1/types.pb.pothos";

export const MessageWithSubpkg$Ref = builder.objectRef<MessageWithSubpkg>(
  "MessageWithSubpkg",
);
builder.objectType(MessageWithSubpkg$Ref, {
  name: "MessageWithSubpkg",
  fields: (t) => ({
    message: t.expose("message", {
      type: SubpkgMessage$Ref,
      nullable: true,
      extensions: {
        protobufField: {
          name: "message",
          typeFullName: "testapis.multipkgs.subpkg1.SubpkgMessage",
        },
      },
    }),
    enum: t.field({
      type: SubpkgEnum$Ref,
      nullable: true,
      resolve: (source) => {
        if (source.enum === SubpkgEnum.SUBPKG_ENUM_UNSPECIFIED) {
          return null;
        }

        return source.enum;
      },
      extensions: {
        protobufField: {
          name: "enum",
          typeFullName: "testapis.multipkgs.subpkg1.SubpkgEnum",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as MessageWithSubpkg | { $type: string & {}; }).$type ===
      "testapis.multipkgs.subpkg1.MessageWithSubpkg";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.multipkgs.subpkg1.MessageWithSubpkg",
      name: "MessageWithSubpkg",
      package: "testapis.multipkgs.subpkg1",
    },
  },
});

export type MessageWithSubpkgInput$Shape = {
  message?: SubpkgMessageInput$Shape | null;
  enum?: MessageWithSubpkg["enum"] | null;
};

export const MessageWithSubpkgInput$Ref: InputObjectRef<
  MessageWithSubpkgInput$Shape
> = builder.inputRef<MessageWithSubpkgInput$Shape>("MessageWithSubpkgInput")
  .implement(
    {
      fields: (t) => ({
        message: t.field({
          type: SubpkgMessageInput$Ref,
          required: false,
          extensions: {
            protobufField: {
              name: "message",
              typeFullName: "testapis.multipkgs.subpkg1.SubpkgMessage",
            },
          },
        }),
        enum: t.field({
          type: SubpkgEnum$Ref,
          required: false,
          extensions: {
            protobufField: {
              name: "enum",
              typeFullName: "testapis.multipkgs.subpkg1.SubpkgEnum",
            },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.multipkgs.subpkg1.MessageWithSubpkg",
          name: "MessageWithSubpkg",
          package: "testapis.multipkgs.subpkg1",
        },
      },
    },
  );

export type MessageWithSubpkgPartialInput$Shape = {
  message?: SubpkgMessagePartialInput$Shape | null;
  enum?: MessageWithSubpkg["enum"] | null;
};

export const MessageWithSubpkgPartialInput$Ref: InputObjectRef<
  MessageWithSubpkgPartialInput$Shape
> = builder.inputRef<MessageWithSubpkgPartialInput$Shape>(
  "MessageWithSubpkgPartialInput",
).implement(
  {
    fields: (t) => ({
      message: t.field({
        type: SubpkgMessagePartialInput$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "message",
            typeFullName: "testapis.multipkgs.subpkg1.SubpkgMessage",
          },
        },
      }),
      enum: t.field({
        type: SubpkgEnum$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "enum",
            typeFullName: "testapis.multipkgs.subpkg1.SubpkgEnum",
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.multipkgs.subpkg1.MessageWithSubpkg",
        name: "MessageWithSubpkg",
        package: "testapis.multipkgs.subpkg1",
      },
    },
  },
);
",
    "name": "testapis/multipkgs/subpkg2/types.pb.pothos.ts",
  },
]
`;

exports[`'testapis.multipkgs.subpkg2' > generates files by plugin 'without import prefix' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/multipkgs/subpkg2/types.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { builder } from "../../../builder";
import {
  SubpkgEnum$Ref,
  SubpkgMessage$Ref,
  SubpkgMessageInput$Ref,
  SubpkgMessageInput$Shape,
} from "../subpkg1/types.pb.pothos";
import { SubpkgEnum } from "./testapis/multipkgs/subpkg1/types";
import { MessageWithSubpkg } from "./testapis/multipkgs/subpkg2/types";

export const MessageWithSubpkg$Ref = builder.objectRef<MessageWithSubpkg>(
  "MessageWithSubpkg",
);
builder.objectType(MessageWithSubpkg$Ref, {
  name: "MessageWithSubpkg",
  fields: (t) => ({
    message: t.expose("message", {
      type: SubpkgMessage$Ref,
      nullable: true,
      extensions: {
        protobufField: {
          name: "message",
          typeFullName: "testapis.multipkgs.subpkg1.SubpkgMessage",
        },
      },
    }),
    enum: t.field({
      type: SubpkgEnum$Ref,
      nullable: true,
      resolve: (source) => {
        if (source.enum === SubpkgEnum.SUBPKG_ENUM_UNSPECIFIED) {
          return null;
        }

        return source.enum;
      },
      extensions: {
        protobufField: {
          name: "enum",
          typeFullName: "testapis.multipkgs.subpkg1.SubpkgEnum",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as MessageWithSubpkg | { $type: string & {}; }).$type ===
      "testapis.multipkgs.subpkg1.MessageWithSubpkg";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.multipkgs.subpkg1.MessageWithSubpkg",
      name: "MessageWithSubpkg",
      package: "testapis.multipkgs.subpkg1",
    },
  },
});

export type MessageWithSubpkgInput$Shape = {
  message?: SubpkgMessageInput$Shape | null;
  enum?: MessageWithSubpkg["enum"] | null;
};

export const MessageWithSubpkgInput$Ref: InputObjectRef<
  MessageWithSubpkgInput$Shape
> = builder.inputRef<MessageWithSubpkgInput$Shape>("MessageWithSubpkgInput")
  .implement(
    {
      fields: (t) => ({
        message: t.field({
          type: SubpkgMessageInput$Ref,
          required: false,
          extensions: {
            protobufField: {
              name: "message",
              typeFullName: "testapis.multipkgs.subpkg1.SubpkgMessage",
            },
          },
        }),
        enum: t.field({
          type: SubpkgEnum$Ref,
          required: false,
          extensions: {
            protobufField: {
              name: "enum",
              typeFullName: "testapis.multipkgs.subpkg1.SubpkgEnum",
            },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.multipkgs.subpkg1.MessageWithSubpkg",
          name: "MessageWithSubpkg",
          package: "testapis.multipkgs.subpkg1",
        },
      },
    },
  );
",
    "name": "testapis/multipkgs/subpkg2/types.pb.pothos.ts",
  },
]
`;

exports[`'testapis.nested' > generates files by plugin 'with import prefix' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/nested/nested.proto

/* eslint-disable */

import { EnumRef, InputObjectRef } from "@pothos/core";
import {
  ParentMessage,
  ParentMessage_NestedEnum,
  ParentMessage_NestedMessage,
} from "@testapis/ts-proto/testapis/nested/nested";
import { builder } from "../../builder";

export const ParentMessage$Ref = builder.objectRef<ParentMessage>(
  "ParentMessage",
);
builder.objectType(ParentMessage$Ref, {
  name: "ParentMessage",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
    nested: t.expose("nested", {
      type: ParentMessageNestedMessage$Ref,
      nullable: true,
      extensions: {
        protobufField: {
          name: "nested",
          typeFullName: "testapis.nested.ParentMessage.NestedMessage",
        },
      },
    }),
    nestedEnum: t.field({
      type: ParentMessageNestedEnum$Ref,
      nullable: true,
      resolve: (source) => {
        if (
          source.nestedEnum === ParentMessage_NestedEnum.NESTED_ENUM_UNSPECIFIED
        ) {
          return null;
        }

        return source.nestedEnum;
      },
      extensions: {
        protobufField: {
          name: "nested_enum",
          typeFullName: "testapis.nested.ParentMessage.NestedEnum",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as ParentMessage | { $type: string & {}; }).$type ===
      "testapis.nested.ParentMessage";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.nested.ParentMessage",
      name: "ParentMessage",
      package: "testapis.nested",
    },
  },
});

export const ParentMessageNestedMessage$Ref = builder.objectRef<
  ParentMessage_NestedMessage
>("ParentMessageNestedMessage");
builder.objectType(ParentMessageNestedMessage$Ref, {
  name: "ParentMessageNestedMessage",
  fields: (t) => ({
    nestedBody: t.expose("nestedBody", {
      type: "String",
      nullable: false,
      extensions: {
        protobufField: { name: "nested_body", typeFullName: "string" },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as ParentMessage_NestedMessage | { $type: string & {}; })
      .$type ===
      "testapis.nested.ParentMessage.NestedMessage";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.nested.ParentMessage.NestedMessage",
      name: "NestedMessage",
      package: "testapis.nested",
    },
  },
});

export type ParentMessageInput$Shape = {
  body: ParentMessage["body"];
  nested?: ParentMessageNestedMessageInput$Shape | null;
  nestedEnum?: ParentMessage["nestedEnum"] | null;
};

export const ParentMessageInput$Ref: InputObjectRef<ParentMessageInput$Shape> =
  builder.inputRef<ParentMessageInput$Shape>("ParentMessageInput").implement(
    {
      fields: (t) => ({
        body: t.field({
          type: "String",
          required: true,
          extensions: {
            protobufField: { name: "body", typeFullName: "string" },
          },
        }),
        nested: t.field({
          type: ParentMessageNestedMessageInput$Ref,
          required: false,
          extensions: {
            protobufField: {
              name: "nested",
              typeFullName: "testapis.nested.ParentMessage.NestedMessage",
            },
          },
        }),
        nestedEnum: t.field({
          type: ParentMessageNestedEnum$Ref,
          required: false,
          extensions: {
            protobufField: {
              name: "nested_enum",
              typeFullName: "testapis.nested.ParentMessage.NestedEnum",
            },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.nested.ParentMessage",
          name: "ParentMessage",
          package: "testapis.nested",
        },
      },
    },
  );

export type ParentMessageNestedMessageInput$Shape = {
  nestedBody: ParentMessage_NestedMessage["nestedBody"];
};

export const ParentMessageNestedMessageInput$Ref: InputObjectRef<
  ParentMessageNestedMessageInput$Shape
> = builder.inputRef<ParentMessageNestedMessageInput$Shape>(
  "ParentMessageNestedMessageInput",
).implement(
  {
    fields: (t) => ({
      nestedBody: t.field({
        type: "String",
        required: true,
        extensions: {
          protobufField: { name: "nested_body", typeFullName: "string" },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.nested.ParentMessage.NestedMessage",
        name: "NestedMessage",
        package: "testapis.nested",
      },
    },
  },
);

export const ParentMessageNestedEnum$Ref: EnumRef<
  ParentMessage_NestedEnum,
  ParentMessage_NestedEnum
> = builder.enumType("ParentMessageNestedEnum", {
  values: {
    FOO: { value: 1, extensions: { protobufEnumValue: { name: "FOO" } } },
    BAR: { value: 2, extensions: { protobufEnumValue: { name: "BAR" } } },
  } as const,
  extensions: {
    protobufEnum: {
      name: "NestedEnum",
      fullName: "testapis.nested.ParentMessage.NestedEnum",
      package: "testapis.nested",
    },
  },
});
",
    "name": "testapis/nested/nested.pb.pothos.ts",
  },
]
`;

exports[`'testapis.nested' > generates files by plugin 'with partial inputs' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/nested/nested.proto

/* eslint-disable */

import { EnumRef, InputObjectRef } from "@pothos/core";
import {
  ParentMessage,
  ParentMessage_NestedEnum,
  ParentMessage_NestedMessage,
} from "@testapis/ts-proto/testapis/nested/nested";
import { builder } from "../../builder";

export const ParentMessage$Ref = builder.objectRef<ParentMessage>(
  "ParentMessage",
);
builder.objectType(ParentMessage$Ref, {
  name: "ParentMessage",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
    nested: t.expose("nested", {
      type: ParentMessageNestedMessage$Ref,
      nullable: true,
      extensions: {
        protobufField: {
          name: "nested",
          typeFullName: "testapis.nested.ParentMessage.NestedMessage",
        },
      },
    }),
    nestedEnum: t.field({
      type: ParentMessageNestedEnum$Ref,
      nullable: true,
      resolve: (source) => {
        if (
          source.nestedEnum === ParentMessage_NestedEnum.NESTED_ENUM_UNSPECIFIED
        ) {
          return null;
        }

        return source.nestedEnum;
      },
      extensions: {
        protobufField: {
          name: "nested_enum",
          typeFullName: "testapis.nested.ParentMessage.NestedEnum",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as ParentMessage | { $type: string & {}; }).$type ===
      "testapis.nested.ParentMessage";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.nested.ParentMessage",
      name: "ParentMessage",
      package: "testapis.nested",
    },
  },
});

export const ParentMessageNestedMessage$Ref = builder.objectRef<
  ParentMessage_NestedMessage
>("ParentMessageNestedMessage");
builder.objectType(ParentMessageNestedMessage$Ref, {
  name: "ParentMessageNestedMessage",
  fields: (t) => ({
    nestedBody: t.expose("nestedBody", {
      type: "String",
      nullable: false,
      extensions: {
        protobufField: { name: "nested_body", typeFullName: "string" },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as ParentMessage_NestedMessage | { $type: string & {}; })
      .$type ===
      "testapis.nested.ParentMessage.NestedMessage";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.nested.ParentMessage.NestedMessage",
      name: "NestedMessage",
      package: "testapis.nested",
    },
  },
});

export type ParentMessageInput$Shape = {
  body: ParentMessage["body"];
  nested?: ParentMessageNestedMessageInput$Shape | null;
  nestedEnum?: ParentMessage["nestedEnum"] | null;
};

export const ParentMessageInput$Ref: InputObjectRef<ParentMessageInput$Shape> =
  builder.inputRef<ParentMessageInput$Shape>("ParentMessageInput").implement(
    {
      fields: (t) => ({
        body: t.field({
          type: "String",
          required: true,
          extensions: {
            protobufField: { name: "body", typeFullName: "string" },
          },
        }),
        nested: t.field({
          type: ParentMessageNestedMessageInput$Ref,
          required: false,
          extensions: {
            protobufField: {
              name: "nested",
              typeFullName: "testapis.nested.ParentMessage.NestedMessage",
            },
          },
        }),
        nestedEnum: t.field({
          type: ParentMessageNestedEnum$Ref,
          required: false,
          extensions: {
            protobufField: {
              name: "nested_enum",
              typeFullName: "testapis.nested.ParentMessage.NestedEnum",
            },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.nested.ParentMessage",
          name: "ParentMessage",
          package: "testapis.nested",
        },
      },
    },
  );

export type ParentMessagePartialInput$Shape = {
  body?: ParentMessage["body"] | null;
  nested?: ParentMessageNestedMessagePartialInput$Shape | null;
  nestedEnum?: ParentMessage["nestedEnum"] | null;
};

export const ParentMessagePartialInput$Ref: InputObjectRef<
  ParentMessagePartialInput$Shape
> = builder.inputRef<ParentMessagePartialInput$Shape>(
  "ParentMessagePartialInput",
).implement(
  {
    fields: (t) => ({
      body: t.field({
        type: "String",
        required: false,
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
      nested: t.field({
        type: ParentMessageNestedMessagePartialInput$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "nested",
            typeFullName: "testapis.nested.ParentMessage.NestedMessage",
          },
        },
      }),
      nestedEnum: t.field({
        type: ParentMessageNestedEnum$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "nested_enum",
            typeFullName: "testapis.nested.ParentMessage.NestedEnum",
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.nested.ParentMessage",
        name: "ParentMessage",
        package: "testapis.nested",
      },
    },
  },
);

export type ParentMessageNestedMessageInput$Shape = {
  nestedBody: ParentMessage_NestedMessage["nestedBody"];
};

export const ParentMessageNestedMessageInput$Ref: InputObjectRef<
  ParentMessageNestedMessageInput$Shape
> = builder.inputRef<ParentMessageNestedMessageInput$Shape>(
  "ParentMessageNestedMessageInput",
).implement(
  {
    fields: (t) => ({
      nestedBody: t.field({
        type: "String",
        required: true,
        extensions: {
          protobufField: { name: "nested_body", typeFullName: "string" },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.nested.ParentMessage.NestedMessage",
        name: "NestedMessage",
        package: "testapis.nested",
      },
    },
  },
);

export type ParentMessageNestedMessagePartialInput$Shape = {
  nestedBody?: ParentMessage_NestedMessage["nestedBody"] | null;
};

export const ParentMessageNestedMessagePartialInput$Ref: InputObjectRef<
  ParentMessageNestedMessagePartialInput$Shape
> = builder.inputRef<ParentMessageNestedMessagePartialInput$Shape>(
  "ParentMessageNestedMessagePartialInput",
).implement(
  {
    fields: (t) => ({
      nestedBody: t.field({
        type: "String",
        required: false,
        extensions: {
          protobufField: { name: "nested_body", typeFullName: "string" },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.nested.ParentMessage.NestedMessage",
        name: "NestedMessage",
        package: "testapis.nested",
      },
    },
  },
);

export const ParentMessageNestedEnum$Ref: EnumRef<
  ParentMessage_NestedEnum,
  ParentMessage_NestedEnum
> = builder.enumType("ParentMessageNestedEnum", {
  values: {
    FOO: { value: 1, extensions: { protobufEnumValue: { name: "FOO" } } },
    BAR: { value: 2, extensions: { protobufEnumValue: { name: "BAR" } } },
  } as const,
  extensions: {
    protobufEnum: {
      name: "NestedEnum",
      fullName: "testapis.nested.ParentMessage.NestedEnum",
      package: "testapis.nested",
    },
  },
});
",
    "name": "testapis/nested/nested.pb.pothos.ts",
  },
]
`;

exports[`'testapis.nested' > generates files by plugin 'without import prefix' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/nested/nested.proto

/* eslint-disable */

import { EnumRef, InputObjectRef } from "@pothos/core";
import { builder } from "../../builder";
import {
  ParentMessage,
  ParentMessage_NestedEnum,
  ParentMessage_NestedMessage,
} from "./testapis/nested/nested";

export const ParentMessage$Ref = builder.objectRef<ParentMessage>(
  "ParentMessage",
);
builder.objectType(ParentMessage$Ref, {
  name: "ParentMessage",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
    nested: t.expose("nested", {
      type: ParentMessageNestedMessage$Ref,
      nullable: true,
      extensions: {
        protobufField: {
          name: "nested",
          typeFullName: "testapis.nested.ParentMessage.NestedMessage",
        },
      },
    }),
    nestedEnum: t.field({
      type: ParentMessageNestedEnum$Ref,
      nullable: true,
      resolve: (source) => {
        if (
          source.nestedEnum === ParentMessage_NestedEnum.NESTED_ENUM_UNSPECIFIED
        ) {
          return null;
        }

        return source.nestedEnum;
      },
      extensions: {
        protobufField: {
          name: "nested_enum",
          typeFullName: "testapis.nested.ParentMessage.NestedEnum",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as ParentMessage | { $type: string & {}; }).$type ===
      "testapis.nested.ParentMessage";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.nested.ParentMessage",
      name: "ParentMessage",
      package: "testapis.nested",
    },
  },
});

export const ParentMessageNestedMessage$Ref = builder.objectRef<
  ParentMessage_NestedMessage
>("ParentMessageNestedMessage");
builder.objectType(ParentMessageNestedMessage$Ref, {
  name: "ParentMessageNestedMessage",
  fields: (t) => ({
    nestedBody: t.expose("nestedBody", {
      type: "String",
      nullable: false,
      extensions: {
        protobufField: { name: "nested_body", typeFullName: "string" },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as ParentMessage_NestedMessage | { $type: string & {}; })
      .$type ===
      "testapis.nested.ParentMessage.NestedMessage";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.nested.ParentMessage.NestedMessage",
      name: "NestedMessage",
      package: "testapis.nested",
    },
  },
});

export type ParentMessageInput$Shape = {
  body: ParentMessage["body"];
  nested?: ParentMessageNestedMessageInput$Shape | null;
  nestedEnum?: ParentMessage["nestedEnum"] | null;
};

export const ParentMessageInput$Ref: InputObjectRef<ParentMessageInput$Shape> =
  builder.inputRef<ParentMessageInput$Shape>("ParentMessageInput").implement(
    {
      fields: (t) => ({
        body: t.field({
          type: "String",
          required: true,
          extensions: {
            protobufField: { name: "body", typeFullName: "string" },
          },
        }),
        nested: t.field({
          type: ParentMessageNestedMessageInput$Ref,
          required: false,
          extensions: {
            protobufField: {
              name: "nested",
              typeFullName: "testapis.nested.ParentMessage.NestedMessage",
            },
          },
        }),
        nestedEnum: t.field({
          type: ParentMessageNestedEnum$Ref,
          required: false,
          extensions: {
            protobufField: {
              name: "nested_enum",
              typeFullName: "testapis.nested.ParentMessage.NestedEnum",
            },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.nested.ParentMessage",
          name: "ParentMessage",
          package: "testapis.nested",
        },
      },
    },
  );

export type ParentMessageNestedMessageInput$Shape = {
  nestedBody: ParentMessage_NestedMessage["nestedBody"];
};

export const ParentMessageNestedMessageInput$Ref: InputObjectRef<
  ParentMessageNestedMessageInput$Shape
> = builder.inputRef<ParentMessageNestedMessageInput$Shape>(
  "ParentMessageNestedMessageInput",
).implement(
  {
    fields: (t) => ({
      nestedBody: t.field({
        type: "String",
        required: true,
        extensions: {
          protobufField: { name: "nested_body", typeFullName: "string" },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.nested.ParentMessage.NestedMessage",
        name: "NestedMessage",
        package: "testapis.nested",
      },
    },
  },
);

export const ParentMessageNestedEnum$Ref: EnumRef<
  ParentMessage_NestedEnum,
  ParentMessage_NestedEnum
> = builder.enumType("ParentMessageNestedEnum", {
  values: {
    FOO: { value: 1, extensions: { protobufEnumValue: { name: "FOO" } } },
    BAR: { value: 2, extensions: { protobufEnumValue: { name: "BAR" } } },
  } as const,
  extensions: {
    protobufEnum: {
      name: "NestedEnum",
      fullName: "testapis.nested.ParentMessage.NestedEnum",
      package: "testapis.nested",
    },
  },
});
",
    "name": "testapis/nested/nested.pb.pothos.ts",
  },
]
`;

exports[`'testapis.oneof' > generates files by plugin 'with import prefix' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/oneof/oneof.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import {
  OneofMemberMessage1,
  OneofMemberMessage2,
  OneofParent,
} from "@testapis/ts-proto/testapis/oneof/oneof";
import { builder } from "../../builder";

export const OneofParent$Ref = builder.objectRef<OneofParent>("OneofParent");
builder.objectType(OneofParent$Ref, {
  name: "OneofParent",
  fields: (t) => ({
    normalField: t.expose("normalField", {
      type: "String",
      nullable: false,
      extensions: {
        protobufField: { name: "normal_field", typeFullName: "string" },
      },
    }),
    requiredOneofMembers: t.field({
      type: OneofParentRequiredOneofMembers$Ref,
      nullable: false,
      description: "Required. disallow not_set.",
      resolve: (source) => {
        const value = source.requiredMessage1 ?? source.requiredMessage2;
        if (value == null) {
          throw new Error("requiredOneofMembers should not be null");
        }
        return value;
      },
      extensions: { protobufField: { name: "required_oneof_members" } },
    }),
    optionalOneofMembers: t.field({
      type: OneofParentOptionalOneofMembers$Ref,
      nullable: true,
      resolve: (source) => {
        const value = source.optoinalMessage1 ?? source.optoinalMessage2;
        if (value == null) {
          return null;
        }
        return value;
      },
      extensions: { protobufField: { name: "optional_oneof_members" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as OneofParent | { $type: string & {}; }).$type ===
      "testapis.oneof.OneofParent";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.oneof.OneofParent",
      name: "OneofParent",
      package: "testapis.oneof",
    },
  },
});

export const OneofMemberMessage1$Ref = builder.objectRef<OneofMemberMessage1>(
  "OneofMemberMessage1",
);
builder.objectType(OneofMemberMessage1$Ref, {
  name: "OneofMemberMessage1",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as OneofMemberMessage1 | { $type: string & {}; }).$type ===
      "testapis.oneof.OneofMemberMessage1";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.oneof.OneofMemberMessage1",
      name: "OneofMemberMessage1",
      package: "testapis.oneof",
    },
  },
});

export const OneofMemberMessage2$Ref = builder.objectRef<OneofMemberMessage2>(
  "OneofMemberMessage2",
);
builder.objectType(OneofMemberMessage2$Ref, {
  name: "OneofMemberMessage2",
  fields: (t) => ({
    imageUrl: t.expose("imageUrl", {
      type: "String",
      nullable: false,
      extensions: {
        protobufField: { name: "image_url", typeFullName: "string" },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as OneofMemberMessage2 | { $type: string & {}; }).$type ===
      "testapis.oneof.OneofMemberMessage2";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.oneof.OneofMemberMessage2",
      name: "OneofMemberMessage2",
      package: "testapis.oneof",
    },
  },
});

export type OneofParentInput$Shape = {
  normalField: OneofParent["normalField"];
  requiredMessage1?: OneofMemberMessage1Input$Shape | null;
  requiredMessage2?: OneofMemberMessage2Input$Shape | null;
  optoinalMessage1?: OneofMemberMessage1Input$Shape | null;
  optoinalMessage2?: OneofMemberMessage2Input$Shape | null;
};

export const OneofParentInput$Ref: InputObjectRef<OneofParentInput$Shape> =
  builder.inputRef<OneofParentInput$Shape>("OneofParentInput").implement(
    {
      fields: (t) => ({
        normalField: t.field({
          type: "String",
          required: true,
          extensions: {
            protobufField: { name: "normal_field", typeFullName: "string" },
          },
        }),
        requiredMessage1: t.field({
          type: OneofMemberMessage1Input$Ref,
          required: false,
          extensions: {
            protobufField: {
              name: "required_message1",
              typeFullName: "testapis.oneof.OneofMemberMessage1",
            },
          },
        }),
        requiredMessage2: t.field({
          type: OneofMemberMessage2Input$Ref,
          required: false,
          extensions: {
            protobufField: {
              name: "required_message2",
              typeFullName: "testapis.oneof.OneofMemberMessage2",
            },
          },
        }),
        optoinalMessage1: t.field({
          type: OneofMemberMessage1Input$Ref,
          required: false,
          extensions: {
            protobufField: {
              name: "optoinal_message1",
              typeFullName: "testapis.oneof.OneofMemberMessage1",
            },
          },
        }),
        optoinalMessage2: t.field({
          type: OneofMemberMessage2Input$Ref,
          required: false,
          extensions: {
            protobufField: {
              name: "optoinal_message2",
              typeFullName: "testapis.oneof.OneofMemberMessage2",
            },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.oneof.OneofParent",
          name: "OneofParent",
          package: "testapis.oneof",
        },
      },
    },
  );

export type OneofMemberMessage1Input$Shape = {
  body: OneofMemberMessage1["body"];
};

export const OneofMemberMessage1Input$Ref: InputObjectRef<
  OneofMemberMessage1Input$Shape
> = builder.inputRef<OneofMemberMessage1Input$Shape>("OneofMemberMessage1Input")
  .implement(
    {
      fields: (t) => ({
        body: t.field({
          type: "String",
          required: true,
          extensions: {
            protobufField: { name: "body", typeFullName: "string" },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.oneof.OneofMemberMessage1",
          name: "OneofMemberMessage1",
          package: "testapis.oneof",
        },
      },
    },
  );

export type OneofMemberMessage2Input$Shape = {
  imageUrl: OneofMemberMessage2["imageUrl"];
};

export const OneofMemberMessage2Input$Ref: InputObjectRef<
  OneofMemberMessage2Input$Shape
> = builder.inputRef<OneofMemberMessage2Input$Shape>("OneofMemberMessage2Input")
  .implement(
    {
      fields: (t) => ({
        imageUrl: t.field({
          type: "String",
          required: true,
          extensions: {
            protobufField: { name: "image_url", typeFullName: "string" },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.oneof.OneofMemberMessage2",
          name: "OneofMemberMessage2",
          package: "testapis.oneof",
        },
      },
    },
  );

export const OneofParentRequiredOneofMembers$Ref = builder.unionType(
  "OneofParentRequiredOneofMembers",
  {
    types: [OneofMemberMessage1$Ref, OneofMemberMessage2$Ref],
    description: "Required. disallow not_set.",
    extensions: {
      protobufOneof: {
        fullName: "testapis.oneof.OneofParent.required_oneof_members",
        name: "required_oneof_members",
        messageName: "OneofParent",
        package: "testapis.oneof",
        fields: [{
          name: "required_message1",
          type: "testapis.oneof.OneofMemberMessage1",
        }, {
          name: "required_message2",
          type: "testapis.oneof.OneofMemberMessage2",
        }],
      },
    },
  },
);

export const OneofParentOptionalOneofMembers$Ref = builder.unionType(
  "OneofParentOptionalOneofMembers",
  {
    types: [OneofMemberMessage1$Ref, OneofMemberMessage2$Ref],
    extensions: {
      protobufOneof: {
        fullName: "testapis.oneof.OneofParent.optional_oneof_members",
        name: "optional_oneof_members",
        messageName: "OneofParent",
        package: "testapis.oneof",
        fields: [{
          name: "optoinal_message1",
          type: "testapis.oneof.OneofMemberMessage1",
        }, {
          name: "optoinal_message2",
          type: "testapis.oneof.OneofMemberMessage2",
        }],
      },
    },
  },
);
",
    "name": "testapis/oneof/oneof.pb.pothos.ts",
  },
]
`;

exports[`'testapis.oneof' > generates files by plugin 'with partial inputs' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/oneof/oneof.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import {
  OneofMemberMessage1,
  OneofMemberMessage2,
  OneofParent,
} from "@testapis/ts-proto/testapis/oneof/oneof";
import { builder } from "../../builder";

export const OneofParent$Ref = builder.objectRef<OneofParent>("OneofParent");
builder.objectType(OneofParent$Ref, {
  name: "OneofParent",
  fields: (t) => ({
    normalField: t.expose("normalField", {
      type: "String",
      nullable: false,
      extensions: {
        protobufField: { name: "normal_field", typeFullName: "string" },
      },
    }),
    requiredOneofMembers: t.field({
      type: OneofParentRequiredOneofMembers$Ref,
      nullable: false,
      description: "Required. disallow not_set.",
      resolve: (source) => {
        const value = source.requiredMessage1 ?? source.requiredMessage2;
        if (value == null) {
          throw new Error("requiredOneofMembers should not be null");
        }
        return value;
      },
      extensions: { protobufField: { name: "required_oneof_members" } },
    }),
    optionalOneofMembers: t.field({
      type: OneofParentOptionalOneofMembers$Ref,
      nullable: true,
      resolve: (source) => {
        const value = source.optoinalMessage1 ?? source.optoinalMessage2;
        if (value == null) {
          return null;
        }
        return value;
      },
      extensions: { protobufField: { name: "optional_oneof_members" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as OneofParent | { $type: string & {}; }).$type ===
      "testapis.oneof.OneofParent";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.oneof.OneofParent",
      name: "OneofParent",
      package: "testapis.oneof",
    },
  },
});

export const OneofMemberMessage1$Ref = builder.objectRef<OneofMemberMessage1>(
  "OneofMemberMessage1",
);
builder.objectType(OneofMemberMessage1$Ref, {
  name: "OneofMemberMessage1",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as OneofMemberMessage1 | { $type: string & {}; }).$type ===
      "testapis.oneof.OneofMemberMessage1";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.oneof.OneofMemberMessage1",
      name: "OneofMemberMessage1",
      package: "testapis.oneof",
    },
  },
});

export const OneofMemberMessage2$Ref = builder.objectRef<OneofMemberMessage2>(
  "OneofMemberMessage2",
);
builder.objectType(OneofMemberMessage2$Ref, {
  name: "OneofMemberMessage2",
  fields: (t) => ({
    imageUrl: t.expose("imageUrl", {
      type: "String",
      nullable: false,
      extensions: {
        protobufField: { name: "image_url", typeFullName: "string" },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as OneofMemberMessage2 | { $type: string & {}; }).$type ===
      "testapis.oneof.OneofMemberMessage2";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.oneof.OneofMemberMessage2",
      name: "OneofMemberMessage2",
      package: "testapis.oneof",
    },
  },
});

export type OneofParentInput$Shape = {
  normalField: OneofParent["normalField"];
  requiredMessage1?: OneofMemberMessage1Input$Shape | null;
  requiredMessage2?: OneofMemberMessage2Input$Shape | null;
  optoinalMessage1?: OneofMemberMessage1Input$Shape | null;
  optoinalMessage2?: OneofMemberMessage2Input$Shape | null;
};

export const OneofParentInput$Ref: InputObjectRef<OneofParentInput$Shape> =
  builder.inputRef<OneofParentInput$Shape>("OneofParentInput").implement(
    {
      fields: (t) => ({
        normalField: t.field({
          type: "String",
          required: true,
          extensions: {
            protobufField: { name: "normal_field", typeFullName: "string" },
          },
        }),
        requiredMessage1: t.field({
          type: OneofMemberMessage1Input$Ref,
          required: false,
          extensions: {
            protobufField: {
              name: "required_message1",
              typeFullName: "testapis.oneof.OneofMemberMessage1",
            },
          },
        }),
        requiredMessage2: t.field({
          type: OneofMemberMessage2Input$Ref,
          required: false,
          extensions: {
            protobufField: {
              name: "required_message2",
              typeFullName: "testapis.oneof.OneofMemberMessage2",
            },
          },
        }),
        optoinalMessage1: t.field({
          type: OneofMemberMessage1Input$Ref,
          required: false,
          extensions: {
            protobufField: {
              name: "optoinal_message1",
              typeFullName: "testapis.oneof.OneofMemberMessage1",
            },
          },
        }),
        optoinalMessage2: t.field({
          type: OneofMemberMessage2Input$Ref,
          required: false,
          extensions: {
            protobufField: {
              name: "optoinal_message2",
              typeFullName: "testapis.oneof.OneofMemberMessage2",
            },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.oneof.OneofParent",
          name: "OneofParent",
          package: "testapis.oneof",
        },
      },
    },
  );

export type OneofParentPartialInput$Shape = {
  normalField?: OneofParent["normalField"] | null;
  requiredMessage1?: OneofMemberMessage1PartialInput$Shape | null;
  requiredMessage2?: OneofMemberMessage2PartialInput$Shape | null;
  optoinalMessage1?: OneofMemberMessage1PartialInput$Shape | null;
  optoinalMessage2?: OneofMemberMessage2PartialInput$Shape | null;
};

export const OneofParentPartialInput$Ref: InputObjectRef<
  OneofParentPartialInput$Shape
> = builder.inputRef<OneofParentPartialInput$Shape>("OneofParentPartialInput")
  .implement(
    {
      fields: (t) => ({
        normalField: t.field({
          type: "String",
          required: false,
          extensions: {
            protobufField: { name: "normal_field", typeFullName: "string" },
          },
        }),
        requiredMessage1: t.field({
          type: OneofMemberMessage1PartialInput$Ref,
          required: false,
          extensions: {
            protobufField: {
              name: "required_message1",
              typeFullName: "testapis.oneof.OneofMemberMessage1",
            },
          },
        }),
        requiredMessage2: t.field({
          type: OneofMemberMessage2PartialInput$Ref,
          required: false,
          extensions: {
            protobufField: {
              name: "required_message2",
              typeFullName: "testapis.oneof.OneofMemberMessage2",
            },
          },
        }),
        optoinalMessage1: t.field({
          type: OneofMemberMessage1PartialInput$Ref,
          required: false,
          extensions: {
            protobufField: {
              name: "optoinal_message1",
              typeFullName: "testapis.oneof.OneofMemberMessage1",
            },
          },
        }),
        optoinalMessage2: t.field({
          type: OneofMemberMessage2PartialInput$Ref,
          required: false,
          extensions: {
            protobufField: {
              name: "optoinal_message2",
              typeFullName: "testapis.oneof.OneofMemberMessage2",
            },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.oneof.OneofParent",
          name: "OneofParent",
          package: "testapis.oneof",
        },
      },
    },
  );

export type OneofMemberMessage1Input$Shape = {
  body: OneofMemberMessage1["body"];
};

export const OneofMemberMessage1Input$Ref: InputObjectRef<
  OneofMemberMessage1Input$Shape
> = builder.inputRef<OneofMemberMessage1Input$Shape>("OneofMemberMessage1Input")
  .implement(
    {
      fields: (t) => ({
        body: t.field({
          type: "String",
          required: true,
          extensions: {
            protobufField: { name: "body", typeFullName: "string" },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.oneof.OneofMemberMessage1",
          name: "OneofMemberMessage1",
          package: "testapis.oneof",
        },
      },
    },
  );

export type OneofMemberMessage1PartialInput$Shape = {
  body?: OneofMemberMessage1["body"] | null;
};

export const OneofMemberMessage1PartialInput$Ref: InputObjectRef<
  OneofMemberMessage1PartialInput$Shape
> = builder.inputRef<OneofMemberMessage1PartialInput$Shape>(
  "OneofMemberMessage1PartialInput",
).implement(
  {
    fields: (t) => ({
      body: t.field({
        type: "String",
        required: false,
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.oneof.OneofMemberMessage1",
        name: "OneofMemberMessage1",
        package: "testapis.oneof",
      },
    },
  },
);

export type OneofMemberMessage2Input$Shape = {
  imageUrl: OneofMemberMessage2["imageUrl"];
};

export const OneofMemberMessage2Input$Ref: InputObjectRef<
  OneofMemberMessage2Input$Shape
> = builder.inputRef<OneofMemberMessage2Input$Shape>("OneofMemberMessage2Input")
  .implement(
    {
      fields: (t) => ({
        imageUrl: t.field({
          type: "String",
          required: true,
          extensions: {
            protobufField: { name: "image_url", typeFullName: "string" },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.oneof.OneofMemberMessage2",
          name: "OneofMemberMessage2",
          package: "testapis.oneof",
        },
      },
    },
  );

export type OneofMemberMessage2PartialInput$Shape = {
  imageUrl?: OneofMemberMessage2["imageUrl"] | null;
};

export const OneofMemberMessage2PartialInput$Ref: InputObjectRef<
  OneofMemberMessage2PartialInput$Shape
> = builder.inputRef<OneofMemberMessage2PartialInput$Shape>(
  "OneofMemberMessage2PartialInput",
).implement(
  {
    fields: (t) => ({
      imageUrl: t.field({
        type: "String",
        required: false,
        extensions: {
          protobufField: { name: "image_url", typeFullName: "string" },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.oneof.OneofMemberMessage2",
        name: "OneofMemberMessage2",
        package: "testapis.oneof",
      },
    },
  },
);

export const OneofParentRequiredOneofMembers$Ref = builder.unionType(
  "OneofParentRequiredOneofMembers",
  {
    types: [OneofMemberMessage1$Ref, OneofMemberMessage2$Ref],
    description: "Required. disallow not_set.",
    extensions: {
      protobufOneof: {
        fullName: "testapis.oneof.OneofParent.required_oneof_members",
        name: "required_oneof_members",
        messageName: "OneofParent",
        package: "testapis.oneof",
        fields: [{
          name: "required_message1",
          type: "testapis.oneof.OneofMemberMessage1",
        }, {
          name: "required_message2",
          type: "testapis.oneof.OneofMemberMessage2",
        }],
      },
    },
  },
);

export const OneofParentOptionalOneofMembers$Ref = builder.unionType(
  "OneofParentOptionalOneofMembers",
  {
    types: [OneofMemberMessage1$Ref, OneofMemberMessage2$Ref],
    extensions: {
      protobufOneof: {
        fullName: "testapis.oneof.OneofParent.optional_oneof_members",
        name: "optional_oneof_members",
        messageName: "OneofParent",
        package: "testapis.oneof",
        fields: [{
          name: "optoinal_message1",
          type: "testapis.oneof.OneofMemberMessage1",
        }, {
          name: "optoinal_message2",
          type: "testapis.oneof.OneofMemberMessage2",
        }],
      },
    },
  },
);
",
    "name": "testapis/oneof/oneof.pb.pothos.ts",
  },
]
`;

exports[`'testapis.oneof' > generates files by plugin 'without import prefix' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/oneof/oneof.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { builder } from "../../builder";
import {
  OneofMemberMessage1,
  OneofMemberMessage2,
  OneofParent,
} from "./testapis/oneof/oneof";

export const OneofParent$Ref = builder.objectRef<OneofParent>("OneofParent");
builder.objectType(OneofParent$Ref, {
  name: "OneofParent",
  fields: (t) => ({
    normalField: t.expose("normalField", {
      type: "String",
      nullable: false,
      extensions: {
        protobufField: { name: "normal_field", typeFullName: "string" },
      },
    }),
    requiredOneofMembers: t.field({
      type: OneofParentRequiredOneofMembers$Ref,
      nullable: false,
      description: "Required. disallow not_set.",
      resolve: (source) => {
        const value = source.requiredMessage1 ?? source.requiredMessage2;
        if (value == null) {
          throw new Error("requiredOneofMembers should not be null");
        }
        return value;
      },
      extensions: { protobufField: { name: "required_oneof_members" } },
    }),
    optionalOneofMembers: t.field({
      type: OneofParentOptionalOneofMembers$Ref,
      nullable: true,
      resolve: (source) => {
        const value = source.optoinalMessage1 ?? source.optoinalMessage2;
        if (value == null) {
          return null;
        }
        return value;
      },
      extensions: { protobufField: { name: "optional_oneof_members" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as OneofParent | { $type: string & {}; }).$type ===
      "testapis.oneof.OneofParent";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.oneof.OneofParent",
      name: "OneofParent",
      package: "testapis.oneof",
    },
  },
});

export const OneofMemberMessage1$Ref = builder.objectRef<OneofMemberMessage1>(
  "OneofMemberMessage1",
);
builder.objectType(OneofMemberMessage1$Ref, {
  name: "OneofMemberMessage1",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as OneofMemberMessage1 | { $type: string & {}; }).$type ===
      "testapis.oneof.OneofMemberMessage1";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.oneof.OneofMemberMessage1",
      name: "OneofMemberMessage1",
      package: "testapis.oneof",
    },
  },
});

export const OneofMemberMessage2$Ref = builder.objectRef<OneofMemberMessage2>(
  "OneofMemberMessage2",
);
builder.objectType(OneofMemberMessage2$Ref, {
  name: "OneofMemberMessage2",
  fields: (t) => ({
    imageUrl: t.expose("imageUrl", {
      type: "String",
      nullable: false,
      extensions: {
        protobufField: { name: "image_url", typeFullName: "string" },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as OneofMemberMessage2 | { $type: string & {}; }).$type ===
      "testapis.oneof.OneofMemberMessage2";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.oneof.OneofMemberMessage2",
      name: "OneofMemberMessage2",
      package: "testapis.oneof",
    },
  },
});

export type OneofParentInput$Shape = {
  normalField: OneofParent["normalField"];
  requiredMessage1?: OneofMemberMessage1Input$Shape | null;
  requiredMessage2?: OneofMemberMessage2Input$Shape | null;
  optoinalMessage1?: OneofMemberMessage1Input$Shape | null;
  optoinalMessage2?: OneofMemberMessage2Input$Shape | null;
};

export const OneofParentInput$Ref: InputObjectRef<OneofParentInput$Shape> =
  builder.inputRef<OneofParentInput$Shape>("OneofParentInput").implement(
    {
      fields: (t) => ({
        normalField: t.field({
          type: "String",
          required: true,
          extensions: {
            protobufField: { name: "normal_field", typeFullName: "string" },
          },
        }),
        requiredMessage1: t.field({
          type: OneofMemberMessage1Input$Ref,
          required: false,
          extensions: {
            protobufField: {
              name: "required_message1",
              typeFullName: "testapis.oneof.OneofMemberMessage1",
            },
          },
        }),
        requiredMessage2: t.field({
          type: OneofMemberMessage2Input$Ref,
          required: false,
          extensions: {
            protobufField: {
              name: "required_message2",
              typeFullName: "testapis.oneof.OneofMemberMessage2",
            },
          },
        }),
        optoinalMessage1: t.field({
          type: OneofMemberMessage1Input$Ref,
          required: false,
          extensions: {
            protobufField: {
              name: "optoinal_message1",
              typeFullName: "testapis.oneof.OneofMemberMessage1",
            },
          },
        }),
        optoinalMessage2: t.field({
          type: OneofMemberMessage2Input$Ref,
          required: false,
          extensions: {
            protobufField: {
              name: "optoinal_message2",
              typeFullName: "testapis.oneof.OneofMemberMessage2",
            },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.oneof.OneofParent",
          name: "OneofParent",
          package: "testapis.oneof",
        },
      },
    },
  );

export type OneofMemberMessage1Input$Shape = {
  body: OneofMemberMessage1["body"];
};

export const OneofMemberMessage1Input$Ref: InputObjectRef<
  OneofMemberMessage1Input$Shape
> = builder.inputRef<OneofMemberMessage1Input$Shape>("OneofMemberMessage1Input")
  .implement(
    {
      fields: (t) => ({
        body: t.field({
          type: "String",
          required: true,
          extensions: {
            protobufField: { name: "body", typeFullName: "string" },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.oneof.OneofMemberMessage1",
          name: "OneofMemberMessage1",
          package: "testapis.oneof",
        },
      },
    },
  );

export type OneofMemberMessage2Input$Shape = {
  imageUrl: OneofMemberMessage2["imageUrl"];
};

export const OneofMemberMessage2Input$Ref: InputObjectRef<
  OneofMemberMessage2Input$Shape
> = builder.inputRef<OneofMemberMessage2Input$Shape>("OneofMemberMessage2Input")
  .implement(
    {
      fields: (t) => ({
        imageUrl: t.field({
          type: "String",
          required: true,
          extensions: {
            protobufField: { name: "image_url", typeFullName: "string" },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.oneof.OneofMemberMessage2",
          name: "OneofMemberMessage2",
          package: "testapis.oneof",
        },
      },
    },
  );

export const OneofParentRequiredOneofMembers$Ref = builder.unionType(
  "OneofParentRequiredOneofMembers",
  {
    types: [OneofMemberMessage1$Ref, OneofMemberMessage2$Ref],
    description: "Required. disallow not_set.",
    extensions: {
      protobufOneof: {
        fullName: "testapis.oneof.OneofParent.required_oneof_members",
        name: "required_oneof_members",
        messageName: "OneofParent",
        package: "testapis.oneof",
        fields: [{
          name: "required_message1",
          type: "testapis.oneof.OneofMemberMessage1",
        }, {
          name: "required_message2",
          type: "testapis.oneof.OneofMemberMessage2",
        }],
      },
    },
  },
);

export const OneofParentOptionalOneofMembers$Ref = builder.unionType(
  "OneofParentOptionalOneofMembers",
  {
    types: [OneofMemberMessage1$Ref, OneofMemberMessage2$Ref],
    extensions: {
      protobufOneof: {
        fullName: "testapis.oneof.OneofParent.optional_oneof_members",
        name: "optional_oneof_members",
        messageName: "OneofParent",
        package: "testapis.oneof",
        fields: [{
          name: "optoinal_message1",
          type: "testapis.oneof.OneofMemberMessage1",
        }, {
          name: "optoinal_message2",
          type: "testapis.oneof.OneofMemberMessage2",
        }],
      },
    },
  },
);
",
    "name": "testapis/oneof/oneof.pb.pothos.ts",
  },
]
`;

exports[`'testapis.primitives' > generates files by plugin 'with import prefix' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/primitives/primitives.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import {
  Message,
  Primitives,
} from "@testapis/ts-proto/testapis/primitives/primitives";
import { builder } from "../../builder";

export const Message$Ref = builder.objectRef<Message>("Message");
builder.objectType(Message$Ref, {
  name: "Message",
  fields: (t) => ({
    requiredPrimitives: t.field({
      type: Primitives$Ref,
      nullable: false,
      description: "Required.",
      resolve: (source) => {
        return source.requiredPrimitives!;
      },
      extensions: {
        protobufField: {
          name: "required_primitives",
          typeFullName: "testapis.primitives.Primitives",
        },
      },
    }),
    optionalPrimitives: t.expose("optionalPrimitives", {
      type: Primitives$Ref,
      nullable: true,
      description: "Optional.",
      extensions: {
        protobufField: {
          name: "optional_primitives",
          typeFullName: "testapis.primitives.Primitives",
        },
      },
    }),
    requiredPrimitivesList: t.field({
      type: [Primitives$Ref],
      nullable: { list: false, items: false },
      description: "Required.",
      resolve: (source) => {
        return source.requiredPrimitivesList!;
      },
      extensions: {
        protobufField: {
          name: "required_primitives_list",
          typeFullName: "testapis.primitives.Primitives",
        },
      },
    }),
    optionalPrimitivesList: t.expose("optionalPrimitivesList", {
      type: [Primitives$Ref],
      nullable: { list: true, items: false },
      description: "Optional.",
      extensions: {
        protobufField: {
          name: "optional_primitives_list",
          typeFullName: "testapis.primitives.Primitives",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as Message | { $type: string & {}; }).$type ===
      "testapis.primitives.Message";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.primitives.Message",
      name: "Message",
      package: "testapis.primitives",
    },
  },
});

export const Primitives$Ref = builder.objectRef<Primitives>("Primitives");
builder.objectType(Primitives$Ref, {
  name: "Primitives",
  fields: (t) => ({
    requiredDoubleValue: t.expose("requiredDoubleValue", {
      type: "Float",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_double_value",
          typeFullName: "double",
        },
      },
    }),
    requiredFloatValue: t.expose("requiredFloatValue", {
      type: "Float",
      nullable: false,
      extensions: {
        protobufField: { name: "required_float_value", typeFullName: "float" },
      },
    }),
    requiredInt32Value: t.expose("requiredInt32Value", {
      type: "Int",
      nullable: false,
      extensions: {
        protobufField: { name: "required_int32_value", typeFullName: "int32" },
      },
    }),
    requiredInt64Value: t.expose("requiredInt64Value", {
      type: "String",
      nullable: false,
      extensions: {
        protobufField: { name: "required_int64_value", typeFullName: "int64" },
      },
    }),
    requiredUint32Value: t.expose("requiredUint32Value", {
      type: "Int",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_uint32_value",
          typeFullName: "uint32",
        },
      },
    }),
    requiredUint64Value: t.expose("requiredUint64Value", {
      type: "String",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_uint64_value",
          typeFullName: "uint64",
        },
      },
    }),
    requiredSint32Value: t.expose("requiredSint32Value", {
      type: "Int",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_sint32_value",
          typeFullName: "sint32",
        },
      },
    }),
    requiredSint64Value: t.expose("requiredSint64Value", {
      type: "String",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_sint64_value",
          typeFullName: "sint64",
        },
      },
    }),
    requiredFixed32Value: t.expose("requiredFixed32Value", {
      type: "Int",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_fixed32_value",
          typeFullName: "fixed32",
        },
      },
    }),
    requiredFixed64Value: t.expose("requiredFixed64Value", {
      type: "String",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_fixed64_value",
          typeFullName: "fixed64",
        },
      },
    }),
    requiredSfixed32Value: t.expose("requiredSfixed32Value", {
      type: "Int",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_sfixed32_value",
          typeFullName: "sfixed32",
        },
      },
    }),
    requiredSfixed64Value: t.expose("requiredSfixed64Value", {
      type: "String",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_sfixed64_value",
          typeFullName: "sfixed64",
        },
      },
    }),
    requiredBoolValue: t.expose("requiredBoolValue", {
      type: "Boolean",
      nullable: false,
      extensions: {
        protobufField: { name: "required_bool_value", typeFullName: "bool" },
      },
    }),
    requiredStringValue: t.expose("requiredStringValue", {
      type: "String",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_string_value",
          typeFullName: "string",
        },
      },
    }),
    requiredBytesValue: t.field({
      type: "Byte",
      nullable: false,
      resolve: (source) => {
        return Buffer.from(source.requiredBytesValue);
      },
      extensions: {
        protobufField: { name: "required_bytes_value", typeFullName: "bytes" },
      },
    }),
    requiredDoubleValues: t.expose("requiredDoubleValues", {
      type: ["Float"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: {
          name: "required_double_values",
          typeFullName: "double",
        },
      },
    }),
    requiredFloatValues: t.expose("requiredFloatValues", {
      type: ["Float"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: { name: "required_float_values", typeFullName: "float" },
      },
    }),
    requiredInt32Values: t.expose("requiredInt32Values", {
      type: ["Int"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: { name: "required_int32_values", typeFullName: "int32" },
      },
    }),
    requiredInt64Values: t.expose("requiredInt64Values", {
      type: ["String"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: { name: "required_int64_values", typeFullName: "int64" },
      },
    }),
    requiredUint32Values: t.expose("requiredUint32Values", {
      type: ["Int"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: {
          name: "required_uint32_values",
          typeFullName: "uint32",
        },
      },
    }),
    requiredUint64Values: t.expose("requiredUint64Values", {
      type: ["String"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: {
          name: "required_uint64_values",
          typeFullName: "uint64",
        },
      },
    }),
    requiredSint32Values: t.expose("requiredSint32Values", {
      type: ["Int"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: {
          name: "required_sint32_values",
          typeFullName: "sint32",
        },
      },
    }),
    requiredSint64Values: t.expose("requiredSint64Values", {
      type: ["String"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: {
          name: "required_sint64_values",
          typeFullName: "sint64",
        },
      },
    }),
    requiredFixed32Values: t.expose("requiredFixed32Values", {
      type: ["Int"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: {
          name: "required_fixed32_values",
          typeFullName: "fixed32",
        },
      },
    }),
    requiredFixed64Values: t.expose("requiredFixed64Values", {
      type: ["String"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: {
          name: "required_fixed64_values",
          typeFullName: "fixed64",
        },
      },
    }),
    requiredSfixed32Values: t.expose("requiredSfixed32Values", {
      type: ["Int"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: {
          name: "required_sfixed32_values",
          typeFullName: "sfixed32",
        },
      },
    }),
    requiredSfixed64Values: t.expose("requiredSfixed64Values", {
      type: ["String"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: {
          name: "required_sfixed64_values",
          typeFullName: "sfixed64",
        },
      },
    }),
    requiredBoolValues: t.expose("requiredBoolValues", {
      type: ["Boolean"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: { name: "required_bool_values", typeFullName: "bool" },
      },
    }),
    requiredStringValues: t.expose("requiredStringValues", {
      type: ["String"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: {
          name: "required_string_values",
          typeFullName: "string",
        },
      },
    }),
    requiredBytesValues: t.field({
      type: ["Byte"],
      nullable: { list: false, items: false },
      resolve: (source) => {
        return source.requiredBytesValues.map((v) => Buffer.from(v));
      },
      extensions: {
        protobufField: { name: "required_bytes_values", typeFullName: "bytes" },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as Primitives | { $type: string & {}; }).$type ===
      "testapis.primitives.Primitives";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.primitives.Primitives",
      name: "Primitives",
      package: "testapis.primitives",
    },
  },
});

export type MessageInput$Shape = {
  requiredPrimitives: PrimitivesInput$Shape;
  optionalPrimitives?: PrimitivesInput$Shape | null;
  requiredPrimitivesList: Array<PrimitivesInput$Shape>;
  optionalPrimitivesList?: Array<PrimitivesInput$Shape> | null;
};

export const MessageInput$Ref: InputObjectRef<MessageInput$Shape> = builder
  .inputRef<MessageInput$Shape>("MessageInput").implement(
    {
      fields: (t) => ({
        requiredPrimitives: t.field({
          type: PrimitivesInput$Ref,
          required: true,
          description: "Required.",
          extensions: {
            protobufField: {
              name: "required_primitives",
              typeFullName: "testapis.primitives.Primitives",
            },
          },
        }),
        optionalPrimitives: t.field({
          type: PrimitivesInput$Ref,
          required: false,
          description: "Optional.",
          extensions: {
            protobufField: {
              name: "optional_primitives",
              typeFullName: "testapis.primitives.Primitives",
            },
          },
        }),
        requiredPrimitivesList: t.field({
          type: [PrimitivesInput$Ref],
          required: { list: true, items: true },
          description: "Required.",
          extensions: {
            protobufField: {
              name: "required_primitives_list",
              typeFullName: "testapis.primitives.Primitives",
            },
          },
        }),
        optionalPrimitivesList: t.field({
          type: [PrimitivesInput$Ref],
          required: { list: false, items: true },
          description: "Optional.",
          extensions: {
            protobufField: {
              name: "optional_primitives_list",
              typeFullName: "testapis.primitives.Primitives",
            },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.primitives.Message",
          name: "Message",
          package: "testapis.primitives",
        },
      },
    },
  );

export type PrimitivesInput$Shape = {
  requiredDoubleValue: Primitives["requiredDoubleValue"];
  requiredFloatValue: Primitives["requiredFloatValue"];
  requiredInt32Value: Primitives["requiredInt32Value"];
  requiredInt64Value: Primitives["requiredInt64Value"];
  requiredUint32Value: Primitives["requiredUint32Value"];
  requiredUint64Value: Primitives["requiredUint64Value"];
  requiredSint32Value: Primitives["requiredSint32Value"];
  requiredSint64Value: Primitives["requiredSint64Value"];
  requiredFixed32Value: Primitives["requiredFixed32Value"];
  requiredFixed64Value: Primitives["requiredFixed64Value"];
  requiredSfixed32Value: Primitives["requiredSfixed32Value"];
  requiredSfixed64Value: Primitives["requiredSfixed64Value"];
  requiredBoolValue: Primitives["requiredBoolValue"];
  requiredStringValue: Primitives["requiredStringValue"];
  requiredBytesValue: Primitives["requiredBytesValue"];
  requiredDoubleValues: Primitives["requiredDoubleValues"];
  requiredFloatValues: Primitives["requiredFloatValues"];
  requiredInt32Values: Primitives["requiredInt32Values"];
  requiredInt64Values: Primitives["requiredInt64Values"];
  requiredUint32Values: Primitives["requiredUint32Values"];
  requiredUint64Values: Primitives["requiredUint64Values"];
  requiredSint32Values: Primitives["requiredSint32Values"];
  requiredSint64Values: Primitives["requiredSint64Values"];
  requiredFixed32Values: Primitives["requiredFixed32Values"];
  requiredFixed64Values: Primitives["requiredFixed64Values"];
  requiredSfixed32Values: Primitives["requiredSfixed32Values"];
  requiredSfixed64Values: Primitives["requiredSfixed64Values"];
  requiredBoolValues: Primitives["requiredBoolValues"];
  requiredStringValues: Primitives["requiredStringValues"];
  requiredBytesValues: Primitives["requiredBytesValues"];
};

export const PrimitivesInput$Ref: InputObjectRef<PrimitivesInput$Shape> =
  builder.inputRef<PrimitivesInput$Shape>("PrimitivesInput").implement(
    {
      fields: (t) => ({
        requiredDoubleValue: t.field({
          type: "Float",
          required: true,
          extensions: {
            protobufField: {
              name: "required_double_value",
              typeFullName: "double",
            },
          },
        }),
        requiredFloatValue: t.field({
          type: "Float",
          required: true,
          extensions: {
            protobufField: {
              name: "required_float_value",
              typeFullName: "float",
            },
          },
        }),
        requiredInt32Value: t.field({
          type: "Int",
          required: true,
          extensions: {
            protobufField: {
              name: "required_int32_value",
              typeFullName: "int32",
            },
          },
        }),
        requiredInt64Value: t.field({
          type: "String",
          required: true,
          extensions: {
            protobufField: {
              name: "required_int64_value",
              typeFullName: "int64",
            },
          },
        }),
        requiredUint32Value: t.field({
          type: "Int",
          required: true,
          extensions: {
            protobufField: {
              name: "required_uint32_value",
              typeFullName: "uint32",
            },
          },
        }),
        requiredUint64Value: t.field({
          type: "String",
          required: true,
          extensions: {
            protobufField: {
              name: "required_uint64_value",
              typeFullName: "uint64",
            },
          },
        }),
        requiredSint32Value: t.field({
          type: "Int",
          required: true,
          extensions: {
            protobufField: {
              name: "required_sint32_value",
              typeFullName: "sint32",
            },
          },
        }),
        requiredSint64Value: t.field({
          type: "String",
          required: true,
          extensions: {
            protobufField: {
              name: "required_sint64_value",
              typeFullName: "sint64",
            },
          },
        }),
        requiredFixed32Value: t.field({
          type: "Int",
          required: true,
          extensions: {
            protobufField: {
              name: "required_fixed32_value",
              typeFullName: "fixed32",
            },
          },
        }),
        requiredFixed64Value: t.field({
          type: "String",
          required: true,
          extensions: {
            protobufField: {
              name: "required_fixed64_value",
              typeFullName: "fixed64",
            },
          },
        }),
        requiredSfixed32Value: t.field({
          type: "Int",
          required: true,
          extensions: {
            protobufField: {
              name: "required_sfixed32_value",
              typeFullName: "sfixed32",
            },
          },
        }),
        requiredSfixed64Value: t.field({
          type: "String",
          required: true,
          extensions: {
            protobufField: {
              name: "required_sfixed64_value",
              typeFullName: "sfixed64",
            },
          },
        }),
        requiredBoolValue: t.field({
          type: "Boolean",
          required: true,
          extensions: {
            protobufField: {
              name: "required_bool_value",
              typeFullName: "bool",
            },
          },
        }),
        requiredStringValue: t.field({
          type: "String",
          required: true,
          extensions: {
            protobufField: {
              name: "required_string_value",
              typeFullName: "string",
            },
          },
        }),
        requiredBytesValue: t.field({
          type: "Byte",
          required: true,
          extensions: {
            protobufField: {
              name: "required_bytes_value",
              typeFullName: "bytes",
            },
          },
        }),
        requiredDoubleValues: t.field({
          type: ["Float"],
          required: { list: true, items: true },
          extensions: {
            protobufField: {
              name: "required_double_values",
              typeFullName: "double",
            },
          },
        }),
        requiredFloatValues: t.field({
          type: ["Float"],
          required: { list: true, items: true },
          extensions: {
            protobufField: {
              name: "required_float_values",
              typeFullName: "float",
            },
          },
        }),
        requiredInt32Values: t.field({
          type: ["Int"],
          required: { list: true, items: true },
          extensions: {
            protobufField: {
              name: "required_int32_values",
              typeFullName: "int32",
            },
          },
        }),
        requiredInt64Values: t.field({
          type: ["String"],
          required: { list: true, items: true },
          extensions: {
            protobufField: {
              name: "required_int64_values",
              typeFullName: "int64",
            },
          },
        }),
        requiredUint32Values: t.field({
          type: ["Int"],
          required: { list: true, items: true },
          extensions: {
            protobufField: {
              name: "required_uint32_values",
              typeFullName: "uint32",
            },
          },
        }),
        requiredUint64Values: t.field({
          type: ["String"],
          required: { list: true, items: true },
          extensions: {
            protobufField: {
              name: "required_uint64_values",
              typeFullName: "uint64",
            },
          },
        }),
        requiredSint32Values: t.field({
          type: ["Int"],
          required: { list: true, items: true },
          extensions: {
            protobufField: {
              name: "required_sint32_values",
              typeFullName: "sint32",
            },
          },
        }),
        requiredSint64Values: t.field({
          type: ["String"],
          required: { list: true, items: true },
          extensions: {
            protobufField: {
              name: "required_sint64_values",
              typeFullName: "sint64",
            },
          },
        }),
        requiredFixed32Values: t.field({
          type: ["Int"],
          required: { list: true, items: true },
          extensions: {
            protobufField: {
              name: "required_fixed32_values",
              typeFullName: "fixed32",
            },
          },
        }),
        requiredFixed64Values: t.field({
          type: ["String"],
          required: { list: true, items: true },
          extensions: {
            protobufField: {
              name: "required_fixed64_values",
              typeFullName: "fixed64",
            },
          },
        }),
        requiredSfixed32Values: t.field({
          type: ["Int"],
          required: { list: true, items: true },
          extensions: {
            protobufField: {
              name: "required_sfixed32_values",
              typeFullName: "sfixed32",
            },
          },
        }),
        requiredSfixed64Values: t.field({
          type: ["String"],
          required: { list: true, items: true },
          extensions: {
            protobufField: {
              name: "required_sfixed64_values",
              typeFullName: "sfixed64",
            },
          },
        }),
        requiredBoolValues: t.field({
          type: ["Boolean"],
          required: { list: true, items: true },
          extensions: {
            protobufField: {
              name: "required_bool_values",
              typeFullName: "bool",
            },
          },
        }),
        requiredStringValues: t.field({
          type: ["String"],
          required: { list: true, items: true },
          extensions: {
            protobufField: {
              name: "required_string_values",
              typeFullName: "string",
            },
          },
        }),
        requiredBytesValues: t.field({
          type: ["Byte"],
          required: { list: true, items: true },
          extensions: {
            protobufField: {
              name: "required_bytes_values",
              typeFullName: "bytes",
            },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.primitives.Primitives",
          name: "Primitives",
          package: "testapis.primitives",
        },
      },
    },
  );
",
    "name": "testapis/primitives/primitives.pb.pothos.ts",
  },
]
`;

exports[`'testapis.primitives' > generates files by plugin 'with partial inputs' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/primitives/primitives.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import {
  Message,
  Primitives,
} from "@testapis/ts-proto/testapis/primitives/primitives";
import { builder } from "../../builder";

export const Message$Ref = builder.objectRef<Message>("Message");
builder.objectType(Message$Ref, {
  name: "Message",
  fields: (t) => ({
    requiredPrimitives: t.field({
      type: Primitives$Ref,
      nullable: false,
      description: "Required.",
      resolve: (source) => {
        return source.requiredPrimitives!;
      },
      extensions: {
        protobufField: {
          name: "required_primitives",
          typeFullName: "testapis.primitives.Primitives",
        },
      },
    }),
    optionalPrimitives: t.expose("optionalPrimitives", {
      type: Primitives$Ref,
      nullable: true,
      description: "Optional.",
      extensions: {
        protobufField: {
          name: "optional_primitives",
          typeFullName: "testapis.primitives.Primitives",
        },
      },
    }),
    requiredPrimitivesList: t.field({
      type: [Primitives$Ref],
      nullable: { list: false, items: false },
      description: "Required.",
      resolve: (source) => {
        return source.requiredPrimitivesList!;
      },
      extensions: {
        protobufField: {
          name: "required_primitives_list",
          typeFullName: "testapis.primitives.Primitives",
        },
      },
    }),
    optionalPrimitivesList: t.expose("optionalPrimitivesList", {
      type: [Primitives$Ref],
      nullable: { list: true, items: false },
      description: "Optional.",
      extensions: {
        protobufField: {
          name: "optional_primitives_list",
          typeFullName: "testapis.primitives.Primitives",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as Message | { $type: string & {}; }).$type ===
      "testapis.primitives.Message";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.primitives.Message",
      name: "Message",
      package: "testapis.primitives",
    },
  },
});

export const Primitives$Ref = builder.objectRef<Primitives>("Primitives");
builder.objectType(Primitives$Ref, {
  name: "Primitives",
  fields: (t) => ({
    requiredDoubleValue: t.expose("requiredDoubleValue", {
      type: "Float",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_double_value",
          typeFullName: "double",
        },
      },
    }),
    requiredFloatValue: t.expose("requiredFloatValue", {
      type: "Float",
      nullable: false,
      extensions: {
        protobufField: { name: "required_float_value", typeFullName: "float" },
      },
    }),
    requiredInt32Value: t.expose("requiredInt32Value", {
      type: "Int",
      nullable: false,
      extensions: {
        protobufField: { name: "required_int32_value", typeFullName: "int32" },
      },
    }),
    requiredInt64Value: t.expose("requiredInt64Value", {
      type: "String",
      nullable: false,
      extensions: {
        protobufField: { name: "required_int64_value", typeFullName: "int64" },
      },
    }),
    requiredUint32Value: t.expose("requiredUint32Value", {
      type: "Int",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_uint32_value",
          typeFullName: "uint32",
        },
      },
    }),
    requiredUint64Value: t.expose("requiredUint64Value", {
      type: "String",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_uint64_value",
          typeFullName: "uint64",
        },
      },
    }),
    requiredSint32Value: t.expose("requiredSint32Value", {
      type: "Int",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_sint32_value",
          typeFullName: "sint32",
        },
      },
    }),
    requiredSint64Value: t.expose("requiredSint64Value", {
      type: "String",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_sint64_value",
          typeFullName: "sint64",
        },
      },
    }),
    requiredFixed32Value: t.expose("requiredFixed32Value", {
      type: "Int",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_fixed32_value",
          typeFullName: "fixed32",
        },
      },
    }),
    requiredFixed64Value: t.expose("requiredFixed64Value", {
      type: "String",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_fixed64_value",
          typeFullName: "fixed64",
        },
      },
    }),
    requiredSfixed32Value: t.expose("requiredSfixed32Value", {
      type: "Int",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_sfixed32_value",
          typeFullName: "sfixed32",
        },
      },
    }),
    requiredSfixed64Value: t.expose("requiredSfixed64Value", {
      type: "String",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_sfixed64_value",
          typeFullName: "sfixed64",
        },
      },
    }),
    requiredBoolValue: t.expose("requiredBoolValue", {
      type: "Boolean",
      nullable: false,
      extensions: {
        protobufField: { name: "required_bool_value", typeFullName: "bool" },
      },
    }),
    requiredStringValue: t.expose("requiredStringValue", {
      type: "String",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_string_value",
          typeFullName: "string",
        },
      },
    }),
    requiredBytesValue: t.field({
      type: "Byte",
      nullable: false,
      resolve: (source) => {
        return Buffer.from(source.requiredBytesValue);
      },
      extensions: {
        protobufField: { name: "required_bytes_value", typeFullName: "bytes" },
      },
    }),
    requiredDoubleValues: t.expose("requiredDoubleValues", {
      type: ["Float"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: {
          name: "required_double_values",
          typeFullName: "double",
        },
      },
    }),
    requiredFloatValues: t.expose("requiredFloatValues", {
      type: ["Float"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: { name: "required_float_values", typeFullName: "float" },
      },
    }),
    requiredInt32Values: t.expose("requiredInt32Values", {
      type: ["Int"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: { name: "required_int32_values", typeFullName: "int32" },
      },
    }),
    requiredInt64Values: t.expose("requiredInt64Values", {
      type: ["String"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: { name: "required_int64_values", typeFullName: "int64" },
      },
    }),
    requiredUint32Values: t.expose("requiredUint32Values", {
      type: ["Int"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: {
          name: "required_uint32_values",
          typeFullName: "uint32",
        },
      },
    }),
    requiredUint64Values: t.expose("requiredUint64Values", {
      type: ["String"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: {
          name: "required_uint64_values",
          typeFullName: "uint64",
        },
      },
    }),
    requiredSint32Values: t.expose("requiredSint32Values", {
      type: ["Int"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: {
          name: "required_sint32_values",
          typeFullName: "sint32",
        },
      },
    }),
    requiredSint64Values: t.expose("requiredSint64Values", {
      type: ["String"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: {
          name: "required_sint64_values",
          typeFullName: "sint64",
        },
      },
    }),
    requiredFixed32Values: t.expose("requiredFixed32Values", {
      type: ["Int"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: {
          name: "required_fixed32_values",
          typeFullName: "fixed32",
        },
      },
    }),
    requiredFixed64Values: t.expose("requiredFixed64Values", {
      type: ["String"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: {
          name: "required_fixed64_values",
          typeFullName: "fixed64",
        },
      },
    }),
    requiredSfixed32Values: t.expose("requiredSfixed32Values", {
      type: ["Int"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: {
          name: "required_sfixed32_values",
          typeFullName: "sfixed32",
        },
      },
    }),
    requiredSfixed64Values: t.expose("requiredSfixed64Values", {
      type: ["String"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: {
          name: "required_sfixed64_values",
          typeFullName: "sfixed64",
        },
      },
    }),
    requiredBoolValues: t.expose("requiredBoolValues", {
      type: ["Boolean"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: { name: "required_bool_values", typeFullName: "bool" },
      },
    }),
    requiredStringValues: t.expose("requiredStringValues", {
      type: ["String"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: {
          name: "required_string_values",
          typeFullName: "string",
        },
      },
    }),
    requiredBytesValues: t.field({
      type: ["Byte"],
      nullable: { list: false, items: false },
      resolve: (source) => {
        return source.requiredBytesValues.map((v) => Buffer.from(v));
      },
      extensions: {
        protobufField: { name: "required_bytes_values", typeFullName: "bytes" },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as Primitives | { $type: string & {}; }).$type ===
      "testapis.primitives.Primitives";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.primitives.Primitives",
      name: "Primitives",
      package: "testapis.primitives",
    },
  },
});

export type MessageInput$Shape = {
  requiredPrimitives: PrimitivesInput$Shape;
  optionalPrimitives?: PrimitivesInput$Shape | null;
  requiredPrimitivesList: Array<PrimitivesInput$Shape>;
  optionalPrimitivesList?: Array<PrimitivesInput$Shape> | null;
};

export const MessageInput$Ref: InputObjectRef<MessageInput$Shape> = builder
  .inputRef<MessageInput$Shape>("MessageInput").implement(
    {
      fields: (t) => ({
        requiredPrimitives: t.field({
          type: PrimitivesInput$Ref,
          required: true,
          description: "Required.",
          extensions: {
            protobufField: {
              name: "required_primitives",
              typeFullName: "testapis.primitives.Primitives",
            },
          },
        }),
        optionalPrimitives: t.field({
          type: PrimitivesInput$Ref,
          required: false,
          description: "Optional.",
          extensions: {
            protobufField: {
              name: "optional_primitives",
              typeFullName: "testapis.primitives.Primitives",
            },
          },
        }),
        requiredPrimitivesList: t.field({
          type: [PrimitivesInput$Ref],
          required: { list: true, items: true },
          description: "Required.",
          extensions: {
            protobufField: {
              name: "required_primitives_list",
              typeFullName: "testapis.primitives.Primitives",
            },
          },
        }),
        optionalPrimitivesList: t.field({
          type: [PrimitivesInput$Ref],
          required: { list: false, items: true },
          description: "Optional.",
          extensions: {
            protobufField: {
              name: "optional_primitives_list",
              typeFullName: "testapis.primitives.Primitives",
            },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.primitives.Message",
          name: "Message",
          package: "testapis.primitives",
        },
      },
    },
  );

export type MessagePartialInput$Shape = {
  requiredPrimitives?: PrimitivesPartialInput$Shape | null;
  optionalPrimitives?: PrimitivesPartialInput$Shape | null;
  requiredPrimitivesList?: Array<PrimitivesPartialInput$Shape> | null;
  optionalPrimitivesList?: Array<PrimitivesPartialInput$Shape> | null;
};

export const MessagePartialInput$Ref: InputObjectRef<
  MessagePartialInput$Shape
> = builder.inputRef<MessagePartialInput$Shape>("MessagePartialInput")
  .implement(
    {
      fields: (t) => ({
        requiredPrimitives: t.field({
          type: PrimitivesPartialInput$Ref,
          required: false,
          description: "Required.",
          extensions: {
            protobufField: {
              name: "required_primitives",
              typeFullName: "testapis.primitives.Primitives",
            },
          },
        }),
        optionalPrimitives: t.field({
          type: PrimitivesPartialInput$Ref,
          required: false,
          description: "Optional.",
          extensions: {
            protobufField: {
              name: "optional_primitives",
              typeFullName: "testapis.primitives.Primitives",
            },
          },
        }),
        requiredPrimitivesList: t.field({
          type: [PrimitivesPartialInput$Ref],
          required: { list: false, items: true },
          description: "Required.",
          extensions: {
            protobufField: {
              name: "required_primitives_list",
              typeFullName: "testapis.primitives.Primitives",
            },
          },
        }),
        optionalPrimitivesList: t.field({
          type: [PrimitivesPartialInput$Ref],
          required: { list: false, items: true },
          description: "Optional.",
          extensions: {
            protobufField: {
              name: "optional_primitives_list",
              typeFullName: "testapis.primitives.Primitives",
            },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.primitives.Message",
          name: "Message",
          package: "testapis.primitives",
        },
      },
    },
  );

export type PrimitivesInput$Shape = {
  requiredDoubleValue: Primitives["requiredDoubleValue"];
  requiredFloatValue: Primitives["requiredFloatValue"];
  requiredInt32Value: Primitives["requiredInt32Value"];
  requiredInt64Value: Primitives["requiredInt64Value"];
  requiredUint32Value: Primitives["requiredUint32Value"];
  requiredUint64Value: Primitives["requiredUint64Value"];
  requiredSint32Value: Primitives["requiredSint32Value"];
  requiredSint64Value: Primitives["requiredSint64Value"];
  requiredFixed32Value: Primitives["requiredFixed32Value"];
  requiredFixed64Value: Primitives["requiredFixed64Value"];
  requiredSfixed32Value: Primitives["requiredSfixed32Value"];
  requiredSfixed64Value: Primitives["requiredSfixed64Value"];
  requiredBoolValue: Primitives["requiredBoolValue"];
  requiredStringValue: Primitives["requiredStringValue"];
  requiredBytesValue: Primitives["requiredBytesValue"];
  requiredDoubleValues: Primitives["requiredDoubleValues"];
  requiredFloatValues: Primitives["requiredFloatValues"];
  requiredInt32Values: Primitives["requiredInt32Values"];
  requiredInt64Values: Primitives["requiredInt64Values"];
  requiredUint32Values: Primitives["requiredUint32Values"];
  requiredUint64Values: Primitives["requiredUint64Values"];
  requiredSint32Values: Primitives["requiredSint32Values"];
  requiredSint64Values: Primitives["requiredSint64Values"];
  requiredFixed32Values: Primitives["requiredFixed32Values"];
  requiredFixed64Values: Primitives["requiredFixed64Values"];
  requiredSfixed32Values: Primitives["requiredSfixed32Values"];
  requiredSfixed64Values: Primitives["requiredSfixed64Values"];
  requiredBoolValues: Primitives["requiredBoolValues"];
  requiredStringValues: Primitives["requiredStringValues"];
  requiredBytesValues: Primitives["requiredBytesValues"];
};

export const PrimitivesInput$Ref: InputObjectRef<PrimitivesInput$Shape> =
  builder.inputRef<PrimitivesInput$Shape>("PrimitivesInput").implement(
    {
      fields: (t) => ({
        requiredDoubleValue: t.field({
          type: "Float",
          required: true,
          extensions: {
            protobufField: {
              name: "required_double_value",
              typeFullName: "double",
            },
          },
        }),
        requiredFloatValue: t.field({
          type: "Float",
          required: true,
          extensions: {
            protobufField: {
              name: "required_float_value",
              typeFullName: "float",
            },
          },
        }),
        requiredInt32Value: t.field({
          type: "Int",
          required: true,
          extensions: {
            protobufField: {
              name: "required_int32_value",
              typeFullName: "int32",
            },
          },
        }),
        requiredInt64Value: t.field({
          type: "String",
          required: true,
          extensions: {
            protobufField: {
              name: "required_int64_value",
              typeFullName: "int64",
            },
          },
        }),
        requiredUint32Value: t.field({
          type: "Int",
          required: true,
          extensions: {
            protobufField: {
              name: "required_uint32_value",
              typeFullName: "uint32",
            },
          },
        }),
        requiredUint64Value: t.field({
          type: "String",
          required: true,
          extensions: {
            protobufField: {
              name: "required_uint64_value",
              typeFullName: "uint64",
            },
          },
        }),
        requiredSint32Value: t.field({
          type: "Int",
          required: true,
          extensions: {
            protobufField: {
              name: "required_sint32_value",
              typeFullName: "sint32",
            },
          },
        }),
        requiredSint64Value: t.field({
          type: "String",
          required: true,
          extensions: {
            protobufField: {
              name: "required_sint64_value",
              typeFullName: "sint64",
            },
          },
        }),
        requiredFixed32Value: t.field({
          type: "Int",
          required: true,
          extensions: {
            protobufField: {
              name: "required_fixed32_value",
              typeFullName: "fixed32",
            },
          },
        }),
        requiredFixed64Value: t.field({
          type: "String",
          required: true,
          extensions: {
            protobufField: {
              name: "required_fixed64_value",
              typeFullName: "fixed64",
            },
          },
        }),
        requiredSfixed32Value: t.field({
          type: "Int",
          required: true,
          extensions: {
            protobufField: {
              name: "required_sfixed32_value",
              typeFullName: "sfixed32",
            },
          },
        }),
        requiredSfixed64Value: t.field({
          type: "String",
          required: true,
          extensions: {
            protobufField: {
              name: "required_sfixed64_value",
              typeFullName: "sfixed64",
            },
          },
        }),
        requiredBoolValue: t.field({
          type: "Boolean",
          required: true,
          extensions: {
            protobufField: {
              name: "required_bool_value",
              typeFullName: "bool",
            },
          },
        }),
        requiredStringValue: t.field({
          type: "String",
          required: true,
          extensions: {
            protobufField: {
              name: "required_string_value",
              typeFullName: "string",
            },
          },
        }),
        requiredBytesValue: t.field({
          type: "Byte",
          required: true,
          extensions: {
            protobufField: {
              name: "required_bytes_value",
              typeFullName: "bytes",
            },
          },
        }),
        requiredDoubleValues: t.field({
          type: ["Float"],
          required: { list: true, items: true },
          extensions: {
            protobufField: {
              name: "required_double_values",
              typeFullName: "double",
            },
          },
        }),
        requiredFloatValues: t.field({
          type: ["Float"],
          required: { list: true, items: true },
          extensions: {
            protobufField: {
              name: "required_float_values",
              typeFullName: "float",
            },
          },
        }),
        requiredInt32Values: t.field({
          type: ["Int"],
          required: { list: true, items: true },
          extensions: {
            protobufField: {
              name: "required_int32_values",
              typeFullName: "int32",
            },
          },
        }),
        requiredInt64Values: t.field({
          type: ["String"],
          required: { list: true, items: true },
          extensions: {
            protobufField: {
              name: "required_int64_values",
              typeFullName: "int64",
            },
          },
        }),
        requiredUint32Values: t.field({
          type: ["Int"],
          required: { list: true, items: true },
          extensions: {
            protobufField: {
              name: "required_uint32_values",
              typeFullName: "uint32",
            },
          },
        }),
        requiredUint64Values: t.field({
          type: ["String"],
          required: { list: true, items: true },
          extensions: {
            protobufField: {
              name: "required_uint64_values",
              typeFullName: "uint64",
            },
          },
        }),
        requiredSint32Values: t.field({
          type: ["Int"],
          required: { list: true, items: true },
          extensions: {
            protobufField: {
              name: "required_sint32_values",
              typeFullName: "sint32",
            },
          },
        }),
        requiredSint64Values: t.field({
          type: ["String"],
          required: { list: true, items: true },
          extensions: {
            protobufField: {
              name: "required_sint64_values",
              typeFullName: "sint64",
            },
          },
        }),
        requiredFixed32Values: t.field({
          type: ["Int"],
          required: { list: true, items: true },
          extensions: {
            protobufField: {
              name: "required_fixed32_values",
              typeFullName: "fixed32",
            },
          },
        }),
        requiredFixed64Values: t.field({
          type: ["String"],
          required: { list: true, items: true },
          extensions: {
            protobufField: {
              name: "required_fixed64_values",
              typeFullName: "fixed64",
            },
          },
        }),
        requiredSfixed32Values: t.field({
          type: ["Int"],
          required: { list: true, items: true },
          extensions: {
            protobufField: {
              name: "required_sfixed32_values",
              typeFullName: "sfixed32",
            },
          },
        }),
        requiredSfixed64Values: t.field({
          type: ["String"],
          required: { list: true, items: true },
          extensions: {
            protobufField: {
              name: "required_sfixed64_values",
              typeFullName: "sfixed64",
            },
          },
        }),
        requiredBoolValues: t.field({
          type: ["Boolean"],
          required: { list: true, items: true },
          extensions: {
            protobufField: {
              name: "required_bool_values",
              typeFullName: "bool",
            },
          },
        }),
        requiredStringValues: t.field({
          type: ["String"],
          required: { list: true, items: true },
          extensions: {
            protobufField: {
              name: "required_string_values",
              typeFullName: "string",
            },
          },
        }),
        requiredBytesValues: t.field({
          type: ["Byte"],
          required: { list: true, items: true },
          extensions: {
            protobufField: {
              name: "required_bytes_values",
              typeFullName: "bytes",
            },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.primitives.Primitives",
          name: "Primitives",
          package: "testapis.primitives",
        },
      },
    },
  );

export type PrimitivesPartialInput$Shape = {
  requiredDoubleValue?: Primitives["requiredDoubleValue"] | null;
  requiredFloatValue?: Primitives["requiredFloatValue"] | null;
  requiredInt32Value?: Primitives["requiredInt32Value"] | null;
  requiredInt64Value?: Primitives["requiredInt64Value"] | null;
  requiredUint32Value?: Primitives["requiredUint32Value"] | null;
  requiredUint64Value?: Primitives["requiredUint64Value"] | null;
  requiredSint32Value?: Primitives["requiredSint32Value"] | null;
  requiredSint64Value?: Primitives["requiredSint64Value"] | null;
  requiredFixed32Value?: Primitives["requiredFixed32Value"] | null;
  requiredFixed64Value?: Primitives["requiredFixed64Value"] | null;
  requiredSfixed32Value?: Primitives["requiredSfixed32Value"] | null;
  requiredSfixed64Value?: Primitives["requiredSfixed64Value"] | null;
  requiredBoolValue?: Primitives["requiredBoolValue"] | null;
  requiredStringValue?: Primitives["requiredStringValue"] | null;
  requiredBytesValue?: Primitives["requiredBytesValue"] | null;
  requiredDoubleValues?: Primitives["requiredDoubleValues"] | null;
  requiredFloatValues?: Primitives["requiredFloatValues"] | null;
  requiredInt32Values?: Primitives["requiredInt32Values"] | null;
  requiredInt64Values?: Primitives["requiredInt64Values"] | null;
  requiredUint32Values?: Primitives["requiredUint32Values"] | null;
  requiredUint64Values?: Primitives["requiredUint64Values"] | null;
  requiredSint32Values?: Primitives["requiredSint32Values"] | null;
  requiredSint64Values?: Primitives["requiredSint64Values"] | null;
  requiredFixed32Values?: Primitives["requiredFixed32Values"] | null;
  requiredFixed64Values?: Primitives["requiredFixed64Values"] | null;
  requiredSfixed32Values?: Primitives["requiredSfixed32Values"] | null;
  requiredSfixed64Values?: Primitives["requiredSfixed64Values"] | null;
  requiredBoolValues?: Primitives["requiredBoolValues"] | null;
  requiredStringValues?: Primitives["requiredStringValues"] | null;
  requiredBytesValues?: Primitives["requiredBytesValues"] | null;
};

export const PrimitivesPartialInput$Ref: InputObjectRef<
  PrimitivesPartialInput$Shape
> = builder.inputRef<PrimitivesPartialInput$Shape>("PrimitivesPartialInput")
  .implement(
    {
      fields: (t) => ({
        requiredDoubleValue: t.field({
          type: "Float",
          required: false,
          extensions: {
            protobufField: {
              name: "required_double_value",
              typeFullName: "double",
            },
          },
        }),
        requiredFloatValue: t.field({
          type: "Float",
          required: false,
          extensions: {
            protobufField: {
              name: "required_float_value",
              typeFullName: "float",
            },
          },
        }),
        requiredInt32Value: t.field({
          type: "Int",
          required: false,
          extensions: {
            protobufField: {
              name: "required_int32_value",
              typeFullName: "int32",
            },
          },
        }),
        requiredInt64Value: t.field({
          type: "String",
          required: false,
          extensions: {
            protobufField: {
              name: "required_int64_value",
              typeFullName: "int64",
            },
          },
        }),
        requiredUint32Value: t.field({
          type: "Int",
          required: false,
          extensions: {
            protobufField: {
              name: "required_uint32_value",
              typeFullName: "uint32",
            },
          },
        }),
        requiredUint64Value: t.field({
          type: "String",
          required: false,
          extensions: {
            protobufField: {
              name: "required_uint64_value",
              typeFullName: "uint64",
            },
          },
        }),
        requiredSint32Value: t.field({
          type: "Int",
          required: false,
          extensions: {
            protobufField: {
              name: "required_sint32_value",
              typeFullName: "sint32",
            },
          },
        }),
        requiredSint64Value: t.field({
          type: "String",
          required: false,
          extensions: {
            protobufField: {
              name: "required_sint64_value",
              typeFullName: "sint64",
            },
          },
        }),
        requiredFixed32Value: t.field({
          type: "Int",
          required: false,
          extensions: {
            protobufField: {
              name: "required_fixed32_value",
              typeFullName: "fixed32",
            },
          },
        }),
        requiredFixed64Value: t.field({
          type: "String",
          required: false,
          extensions: {
            protobufField: {
              name: "required_fixed64_value",
              typeFullName: "fixed64",
            },
          },
        }),
        requiredSfixed32Value: t.field({
          type: "Int",
          required: false,
          extensions: {
            protobufField: {
              name: "required_sfixed32_value",
              typeFullName: "sfixed32",
            },
          },
        }),
        requiredSfixed64Value: t.field({
          type: "String",
          required: false,
          extensions: {
            protobufField: {
              name: "required_sfixed64_value",
              typeFullName: "sfixed64",
            },
          },
        }),
        requiredBoolValue: t.field({
          type: "Boolean",
          required: false,
          extensions: {
            protobufField: {
              name: "required_bool_value",
              typeFullName: "bool",
            },
          },
        }),
        requiredStringValue: t.field({
          type: "String",
          required: false,
          extensions: {
            protobufField: {
              name: "required_string_value",
              typeFullName: "string",
            },
          },
        }),
        requiredBytesValue: t.field({
          type: "Byte",
          required: false,
          extensions: {
            protobufField: {
              name: "required_bytes_value",
              typeFullName: "bytes",
            },
          },
        }),
        requiredDoubleValues: t.field({
          type: ["Float"],
          required: { list: false, items: true },
          extensions: {
            protobufField: {
              name: "required_double_values",
              typeFullName: "double",
            },
          },
        }),
        requiredFloatValues: t.field({
          type: ["Float"],
          required: { list: false, items: true },
          extensions: {
            protobufField: {
              name: "required_float_values",
              typeFullName: "float",
            },
          },
        }),
        requiredInt32Values: t.field({
          type: ["Int"],
          required: { list: false, items: true },
          extensions: {
            protobufField: {
              name: "required_int32_values",
              typeFullName: "int32",
            },
          },
        }),
        requiredInt64Values: t.field({
          type: ["String"],
          required: { list: false, items: true },
          extensions: {
            protobufField: {
              name: "required_int64_values",
              typeFullName: "int64",
            },
          },
        }),
        requiredUint32Values: t.field({
          type: ["Int"],
          required: { list: false, items: true },
          extensions: {
            protobufField: {
              name: "required_uint32_values",
              typeFullName: "uint32",
            },
          },
        }),
        requiredUint64Values: t.field({
          type: ["String"],
          required: { list: false, items: true },
          extensions: {
            protobufField: {
              name: "required_uint64_values",
              typeFullName: "uint64",
            },
          },
        }),
        requiredSint32Values: t.field({
          type: ["Int"],
          required: { list: false, items: true },
          extensions: {
            protobufField: {
              name: "required_sint32_values",
              typeFullName: "sint32",
            },
          },
        }),
        requiredSint64Values: t.field({
          type: ["String"],
          required: { list: false, items: true },
          extensions: {
            protobufField: {
              name: "required_sint64_values",
              typeFullName: "sint64",
            },
          },
        }),
        requiredFixed32Values: t.field({
          type: ["Int"],
          required: { list: false, items: true },
          extensions: {
            protobufField: {
              name: "required_fixed32_values",
              typeFullName: "fixed32",
            },
          },
        }),
        requiredFixed64Values: t.field({
          type: ["String"],
          required: { list: false, items: true },
          extensions: {
            protobufField: {
              name: "required_fixed64_values",
              typeFullName: "fixed64",
            },
          },
        }),
        requiredSfixed32Values: t.field({
          type: ["Int"],
          required: { list: false, items: true },
          extensions: {
            protobufField: {
              name: "required_sfixed32_values",
              typeFullName: "sfixed32",
            },
          },
        }),
        requiredSfixed64Values: t.field({
          type: ["String"],
          required: { list: false, items: true },
          extensions: {
            protobufField: {
              name: "required_sfixed64_values",
              typeFullName: "sfixed64",
            },
          },
        }),
        requiredBoolValues: t.field({
          type: ["Boolean"],
          required: { list: false, items: true },
          extensions: {
            protobufField: {
              name: "required_bool_values",
              typeFullName: "bool",
            },
          },
        }),
        requiredStringValues: t.field({
          type: ["String"],
          required: { list: false, items: true },
          extensions: {
            protobufField: {
              name: "required_string_values",
              typeFullName: "string",
            },
          },
        }),
        requiredBytesValues: t.field({
          type: ["Byte"],
          required: { list: false, items: true },
          extensions: {
            protobufField: {
              name: "required_bytes_values",
              typeFullName: "bytes",
            },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.primitives.Primitives",
          name: "Primitives",
          package: "testapis.primitives",
        },
      },
    },
  );
",
    "name": "testapis/primitives/primitives.pb.pothos.ts",
  },
]
`;

exports[`'testapis.primitives' > generates files by plugin 'without import prefix' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/primitives/primitives.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { builder } from "../../builder";
import { Message, Primitives } from "./testapis/primitives/primitives";

export const Message$Ref = builder.objectRef<Message>("Message");
builder.objectType(Message$Ref, {
  name: "Message",
  fields: (t) => ({
    requiredPrimitives: t.field({
      type: Primitives$Ref,
      nullable: false,
      description: "Required.",
      resolve: (source) => {
        return source.requiredPrimitives!;
      },
      extensions: {
        protobufField: {
          name: "required_primitives",
          typeFullName: "testapis.primitives.Primitives",
        },
      },
    }),
    optionalPrimitives: t.expose("optionalPrimitives", {
      type: Primitives$Ref,
      nullable: true,
      description: "Optional.",
      extensions: {
        protobufField: {
          name: "optional_primitives",
          typeFullName: "testapis.primitives.Primitives",
        },
      },
    }),
    requiredPrimitivesList: t.field({
      type: [Primitives$Ref],
      nullable: { list: false, items: false },
      description: "Required.",
      resolve: (source) => {
        return source.requiredPrimitivesList!;
      },
      extensions: {
        protobufField: {
          name: "required_primitives_list",
          typeFullName: "testapis.primitives.Primitives",
        },
      },
    }),
    optionalPrimitivesList: t.expose("optionalPrimitivesList", {
      type: [Primitives$Ref],
      nullable: { list: true, items: false },
      description: "Optional.",
      extensions: {
        protobufField: {
          name: "optional_primitives_list",
          typeFullName: "testapis.primitives.Primitives",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as Message | { $type: string & {}; }).$type ===
      "testapis.primitives.Message";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.primitives.Message",
      name: "Message",
      package: "testapis.primitives",
    },
  },
});

export const Primitives$Ref = builder.objectRef<Primitives>("Primitives");
builder.objectType(Primitives$Ref, {
  name: "Primitives",
  fields: (t) => ({
    requiredDoubleValue: t.expose("requiredDoubleValue", {
      type: "Float",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_double_value",
          typeFullName: "double",
        },
      },
    }),
    requiredFloatValue: t.expose("requiredFloatValue", {
      type: "Float",
      nullable: false,
      extensions: {
        protobufField: { name: "required_float_value", typeFullName: "float" },
      },
    }),
    requiredInt32Value: t.expose("requiredInt32Value", {
      type: "Int",
      nullable: false,
      extensions: {
        protobufField: { name: "required_int32_value", typeFullName: "int32" },
      },
    }),
    requiredInt64Value: t.expose("requiredInt64Value", {
      type: "String",
      nullable: false,
      extensions: {
        protobufField: { name: "required_int64_value", typeFullName: "int64" },
      },
    }),
    requiredUint32Value: t.expose("requiredUint32Value", {
      type: "Int",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_uint32_value",
          typeFullName: "uint32",
        },
      },
    }),
    requiredUint64Value: t.expose("requiredUint64Value", {
      type: "String",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_uint64_value",
          typeFullName: "uint64",
        },
      },
    }),
    requiredSint32Value: t.expose("requiredSint32Value", {
      type: "Int",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_sint32_value",
          typeFullName: "sint32",
        },
      },
    }),
    requiredSint64Value: t.expose("requiredSint64Value", {
      type: "String",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_sint64_value",
          typeFullName: "sint64",
        },
      },
    }),
    requiredFixed32Value: t.expose("requiredFixed32Value", {
      type: "Int",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_fixed32_value",
          typeFullName: "fixed32",
        },
      },
    }),
    requiredFixed64Value: t.expose("requiredFixed64Value", {
      type: "String",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_fixed64_value",
          typeFullName: "fixed64",
        },
      },
    }),
    requiredSfixed32Value: t.expose("requiredSfixed32Value", {
      type: "Int",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_sfixed32_value",
          typeFullName: "sfixed32",
        },
      },
    }),
    requiredSfixed64Value: t.expose("requiredSfixed64Value", {
      type: "String",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_sfixed64_value",
          typeFullName: "sfixed64",
        },
      },
    }),
    requiredBoolValue: t.expose("requiredBoolValue", {
      type: "Boolean",
      nullable: false,
      extensions: {
        protobufField: { name: "required_bool_value", typeFullName: "bool" },
      },
    }),
    requiredStringValue: t.expose("requiredStringValue", {
      type: "String",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_string_value",
          typeFullName: "string",
        },
      },
    }),
    requiredBytesValue: t.field({
      type: "Byte",
      nullable: false,
      resolve: (source) => {
        return Buffer.from(source.requiredBytesValue);
      },
      extensions: {
        protobufField: { name: "required_bytes_value", typeFullName: "bytes" },
      },
    }),
    requiredDoubleValues: t.expose("requiredDoubleValues", {
      type: ["Float"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: {
          name: "required_double_values",
          typeFullName: "double",
        },
      },
    }),
    requiredFloatValues: t.expose("requiredFloatValues", {
      type: ["Float"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: { name: "required_float_values", typeFullName: "float" },
      },
    }),
    requiredInt32Values: t.expose("requiredInt32Values", {
      type: ["Int"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: { name: "required_int32_values", typeFullName: "int32" },
      },
    }),
    requiredInt64Values: t.expose("requiredInt64Values", {
      type: ["String"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: { name: "required_int64_values", typeFullName: "int64" },
      },
    }),
    requiredUint32Values: t.expose("requiredUint32Values", {
      type: ["Int"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: {
          name: "required_uint32_values",
          typeFullName: "uint32",
        },
      },
    }),
    requiredUint64Values: t.expose("requiredUint64Values", {
      type: ["String"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: {
          name: "required_uint64_values",
          typeFullName: "uint64",
        },
      },
    }),
    requiredSint32Values: t.expose("requiredSint32Values", {
      type: ["Int"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: {
          name: "required_sint32_values",
          typeFullName: "sint32",
        },
      },
    }),
    requiredSint64Values: t.expose("requiredSint64Values", {
      type: ["String"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: {
          name: "required_sint64_values",
          typeFullName: "sint64",
        },
      },
    }),
    requiredFixed32Values: t.expose("requiredFixed32Values", {
      type: ["Int"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: {
          name: "required_fixed32_values",
          typeFullName: "fixed32",
        },
      },
    }),
    requiredFixed64Values: t.expose("requiredFixed64Values", {
      type: ["String"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: {
          name: "required_fixed64_values",
          typeFullName: "fixed64",
        },
      },
    }),
    requiredSfixed32Values: t.expose("requiredSfixed32Values", {
      type: ["Int"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: {
          name: "required_sfixed32_values",
          typeFullName: "sfixed32",
        },
      },
    }),
    requiredSfixed64Values: t.expose("requiredSfixed64Values", {
      type: ["String"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: {
          name: "required_sfixed64_values",
          typeFullName: "sfixed64",
        },
      },
    }),
    requiredBoolValues: t.expose("requiredBoolValues", {
      type: ["Boolean"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: { name: "required_bool_values", typeFullName: "bool" },
      },
    }),
    requiredStringValues: t.expose("requiredStringValues", {
      type: ["String"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: {
          name: "required_string_values",
          typeFullName: "string",
        },
      },
    }),
    requiredBytesValues: t.field({
      type: ["Byte"],
      nullable: { list: false, items: false },
      resolve: (source) => {
        return source.requiredBytesValues.map((v) => Buffer.from(v));
      },
      extensions: {
        protobufField: { name: "required_bytes_values", typeFullName: "bytes" },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as Primitives | { $type: string & {}; }).$type ===
      "testapis.primitives.Primitives";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.primitives.Primitives",
      name: "Primitives",
      package: "testapis.primitives",
    },
  },
});

export type MessageInput$Shape = {
  requiredPrimitives: PrimitivesInput$Shape;
  optionalPrimitives?: PrimitivesInput$Shape | null;
  requiredPrimitivesList: Array<PrimitivesInput$Shape>;
  optionalPrimitivesList?: Array<PrimitivesInput$Shape> | null;
};

export const MessageInput$Ref: InputObjectRef<MessageInput$Shape> = builder
  .inputRef<MessageInput$Shape>("MessageInput").implement(
    {
      fields: (t) => ({
        requiredPrimitives: t.field({
          type: PrimitivesInput$Ref,
          required: true,
          description: "Required.",
          extensions: {
            protobufField: {
              name: "required_primitives",
              typeFullName: "testapis.primitives.Primitives",
            },
          },
        }),
        optionalPrimitives: t.field({
          type: PrimitivesInput$Ref,
          required: false,
          description: "Optional.",
          extensions: {
            protobufField: {
              name: "optional_primitives",
              typeFullName: "testapis.primitives.Primitives",
            },
          },
        }),
        requiredPrimitivesList: t.field({
          type: [PrimitivesInput$Ref],
          required: { list: true, items: true },
          description: "Required.",
          extensions: {
            protobufField: {
              name: "required_primitives_list",
              typeFullName: "testapis.primitives.Primitives",
            },
          },
        }),
        optionalPrimitivesList: t.field({
          type: [PrimitivesInput$Ref],
          required: { list: false, items: true },
          description: "Optional.",
          extensions: {
            protobufField: {
              name: "optional_primitives_list",
              typeFullName: "testapis.primitives.Primitives",
            },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.primitives.Message",
          name: "Message",
          package: "testapis.primitives",
        },
      },
    },
  );

export type PrimitivesInput$Shape = {
  requiredDoubleValue: Primitives["requiredDoubleValue"];
  requiredFloatValue: Primitives["requiredFloatValue"];
  requiredInt32Value: Primitives["requiredInt32Value"];
  requiredInt64Value: Primitives["requiredInt64Value"];
  requiredUint32Value: Primitives["requiredUint32Value"];
  requiredUint64Value: Primitives["requiredUint64Value"];
  requiredSint32Value: Primitives["requiredSint32Value"];
  requiredSint64Value: Primitives["requiredSint64Value"];
  requiredFixed32Value: Primitives["requiredFixed32Value"];
  requiredFixed64Value: Primitives["requiredFixed64Value"];
  requiredSfixed32Value: Primitives["requiredSfixed32Value"];
  requiredSfixed64Value: Primitives["requiredSfixed64Value"];
  requiredBoolValue: Primitives["requiredBoolValue"];
  requiredStringValue: Primitives["requiredStringValue"];
  requiredBytesValue: Primitives["requiredBytesValue"];
  requiredDoubleValues: Primitives["requiredDoubleValues"];
  requiredFloatValues: Primitives["requiredFloatValues"];
  requiredInt32Values: Primitives["requiredInt32Values"];
  requiredInt64Values: Primitives["requiredInt64Values"];
  requiredUint32Values: Primitives["requiredUint32Values"];
  requiredUint64Values: Primitives["requiredUint64Values"];
  requiredSint32Values: Primitives["requiredSint32Values"];
  requiredSint64Values: Primitives["requiredSint64Values"];
  requiredFixed32Values: Primitives["requiredFixed32Values"];
  requiredFixed64Values: Primitives["requiredFixed64Values"];
  requiredSfixed32Values: Primitives["requiredSfixed32Values"];
  requiredSfixed64Values: Primitives["requiredSfixed64Values"];
  requiredBoolValues: Primitives["requiredBoolValues"];
  requiredStringValues: Primitives["requiredStringValues"];
  requiredBytesValues: Primitives["requiredBytesValues"];
};

export const PrimitivesInput$Ref: InputObjectRef<PrimitivesInput$Shape> =
  builder.inputRef<PrimitivesInput$Shape>("PrimitivesInput").implement(
    {
      fields: (t) => ({
        requiredDoubleValue: t.field({
          type: "Float",
          required: true,
          extensions: {
            protobufField: {
              name: "required_double_value",
              typeFullName: "double",
            },
          },
        }),
        requiredFloatValue: t.field({
          type: "Float",
          required: true,
          extensions: {
            protobufField: {
              name: "required_float_value",
              typeFullName: "float",
            },
          },
        }),
        requiredInt32Value: t.field({
          type: "Int",
          required: true,
          extensions: {
            protobufField: {
              name: "required_int32_value",
              typeFullName: "int32",
            },
          },
        }),
        requiredInt64Value: t.field({
          type: "String",
          required: true,
          extensions: {
            protobufField: {
              name: "required_int64_value",
              typeFullName: "int64",
            },
          },
        }),
        requiredUint32Value: t.field({
          type: "Int",
          required: true,
          extensions: {
            protobufField: {
              name: "required_uint32_value",
              typeFullName: "uint32",
            },
          },
        }),
        requiredUint64Value: t.field({
          type: "String",
          required: true,
          extensions: {
            protobufField: {
              name: "required_uint64_value",
              typeFullName: "uint64",
            },
          },
        }),
        requiredSint32Value: t.field({
          type: "Int",
          required: true,
          extensions: {
            protobufField: {
              name: "required_sint32_value",
              typeFullName: "sint32",
            },
          },
        }),
        requiredSint64Value: t.field({
          type: "String",
          required: true,
          extensions: {
            protobufField: {
              name: "required_sint64_value",
              typeFullName: "sint64",
            },
          },
        }),
        requiredFixed32Value: t.field({
          type: "Int",
          required: true,
          extensions: {
            protobufField: {
              name: "required_fixed32_value",
              typeFullName: "fixed32",
            },
          },
        }),
        requiredFixed64Value: t.field({
          type: "String",
          required: true,
          extensions: {
            protobufField: {
              name: "required_fixed64_value",
              typeFullName: "fixed64",
            },
          },
        }),
        requiredSfixed32Value: t.field({
          type: "Int",
          required: true,
          extensions: {
            protobufField: {
              name: "required_sfixed32_value",
              typeFullName: "sfixed32",
            },
          },
        }),
        requiredSfixed64Value: t.field({
          type: "String",
          required: true,
          extensions: {
            protobufField: {
              name: "required_sfixed64_value",
              typeFullName: "sfixed64",
            },
          },
        }),
        requiredBoolValue: t.field({
          type: "Boolean",
          required: true,
          extensions: {
            protobufField: {
              name: "required_bool_value",
              typeFullName: "bool",
            },
          },
        }),
        requiredStringValue: t.field({
          type: "String",
          required: true,
          extensions: {
            protobufField: {
              name: "required_string_value",
              typeFullName: "string",
            },
          },
        }),
        requiredBytesValue: t.field({
          type: "Byte",
          required: true,
          extensions: {
            protobufField: {
              name: "required_bytes_value",
              typeFullName: "bytes",
            },
          },
        }),
        requiredDoubleValues: t.field({
          type: ["Float"],
          required: { list: true, items: true },
          extensions: {
            protobufField: {
              name: "required_double_values",
              typeFullName: "double",
            },
          },
        }),
        requiredFloatValues: t.field({
          type: ["Float"],
          required: { list: true, items: true },
          extensions: {
            protobufField: {
              name: "required_float_values",
              typeFullName: "float",
            },
          },
        }),
        requiredInt32Values: t.field({
          type: ["Int"],
          required: { list: true, items: true },
          extensions: {
            protobufField: {
              name: "required_int32_values",
              typeFullName: "int32",
            },
          },
        }),
        requiredInt64Values: t.field({
          type: ["String"],
          required: { list: true, items: true },
          extensions: {
            protobufField: {
              name: "required_int64_values",
              typeFullName: "int64",
            },
          },
        }),
        requiredUint32Values: t.field({
          type: ["Int"],
          required: { list: true, items: true },
          extensions: {
            protobufField: {
              name: "required_uint32_values",
              typeFullName: "uint32",
            },
          },
        }),
        requiredUint64Values: t.field({
          type: ["String"],
          required: { list: true, items: true },
          extensions: {
            protobufField: {
              name: "required_uint64_values",
              typeFullName: "uint64",
            },
          },
        }),
        requiredSint32Values: t.field({
          type: ["Int"],
          required: { list: true, items: true },
          extensions: {
            protobufField: {
              name: "required_sint32_values",
              typeFullName: "sint32",
            },
          },
        }),
        requiredSint64Values: t.field({
          type: ["String"],
          required: { list: true, items: true },
          extensions: {
            protobufField: {
              name: "required_sint64_values",
              typeFullName: "sint64",
            },
          },
        }),
        requiredFixed32Values: t.field({
          type: ["Int"],
          required: { list: true, items: true },
          extensions: {
            protobufField: {
              name: "required_fixed32_values",
              typeFullName: "fixed32",
            },
          },
        }),
        requiredFixed64Values: t.field({
          type: ["String"],
          required: { list: true, items: true },
          extensions: {
            protobufField: {
              name: "required_fixed64_values",
              typeFullName: "fixed64",
            },
          },
        }),
        requiredSfixed32Values: t.field({
          type: ["Int"],
          required: { list: true, items: true },
          extensions: {
            protobufField: {
              name: "required_sfixed32_values",
              typeFullName: "sfixed32",
            },
          },
        }),
        requiredSfixed64Values: t.field({
          type: ["String"],
          required: { list: true, items: true },
          extensions: {
            protobufField: {
              name: "required_sfixed64_values",
              typeFullName: "sfixed64",
            },
          },
        }),
        requiredBoolValues: t.field({
          type: ["Boolean"],
          required: { list: true, items: true },
          extensions: {
            protobufField: {
              name: "required_bool_values",
              typeFullName: "bool",
            },
          },
        }),
        requiredStringValues: t.field({
          type: ["String"],
          required: { list: true, items: true },
          extensions: {
            protobufField: {
              name: "required_string_values",
              typeFullName: "string",
            },
          },
        }),
        requiredBytesValues: t.field({
          type: ["Byte"],
          required: { list: true, items: true },
          extensions: {
            protobufField: {
              name: "required_bytes_values",
              typeFullName: "bytes",
            },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.primitives.Primitives",
          name: "Primitives",
          package: "testapis.primitives",
        },
      },
    },
  );
",
    "name": "testapis/primitives/primitives.pb.pothos.ts",
  },
]
`;

exports[`'testapis.proto3_optional' > generates files by plugin 'with import prefix' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/proto3_optional/proto3_optional.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { Message } from "@testapis/ts-proto/testapis/proto3_optional/proto3_optional";
import { builder } from "../../builder";

export const Message$Ref = builder.objectRef<Message>("Message");
builder.objectType(Message$Ref, {
  name: "Message",
  fields: (t) => ({
    requiredStringValue: t.expose("requiredStringValue", {
      type: "String",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_string_value",
          typeFullName: "string",
        },
      },
    }),
    optionalStringValue: t.expose("optionalStringValue", {
      type: "String",
      nullable: true,
      extensions: {
        protobufField: {
          name: "optional_string_value",
          typeFullName: "string",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as Message | { $type: string & {}; }).$type ===
      "testapis.proto3_optional.Message";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.proto3_optional.Message",
      name: "Message",
      package: "testapis.proto3_optional",
    },
  },
});

export type MessageInput$Shape = {
  requiredStringValue: Message["requiredStringValue"];
  optionalStringValue?: Message["optionalStringValue"] | null;
};

export const MessageInput$Ref: InputObjectRef<MessageInput$Shape> = builder
  .inputRef<MessageInput$Shape>("MessageInput").implement(
    {
      fields: (t) => ({
        requiredStringValue: t.field({
          type: "String",
          required: true,
          extensions: {
            protobufField: {
              name: "required_string_value",
              typeFullName: "string",
            },
          },
        }),
        optionalStringValue: t.field({
          type: "String",
          required: false,
          extensions: {
            protobufField: {
              name: "optional_string_value",
              typeFullName: "string",
            },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.proto3_optional.Message",
          name: "Message",
          package: "testapis.proto3_optional",
        },
      },
    },
  );
",
    "name": "testapis/proto3_optional/proto3_optional.pb.pothos.ts",
  },
]
`;

exports[`'testapis.proto3_optional' > generates files by plugin 'with partial inputs' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/proto3_optional/proto3_optional.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { Message } from "@testapis/ts-proto/testapis/proto3_optional/proto3_optional";
import { builder } from "../../builder";

export const Message$Ref = builder.objectRef<Message>("Message");
builder.objectType(Message$Ref, {
  name: "Message",
  fields: (t) => ({
    requiredStringValue: t.expose("requiredStringValue", {
      type: "String",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_string_value",
          typeFullName: "string",
        },
      },
    }),
    optionalStringValue: t.expose("optionalStringValue", {
      type: "String",
      nullable: true,
      extensions: {
        protobufField: {
          name: "optional_string_value",
          typeFullName: "string",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as Message | { $type: string & {}; }).$type ===
      "testapis.proto3_optional.Message";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.proto3_optional.Message",
      name: "Message",
      package: "testapis.proto3_optional",
    },
  },
});

export type MessageInput$Shape = {
  requiredStringValue: Message["requiredStringValue"];
  optionalStringValue?: Message["optionalStringValue"] | null;
};

export const MessageInput$Ref: InputObjectRef<MessageInput$Shape> = builder
  .inputRef<MessageInput$Shape>("MessageInput").implement(
    {
      fields: (t) => ({
        requiredStringValue: t.field({
          type: "String",
          required: true,
          extensions: {
            protobufField: {
              name: "required_string_value",
              typeFullName: "string",
            },
          },
        }),
        optionalStringValue: t.field({
          type: "String",
          required: false,
          extensions: {
            protobufField: {
              name: "optional_string_value",
              typeFullName: "string",
            },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.proto3_optional.Message",
          name: "Message",
          package: "testapis.proto3_optional",
        },
      },
    },
  );

export type MessagePartialInput$Shape = {
  requiredStringValue?: Message["requiredStringValue"] | null;
  optionalStringValue?: Message["optionalStringValue"] | null;
};

export const MessagePartialInput$Ref: InputObjectRef<
  MessagePartialInput$Shape
> = builder.inputRef<MessagePartialInput$Shape>("MessagePartialInput")
  .implement(
    {
      fields: (t) => ({
        requiredStringValue: t.field({
          type: "String",
          required: false,
          extensions: {
            protobufField: {
              name: "required_string_value",
              typeFullName: "string",
            },
          },
        }),
        optionalStringValue: t.field({
          type: "String",
          required: false,
          extensions: {
            protobufField: {
              name: "optional_string_value",
              typeFullName: "string",
            },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.proto3_optional.Message",
          name: "Message",
          package: "testapis.proto3_optional",
        },
      },
    },
  );
",
    "name": "testapis/proto3_optional/proto3_optional.pb.pothos.ts",
  },
]
`;

exports[`'testapis.proto3_optional' > generates files by plugin 'without import prefix' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/proto3_optional/proto3_optional.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { builder } from "../../builder";
import { Message } from "./testapis/proto3_optional/proto3_optional";

export const Message$Ref = builder.objectRef<Message>("Message");
builder.objectType(Message$Ref, {
  name: "Message",
  fields: (t) => ({
    requiredStringValue: t.expose("requiredStringValue", {
      type: "String",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_string_value",
          typeFullName: "string",
        },
      },
    }),
    optionalStringValue: t.expose("optionalStringValue", {
      type: "String",
      nullable: true,
      extensions: {
        protobufField: {
          name: "optional_string_value",
          typeFullName: "string",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as Message | { $type: string & {}; }).$type ===
      "testapis.proto3_optional.Message";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.proto3_optional.Message",
      name: "Message",
      package: "testapis.proto3_optional",
    },
  },
});

export type MessageInput$Shape = {
  requiredStringValue: Message["requiredStringValue"];
  optionalStringValue?: Message["optionalStringValue"] | null;
};

export const MessageInput$Ref: InputObjectRef<MessageInput$Shape> = builder
  .inputRef<MessageInput$Shape>("MessageInput").implement(
    {
      fields: (t) => ({
        requiredStringValue: t.field({
          type: "String",
          required: true,
          extensions: {
            protobufField: {
              name: "required_string_value",
              typeFullName: "string",
            },
          },
        }),
        optionalStringValue: t.field({
          type: "String",
          required: false,
          extensions: {
            protobufField: {
              name: "optional_string_value",
              typeFullName: "string",
            },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.proto3_optional.Message",
          name: "Message",
          package: "testapis.proto3_optional",
        },
      },
    },
  );
",
    "name": "testapis/proto3_optional/proto3_optional.pb.pothos.ts",
  },
]
`;

exports[`'testapis.wktypes' > generates files by plugin 'with import prefix' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/wktypes/well_known_types.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { Message } from "@testapis/ts-proto/testapis/wktypes/well_known_types";
import { builder } from "../../builder";

export const Message$Ref = builder.objectRef<Message>("Message");
builder.objectType(Message$Ref, {
  name: "Message",
  fields: (t) => ({
    timestamp: t.expose("timestamp", {
      type: "DateTime",
      nullable: true,
      extensions: {
        protobufField: {
          name: "timestamp",
          typeFullName: "google.protobuf.Timestamp",
        },
      },
    }),
    int32Value: t.expose("int32Value", {
      type: "Int",
      nullable: true,
      extensions: {
        protobufField: {
          name: "int32_value",
          typeFullName: "google.protobuf.Int32Value",
        },
      },
    }),
    int64Value: t.expose("int64Value", {
      type: "String",
      nullable: true,
      extensions: {
        protobufField: {
          name: "int64_value",
          typeFullName: "google.protobuf.Int64Value",
        },
      },
    }),
    uint32Value: t.expose("uint32Value", {
      type: "Int",
      nullable: true,
      extensions: {
        protobufField: {
          name: "uint32_value",
          typeFullName: "google.protobuf.UInt32Value",
        },
      },
    }),
    uint64Value: t.expose("uint64Value", {
      type: "String",
      nullable: true,
      extensions: {
        protobufField: {
          name: "uint64_value",
          typeFullName: "google.protobuf.UInt64Value",
        },
      },
    }),
    floatValue: t.expose("floatValue", {
      type: "Float",
      nullable: true,
      extensions: {
        protobufField: {
          name: "float_value",
          typeFullName: "google.protobuf.FloatValue",
        },
      },
    }),
    doubleValue: t.expose("doubleValue", {
      type: "Float",
      nullable: true,
      extensions: {
        protobufField: {
          name: "double_value",
          typeFullName: "google.protobuf.DoubleValue",
        },
      },
    }),
    boolValue: t.expose("boolValue", {
      type: "Boolean",
      nullable: true,
      extensions: {
        protobufField: {
          name: "bool_value",
          typeFullName: "google.protobuf.BoolValue",
        },
      },
    }),
    stringValue: t.expose("stringValue", {
      type: "String",
      nullable: true,
      extensions: {
        protobufField: {
          name: "string_value",
          typeFullName: "google.protobuf.StringValue",
        },
      },
    }),
    bytesValue: t.field({
      type: "Byte",
      nullable: true,
      resolve: (source) => {
        return source.bytesValue == null
          ? null
          : Buffer.from(source.bytesValue);
      },
      extensions: {
        protobufField: {
          name: "bytes_value",
          typeFullName: "google.protobuf.BytesValue",
        },
      },
    }),
    requiredTimestamp: t.field({
      type: "DateTime",
      nullable: false,
      description: "Required.",
      resolve: (source) => {
        return source.requiredTimestamp!;
      },
      extensions: {
        protobufField: {
          name: "required_timestamp",
          typeFullName: "google.protobuf.Timestamp",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as Message | { $type: string & {}; }).$type ===
      "testapis.wktypes.Message";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.wktypes.Message",
      name: "Message",
      package: "testapis.wktypes",
    },
  },
});

export type MessageInput$Shape = {
  timestamp?: Message["timestamp"] | null;
  int32Value?: Message["int32Value"] | null;
  int64Value?: Message["int64Value"] | null;
  uint32Value?: Message["uint32Value"] | null;
  uint64Value?: Message["uint64Value"] | null;
  floatValue?: Message["floatValue"] | null;
  doubleValue?: Message["doubleValue"] | null;
  boolValue?: Message["boolValue"] | null;
  stringValue?: Message["stringValue"] | null;
  bytesValue?: Message["bytesValue"] | null;
  requiredTimestamp: NonNullable<Message["requiredTimestamp"]>;
};

export const MessageInput$Ref: InputObjectRef<MessageInput$Shape> = builder
  .inputRef<MessageInput$Shape>("MessageInput").implement(
    {
      fields: (t) => ({
        timestamp: t.field({
          type: "DateTime",
          required: false,
          extensions: {
            protobufField: {
              name: "timestamp",
              typeFullName: "google.protobuf.Timestamp",
            },
          },
        }),
        int32Value: t.field({
          type: "Int",
          required: false,
          extensions: {
            protobufField: {
              name: "int32_value",
              typeFullName: "google.protobuf.Int32Value",
            },
          },
        }),
        int64Value: t.field({
          type: "String",
          required: false,
          extensions: {
            protobufField: {
              name: "int64_value",
              typeFullName: "google.protobuf.Int64Value",
            },
          },
        }),
        uint32Value: t.field({
          type: "Int",
          required: false,
          extensions: {
            protobufField: {
              name: "uint32_value",
              typeFullName: "google.protobuf.UInt32Value",
            },
          },
        }),
        uint64Value: t.field({
          type: "String",
          required: false,
          extensions: {
            protobufField: {
              name: "uint64_value",
              typeFullName: "google.protobuf.UInt64Value",
            },
          },
        }),
        floatValue: t.field({
          type: "Float",
          required: false,
          extensions: {
            protobufField: {
              name: "float_value",
              typeFullName: "google.protobuf.FloatValue",
            },
          },
        }),
        doubleValue: t.field({
          type: "Float",
          required: false,
          extensions: {
            protobufField: {
              name: "double_value",
              typeFullName: "google.protobuf.DoubleValue",
            },
          },
        }),
        boolValue: t.field({
          type: "Boolean",
          required: false,
          extensions: {
            protobufField: {
              name: "bool_value",
              typeFullName: "google.protobuf.BoolValue",
            },
          },
        }),
        stringValue: t.field({
          type: "String",
          required: false,
          extensions: {
            protobufField: {
              name: "string_value",
              typeFullName: "google.protobuf.StringValue",
            },
          },
        }),
        bytesValue: t.field({
          type: "Byte",
          required: false,
          extensions: {
            protobufField: {
              name: "bytes_value",
              typeFullName: "google.protobuf.BytesValue",
            },
          },
        }),
        requiredTimestamp: t.field({
          type: "DateTime",
          required: true,
          description: "Required.",
          extensions: {
            protobufField: {
              name: "required_timestamp",
              typeFullName: "google.protobuf.Timestamp",
            },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.wktypes.Message",
          name: "Message",
          package: "testapis.wktypes",
        },
      },
    },
  );
",
    "name": "testapis/wktypes/well_known_types.pb.pothos.ts",
  },
]
`;

exports[`'testapis.wktypes' > generates files by plugin 'with partial inputs' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/wktypes/well_known_types.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { Message } from "@testapis/ts-proto/testapis/wktypes/well_known_types";
import { builder } from "../../builder";

export const Message$Ref = builder.objectRef<Message>("Message");
builder.objectType(Message$Ref, {
  name: "Message",
  fields: (t) => ({
    timestamp: t.expose("timestamp", {
      type: "DateTime",
      nullable: true,
      extensions: {
        protobufField: {
          name: "timestamp",
          typeFullName: "google.protobuf.Timestamp",
        },
      },
    }),
    int32Value: t.expose("int32Value", {
      type: "Int",
      nullable: true,
      extensions: {
        protobufField: {
          name: "int32_value",
          typeFullName: "google.protobuf.Int32Value",
        },
      },
    }),
    int64Value: t.expose("int64Value", {
      type: "String",
      nullable: true,
      extensions: {
        protobufField: {
          name: "int64_value",
          typeFullName: "google.protobuf.Int64Value",
        },
      },
    }),
    uint32Value: t.expose("uint32Value", {
      type: "Int",
      nullable: true,
      extensions: {
        protobufField: {
          name: "uint32_value",
          typeFullName: "google.protobuf.UInt32Value",
        },
      },
    }),
    uint64Value: t.expose("uint64Value", {
      type: "String",
      nullable: true,
      extensions: {
        protobufField: {
          name: "uint64_value",
          typeFullName: "google.protobuf.UInt64Value",
        },
      },
    }),
    floatValue: t.expose("floatValue", {
      type: "Float",
      nullable: true,
      extensions: {
        protobufField: {
          name: "float_value",
          typeFullName: "google.protobuf.FloatValue",
        },
      },
    }),
    doubleValue: t.expose("doubleValue", {
      type: "Float",
      nullable: true,
      extensions: {
        protobufField: {
          name: "double_value",
          typeFullName: "google.protobuf.DoubleValue",
        },
      },
    }),
    boolValue: t.expose("boolValue", {
      type: "Boolean",
      nullable: true,
      extensions: {
        protobufField: {
          name: "bool_value",
          typeFullName: "google.protobuf.BoolValue",
        },
      },
    }),
    stringValue: t.expose("stringValue", {
      type: "String",
      nullable: true,
      extensions: {
        protobufField: {
          name: "string_value",
          typeFullName: "google.protobuf.StringValue",
        },
      },
    }),
    bytesValue: t.field({
      type: "Byte",
      nullable: true,
      resolve: (source) => {
        return source.bytesValue == null
          ? null
          : Buffer.from(source.bytesValue);
      },
      extensions: {
        protobufField: {
          name: "bytes_value",
          typeFullName: "google.protobuf.BytesValue",
        },
      },
    }),
    requiredTimestamp: t.field({
      type: "DateTime",
      nullable: false,
      description: "Required.",
      resolve: (source) => {
        return source.requiredTimestamp!;
      },
      extensions: {
        protobufField: {
          name: "required_timestamp",
          typeFullName: "google.protobuf.Timestamp",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as Message | { $type: string & {}; }).$type ===
      "testapis.wktypes.Message";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.wktypes.Message",
      name: "Message",
      package: "testapis.wktypes",
    },
  },
});

export type MessageInput$Shape = {
  timestamp?: Message["timestamp"] | null;
  int32Value?: Message["int32Value"] | null;
  int64Value?: Message["int64Value"] | null;
  uint32Value?: Message["uint32Value"] | null;
  uint64Value?: Message["uint64Value"] | null;
  floatValue?: Message["floatValue"] | null;
  doubleValue?: Message["doubleValue"] | null;
  boolValue?: Message["boolValue"] | null;
  stringValue?: Message["stringValue"] | null;
  bytesValue?: Message["bytesValue"] | null;
  requiredTimestamp: NonNullable<Message["requiredTimestamp"]>;
};

export const MessageInput$Ref: InputObjectRef<MessageInput$Shape> = builder
  .inputRef<MessageInput$Shape>("MessageInput").implement(
    {
      fields: (t) => ({
        timestamp: t.field({
          type: "DateTime",
          required: false,
          extensions: {
            protobufField: {
              name: "timestamp",
              typeFullName: "google.protobuf.Timestamp",
            },
          },
        }),
        int32Value: t.field({
          type: "Int",
          required: false,
          extensions: {
            protobufField: {
              name: "int32_value",
              typeFullName: "google.protobuf.Int32Value",
            },
          },
        }),
        int64Value: t.field({
          type: "String",
          required: false,
          extensions: {
            protobufField: {
              name: "int64_value",
              typeFullName: "google.protobuf.Int64Value",
            },
          },
        }),
        uint32Value: t.field({
          type: "Int",
          required: false,
          extensions: {
            protobufField: {
              name: "uint32_value",
              typeFullName: "google.protobuf.UInt32Value",
            },
          },
        }),
        uint64Value: t.field({
          type: "String",
          required: false,
          extensions: {
            protobufField: {
              name: "uint64_value",
              typeFullName: "google.protobuf.UInt64Value",
            },
          },
        }),
        floatValue: t.field({
          type: "Float",
          required: false,
          extensions: {
            protobufField: {
              name: "float_value",
              typeFullName: "google.protobuf.FloatValue",
            },
          },
        }),
        doubleValue: t.field({
          type: "Float",
          required: false,
          extensions: {
            protobufField: {
              name: "double_value",
              typeFullName: "google.protobuf.DoubleValue",
            },
          },
        }),
        boolValue: t.field({
          type: "Boolean",
          required: false,
          extensions: {
            protobufField: {
              name: "bool_value",
              typeFullName: "google.protobuf.BoolValue",
            },
          },
        }),
        stringValue: t.field({
          type: "String",
          required: false,
          extensions: {
            protobufField: {
              name: "string_value",
              typeFullName: "google.protobuf.StringValue",
            },
          },
        }),
        bytesValue: t.field({
          type: "Byte",
          required: false,
          extensions: {
            protobufField: {
              name: "bytes_value",
              typeFullName: "google.protobuf.BytesValue",
            },
          },
        }),
        requiredTimestamp: t.field({
          type: "DateTime",
          required: true,
          description: "Required.",
          extensions: {
            protobufField: {
              name: "required_timestamp",
              typeFullName: "google.protobuf.Timestamp",
            },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.wktypes.Message",
          name: "Message",
          package: "testapis.wktypes",
        },
      },
    },
  );

export type MessagePartialInput$Shape = {
  timestamp?: Message["timestamp"] | null;
  int32Value?: Message["int32Value"] | null;
  int64Value?: Message["int64Value"] | null;
  uint32Value?: Message["uint32Value"] | null;
  uint64Value?: Message["uint64Value"] | null;
  floatValue?: Message["floatValue"] | null;
  doubleValue?: Message["doubleValue"] | null;
  boolValue?: Message["boolValue"] | null;
  stringValue?: Message["stringValue"] | null;
  bytesValue?: Message["bytesValue"] | null;
  requiredTimestamp?: Message["requiredTimestamp"] | null;
};

export const MessagePartialInput$Ref: InputObjectRef<
  MessagePartialInput$Shape
> = builder.inputRef<MessagePartialInput$Shape>("MessagePartialInput")
  .implement(
    {
      fields: (t) => ({
        timestamp: t.field({
          type: "DateTime",
          required: false,
          extensions: {
            protobufField: {
              name: "timestamp",
              typeFullName: "google.protobuf.Timestamp",
            },
          },
        }),
        int32Value: t.field({
          type: "Int",
          required: false,
          extensions: {
            protobufField: {
              name: "int32_value",
              typeFullName: "google.protobuf.Int32Value",
            },
          },
        }),
        int64Value: t.field({
          type: "String",
          required: false,
          extensions: {
            protobufField: {
              name: "int64_value",
              typeFullName: "google.protobuf.Int64Value",
            },
          },
        }),
        uint32Value: t.field({
          type: "Int",
          required: false,
          extensions: {
            protobufField: {
              name: "uint32_value",
              typeFullName: "google.protobuf.UInt32Value",
            },
          },
        }),
        uint64Value: t.field({
          type: "String",
          required: false,
          extensions: {
            protobufField: {
              name: "uint64_value",
              typeFullName: "google.protobuf.UInt64Value",
            },
          },
        }),
        floatValue: t.field({
          type: "Float",
          required: false,
          extensions: {
            protobufField: {
              name: "float_value",
              typeFullName: "google.protobuf.FloatValue",
            },
          },
        }),
        doubleValue: t.field({
          type: "Float",
          required: false,
          extensions: {
            protobufField: {
              name: "double_value",
              typeFullName: "google.protobuf.DoubleValue",
            },
          },
        }),
        boolValue: t.field({
          type: "Boolean",
          required: false,
          extensions: {
            protobufField: {
              name: "bool_value",
              typeFullName: "google.protobuf.BoolValue",
            },
          },
        }),
        stringValue: t.field({
          type: "String",
          required: false,
          extensions: {
            protobufField: {
              name: "string_value",
              typeFullName: "google.protobuf.StringValue",
            },
          },
        }),
        bytesValue: t.field({
          type: "Byte",
          required: false,
          extensions: {
            protobufField: {
              name: "bytes_value",
              typeFullName: "google.protobuf.BytesValue",
            },
          },
        }),
        requiredTimestamp: t.field({
          type: "DateTime",
          required: false,
          description: "Required.",
          extensions: {
            protobufField: {
              name: "required_timestamp",
              typeFullName: "google.protobuf.Timestamp",
            },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.wktypes.Message",
          name: "Message",
          package: "testapis.wktypes",
        },
      },
    },
  );
",
    "name": "testapis/wktypes/well_known_types.pb.pothos.ts",
  },
]
`;

exports[`'testapis.wktypes' > generates files by plugin 'without import prefix' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/wktypes/well_known_types.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { builder } from "../../builder";
import { Message } from "./testapis/wktypes/well_known_types";

export const Message$Ref = builder.objectRef<Message>("Message");
builder.objectType(Message$Ref, {
  name: "Message",
  fields: (t) => ({
    timestamp: t.expose("timestamp", {
      type: "DateTime",
      nullable: true,
      extensions: {
        protobufField: {
          name: "timestamp",
          typeFullName: "google.protobuf.Timestamp",
        },
      },
    }),
    int32Value: t.expose("int32Value", {
      type: "Int",
      nullable: true,
      extensions: {
        protobufField: {
          name: "int32_value",
          typeFullName: "google.protobuf.Int32Value",
        },
      },
    }),
    int64Value: t.expose("int64Value", {
      type: "String",
      nullable: true,
      extensions: {
        protobufField: {
          name: "int64_value",
          typeFullName: "google.protobuf.Int64Value",
        },
      },
    }),
    uint32Value: t.expose("uint32Value", {
      type: "Int",
      nullable: true,
      extensions: {
        protobufField: {
          name: "uint32_value",
          typeFullName: "google.protobuf.UInt32Value",
        },
      },
    }),
    uint64Value: t.expose("uint64Value", {
      type: "String",
      nullable: true,
      extensions: {
        protobufField: {
          name: "uint64_value",
          typeFullName: "google.protobuf.UInt64Value",
        },
      },
    }),
    floatValue: t.expose("floatValue", {
      type: "Float",
      nullable: true,
      extensions: {
        protobufField: {
          name: "float_value",
          typeFullName: "google.protobuf.FloatValue",
        },
      },
    }),
    doubleValue: t.expose("doubleValue", {
      type: "Float",
      nullable: true,
      extensions: {
        protobufField: {
          name: "double_value",
          typeFullName: "google.protobuf.DoubleValue",
        },
      },
    }),
    boolValue: t.expose("boolValue", {
      type: "Boolean",
      nullable: true,
      extensions: {
        protobufField: {
          name: "bool_value",
          typeFullName: "google.protobuf.BoolValue",
        },
      },
    }),
    stringValue: t.expose("stringValue", {
      type: "String",
      nullable: true,
      extensions: {
        protobufField: {
          name: "string_value",
          typeFullName: "google.protobuf.StringValue",
        },
      },
    }),
    bytesValue: t.field({
      type: "Byte",
      nullable: true,
      resolve: (source) => {
        return source.bytesValue == null
          ? null
          : Buffer.from(source.bytesValue);
      },
      extensions: {
        protobufField: {
          name: "bytes_value",
          typeFullName: "google.protobuf.BytesValue",
        },
      },
    }),
    requiredTimestamp: t.field({
      type: "DateTime",
      nullable: false,
      description: "Required.",
      resolve: (source) => {
        return source.requiredTimestamp!;
      },
      extensions: {
        protobufField: {
          name: "required_timestamp",
          typeFullName: "google.protobuf.Timestamp",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as Message | { $type: string & {}; }).$type ===
      "testapis.wktypes.Message";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.wktypes.Message",
      name: "Message",
      package: "testapis.wktypes",
    },
  },
});

export type MessageInput$Shape = {
  timestamp?: Message["timestamp"] | null;
  int32Value?: Message["int32Value"] | null;
  int64Value?: Message["int64Value"] | null;
  uint32Value?: Message["uint32Value"] | null;
  uint64Value?: Message["uint64Value"] | null;
  floatValue?: Message["floatValue"] | null;
  doubleValue?: Message["doubleValue"] | null;
  boolValue?: Message["boolValue"] | null;
  stringValue?: Message["stringValue"] | null;
  bytesValue?: Message["bytesValue"] | null;
  requiredTimestamp: NonNullable<Message["requiredTimestamp"]>;
};

export const MessageInput$Ref: InputObjectRef<MessageInput$Shape> = builder
  .inputRef<MessageInput$Shape>("MessageInput").implement(
    {
      fields: (t) => ({
        timestamp: t.field({
          type: "DateTime",
          required: false,
          extensions: {
            protobufField: {
              name: "timestamp",
              typeFullName: "google.protobuf.Timestamp",
            },
          },
        }),
        int32Value: t.field({
          type: "Int",
          required: false,
          extensions: {
            protobufField: {
              name: "int32_value",
              typeFullName: "google.protobuf.Int32Value",
            },
          },
        }),
        int64Value: t.field({
          type: "String",
          required: false,
          extensions: {
            protobufField: {
              name: "int64_value",
              typeFullName: "google.protobuf.Int64Value",
            },
          },
        }),
        uint32Value: t.field({
          type: "Int",
          required: false,
          extensions: {
            protobufField: {
              name: "uint32_value",
              typeFullName: "google.protobuf.UInt32Value",
            },
          },
        }),
        uint64Value: t.field({
          type: "String",
          required: false,
          extensions: {
            protobufField: {
              name: "uint64_value",
              typeFullName: "google.protobuf.UInt64Value",
            },
          },
        }),
        floatValue: t.field({
          type: "Float",
          required: false,
          extensions: {
            protobufField: {
              name: "float_value",
              typeFullName: "google.protobuf.FloatValue",
            },
          },
        }),
        doubleValue: t.field({
          type: "Float",
          required: false,
          extensions: {
            protobufField: {
              name: "double_value",
              typeFullName: "google.protobuf.DoubleValue",
            },
          },
        }),
        boolValue: t.field({
          type: "Boolean",
          required: false,
          extensions: {
            protobufField: {
              name: "bool_value",
              typeFullName: "google.protobuf.BoolValue",
            },
          },
        }),
        stringValue: t.field({
          type: "String",
          required: false,
          extensions: {
            protobufField: {
              name: "string_value",
              typeFullName: "google.protobuf.StringValue",
            },
          },
        }),
        bytesValue: t.field({
          type: "Byte",
          required: false,
          extensions: {
            protobufField: {
              name: "bytes_value",
              typeFullName: "google.protobuf.BytesValue",
            },
          },
        }),
        requiredTimestamp: t.field({
          type: "DateTime",
          required: true,
          description: "Required.",
          extensions: {
            protobufField: {
              name: "required_timestamp",
              typeFullName: "google.protobuf.Timestamp",
            },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.wktypes.Message",
          name: "Message",
          package: "testapis.wktypes",
        },
      },
    },
  );
",
    "name": "testapis/wktypes/well_known_types.pb.pothos.ts",
  },
]
`;

exports[`protobuf-es > 'testapis.custom_types' > generates files by plugin 'with import prefix' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/custom_types/date.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { Date } from "@testapis/protobuf-es/testapis/custom_types/date_pb";
import { builder } from "../../builder";

export const Date$Ref = builder.objectRef<Date>("Date");
builder.objectType(Date$Ref, {
  name: "Date",
  fields: (t) => ({
    year: t.expose("year", {
      type: "Int",
      nullable: false,
      extensions: { protobufField: { name: "year", typeFullName: "uint32" } },
    }),
    month: t.expose("month", {
      type: "Int",
      nullable: false,
      extensions: { protobufField: { name: "month", typeFullName: "uint32" } },
    }),
    day: t.expose("day", {
      type: "Int",
      nullable: false,
      extensions: { protobufField: { name: "day", typeFullName: "uint32" } },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof Date;
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.custom_types.Date",
      name: "Date",
      package: "testapis.custom_types",
    },
  },
});

export type DateInput$Shape = {
  year: Date["year"];
  month: Date["month"];
  day: Date["day"];
};

export const DateInput$Ref: InputObjectRef<DateInput$Shape> = builder.inputRef<
  DateInput$Shape
>("DateInput").implement(
  {
    fields: (t) => ({
      year: t.field({
        type: "Int",
        required: true,
        extensions: { protobufField: { name: "year", typeFullName: "uint32" } },
      }),
      month: t.field({
        type: "Int",
        required: true,
        extensions: {
          protobufField: { name: "month", typeFullName: "uint32" },
        },
      }),
      day: t.field({
        type: "Int",
        required: true,
        extensions: { protobufField: { name: "day", typeFullName: "uint32" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.custom_types.Date",
        name: "Date",
        package: "testapis.custom_types",
      },
    },
  },
);

export function DateInput$toProto(
  input: DateInput$Shape | null | undefined,
): Date {
  return new Date({
    year: input?.year ?? undefined,
    month: input?.month ?? undefined,
    day: input?.day ?? undefined,
  });
}
",
    "name": "testapis/custom_types/date.pb.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/custom_types/post.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { Post } from "@testapis/protobuf-es/testapis/custom_types/post_pb";
import { builder } from "../../builder";
import {
  Date$Ref,
  DateInput$Ref,
  DateInput$Shape,
  DateInput$toProto,
} from "./date.pb.pothos";

export const Post$Ref = builder.objectRef<Post>("Post");
builder.objectType(Post$Ref, {
  name: "Post",
  fields: (t) => ({
    title: t.expose("title", {
      type: "String",
      nullable: false,
      description: "Required.",
      extensions: { protobufField: { name: "title", typeFullName: "string" } },
    }),
    publishedDate: t.expose("publishedDate", {
      type: Date$Ref,
      nullable: true,
      description: "Optional.",
      extensions: {
        protobufField: {
          name: "published_date",
          typeFullName: "testapis.custom_types.Date",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof Post;
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.custom_types.Post",
      name: "Post",
      package: "testapis.custom_types",
    },
  },
});

export type PostInput$Shape = {
  title: Post["title"];
  publishedDate?: DateInput$Shape | null;
};

export const PostInput$Ref: InputObjectRef<PostInput$Shape> = builder.inputRef<
  PostInput$Shape
>("PostInput").implement(
  {
    fields: (t) => ({
      title: t.field({
        type: "String",
        required: true,
        description: "Required.",
        extensions: {
          protobufField: { name: "title", typeFullName: "string" },
        },
      }),
      publishedDate: t.field({
        type: DateInput$Ref,
        required: false,
        description: "Optional.",
        extensions: {
          protobufField: {
            name: "published_date",
            typeFullName: "testapis.custom_types.Date",
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.custom_types.Post",
        name: "Post",
        package: "testapis.custom_types",
      },
    },
  },
);

export function PostInput$toProto(
  input: PostInput$Shape | null | undefined,
): Post {
  return new Post({
    title: input?.title ?? undefined,
    publishedDate: input?.publishedDate
      ? DateInput$toProto(input.publishedDate)
      : undefined,
  });
}
",
    "name": "testapis/custom_types/post.pb.pothos.ts",
  },
]
`;

exports[`protobuf-es > 'testapis.custom_types' > generates files by plugin 'with partial inputs' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/custom_types/date.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { Date } from "@testapis/protobuf-es/testapis/custom_types/date_pb";
import { builder } from "../../builder";

export const Date$Ref = builder.objectRef<Date>("Date");
builder.objectType(Date$Ref, {
  name: "Date",
  fields: (t) => ({
    year: t.expose("year", {
      type: "Int",
      nullable: false,
      extensions: { protobufField: { name: "year", typeFullName: "uint32" } },
    }),
    month: t.expose("month", {
      type: "Int",
      nullable: false,
      extensions: { protobufField: { name: "month", typeFullName: "uint32" } },
    }),
    day: t.expose("day", {
      type: "Int",
      nullable: false,
      extensions: { protobufField: { name: "day", typeFullName: "uint32" } },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof Date;
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.custom_types.Date",
      name: "Date",
      package: "testapis.custom_types",
    },
  },
});

export type DateInput$Shape = {
  year: Date["year"];
  month: Date["month"];
  day: Date["day"];
};

export const DateInput$Ref: InputObjectRef<DateInput$Shape> = builder.inputRef<
  DateInput$Shape
>("DateInput").implement(
  {
    fields: (t) => ({
      year: t.field({
        type: "Int",
        required: true,
        extensions: { protobufField: { name: "year", typeFullName: "uint32" } },
      }),
      month: t.field({
        type: "Int",
        required: true,
        extensions: {
          protobufField: { name: "month", typeFullName: "uint32" },
        },
      }),
      day: t.field({
        type: "Int",
        required: true,
        extensions: { protobufField: { name: "day", typeFullName: "uint32" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.custom_types.Date",
        name: "Date",
        package: "testapis.custom_types",
      },
    },
  },
);

export function DateInput$toProto(
  input: DateInput$Shape | null | undefined,
): Date {
  return new Date({
    year: input?.year ?? undefined,
    month: input?.month ?? undefined,
    day: input?.day ?? undefined,
  });
}

export type DatePartialInput$Shape = {
  year?: Date["year"] | null;
  month?: Date["month"] | null;
  day?: Date["day"] | null;
};

export const DatePartialInput$Ref: InputObjectRef<DatePartialInput$Shape> =
  builder.inputRef<DatePartialInput$Shape>("DatePartialInput").implement(
    {
      fields: (t) => ({
        year: t.field({
          type: "Int",
          required: false,
          extensions: {
            protobufField: { name: "year", typeFullName: "uint32" },
          },
        }),
        month: t.field({
          type: "Int",
          required: false,
          extensions: {
            protobufField: { name: "month", typeFullName: "uint32" },
          },
        }),
        day: t.field({
          type: "Int",
          required: false,
          extensions: {
            protobufField: { name: "day", typeFullName: "uint32" },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.custom_types.Date",
          name: "Date",
          package: "testapis.custom_types",
        },
      },
    },
  );

export function DatePartialInput$toProto(
  input: DatePartialInput$Shape | null | undefined,
): Date {
  return new Date({
    year: input?.year ?? undefined,
    month: input?.month ?? undefined,
    day: input?.day ?? undefined,
  });
}
",
    "name": "testapis/custom_types/date.pb.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/custom_types/post.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { Post } from "@testapis/protobuf-es/testapis/custom_types/post_pb";
import { builder } from "../../builder";
import {
  Date$Ref,
  DateInput$Ref,
  DateInput$Shape,
  DateInput$toProto,
  DatePartialInput$Ref,
  DatePartialInput$Shape,
  DatePartialInput$toProto,
} from "./date.pb.pothos";

export const Post$Ref = builder.objectRef<Post>("Post");
builder.objectType(Post$Ref, {
  name: "Post",
  fields: (t) => ({
    title: t.expose("title", {
      type: "String",
      nullable: false,
      description: "Required.",
      extensions: { protobufField: { name: "title", typeFullName: "string" } },
    }),
    publishedDate: t.expose("publishedDate", {
      type: Date$Ref,
      nullable: true,
      description: "Optional.",
      extensions: {
        protobufField: {
          name: "published_date",
          typeFullName: "testapis.custom_types.Date",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof Post;
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.custom_types.Post",
      name: "Post",
      package: "testapis.custom_types",
    },
  },
});

export type PostInput$Shape = {
  title: Post["title"];
  publishedDate?: DateInput$Shape | null;
};

export const PostInput$Ref: InputObjectRef<PostInput$Shape> = builder.inputRef<
  PostInput$Shape
>("PostInput").implement(
  {
    fields: (t) => ({
      title: t.field({
        type: "String",
        required: true,
        description: "Required.",
        extensions: {
          protobufField: { name: "title", typeFullName: "string" },
        },
      }),
      publishedDate: t.field({
        type: DateInput$Ref,
        required: false,
        description: "Optional.",
        extensions: {
          protobufField: {
            name: "published_date",
            typeFullName: "testapis.custom_types.Date",
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.custom_types.Post",
        name: "Post",
        package: "testapis.custom_types",
      },
    },
  },
);

export function PostInput$toProto(
  input: PostInput$Shape | null | undefined,
): Post {
  return new Post({
    title: input?.title ?? undefined,
    publishedDate: input?.publishedDate
      ? DateInput$toProto(input.publishedDate)
      : undefined,
  });
}

export type PostPartialInput$Shape = {
  title?: Post["title"] | null;
  publishedDate?: DatePartialInput$Shape | null;
};

export const PostPartialInput$Ref: InputObjectRef<PostPartialInput$Shape> =
  builder.inputRef<PostPartialInput$Shape>("PostPartialInput").implement(
    {
      fields: (t) => ({
        title: t.field({
          type: "String",
          required: false,
          description: "Required.",
          extensions: {
            protobufField: { name: "title", typeFullName: "string" },
          },
        }),
        publishedDate: t.field({
          type: DatePartialInput$Ref,
          required: false,
          description: "Optional.",
          extensions: {
            protobufField: {
              name: "published_date",
              typeFullName: "testapis.custom_types.Date",
            },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.custom_types.Post",
          name: "Post",
          package: "testapis.custom_types",
        },
      },
    },
  );

export function PostPartialInput$toProto(
  input: PostPartialInput$Shape | null | undefined,
): Post {
  return new Post({
    title: input?.title ?? undefined,
    publishedDate: input?.publishedDate
      ? DatePartialInput$toProto(input.publishedDate)
      : undefined,
  });
}
",
    "name": "testapis/custom_types/post.pb.pothos.ts",
  },
]
`;

exports[`protobuf-es > 'testapis.custom_types' > generates files by plugin 'without import prefix' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/custom_types/date.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { builder } from "../../builder";
import { Date } from "./testapis/custom_types/date_pb";

export const Date$Ref = builder.objectRef<Date>("Date");
builder.objectType(Date$Ref, {
  name: "Date",
  fields: (t) => ({
    year: t.expose("year", {
      type: "Int",
      nullable: false,
      extensions: { protobufField: { name: "year", typeFullName: "uint32" } },
    }),
    month: t.expose("month", {
      type: "Int",
      nullable: false,
      extensions: { protobufField: { name: "month", typeFullName: "uint32" } },
    }),
    day: t.expose("day", {
      type: "Int",
      nullable: false,
      extensions: { protobufField: { name: "day", typeFullName: "uint32" } },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof Date;
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.custom_types.Date",
      name: "Date",
      package: "testapis.custom_types",
    },
  },
});

export type DateInput$Shape = {
  year: Date["year"];
  month: Date["month"];
  day: Date["day"];
};

export const DateInput$Ref: InputObjectRef<DateInput$Shape> = builder.inputRef<
  DateInput$Shape
>("DateInput").implement(
  {
    fields: (t) => ({
      year: t.field({
        type: "Int",
        required: true,
        extensions: { protobufField: { name: "year", typeFullName: "uint32" } },
      }),
      month: t.field({
        type: "Int",
        required: true,
        extensions: {
          protobufField: { name: "month", typeFullName: "uint32" },
        },
      }),
      day: t.field({
        type: "Int",
        required: true,
        extensions: { protobufField: { name: "day", typeFullName: "uint32" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.custom_types.Date",
        name: "Date",
        package: "testapis.custom_types",
      },
    },
  },
);

export function DateInput$toProto(
  input: DateInput$Shape | null | undefined,
): Date {
  return new Date({
    year: input?.year ?? undefined,
    month: input?.month ?? undefined,
    day: input?.day ?? undefined,
  });
}
",
    "name": "testapis/custom_types/date.pb.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/custom_types/post.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { builder } from "../../builder";
import {
  Date$Ref,
  DateInput$Ref,
  DateInput$Shape,
  DateInput$toProto,
} from "./date.pb.pothos";
import { Post } from "./testapis/custom_types/post_pb";

export const Post$Ref = builder.objectRef<Post>("Post");
builder.objectType(Post$Ref, {
  name: "Post",
  fields: (t) => ({
    title: t.expose("title", {
      type: "String",
      nullable: false,
      description: "Required.",
      extensions: { protobufField: { name: "title", typeFullName: "string" } },
    }),
    publishedDate: t.expose("publishedDate", {
      type: Date$Ref,
      nullable: true,
      description: "Optional.",
      extensions: {
        protobufField: {
          name: "published_date",
          typeFullName: "testapis.custom_types.Date",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof Post;
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.custom_types.Post",
      name: "Post",
      package: "testapis.custom_types",
    },
  },
});

export type PostInput$Shape = {
  title: Post["title"];
  publishedDate?: DateInput$Shape | null;
};

export const PostInput$Ref: InputObjectRef<PostInput$Shape> = builder.inputRef<
  PostInput$Shape
>("PostInput").implement(
  {
    fields: (t) => ({
      title: t.field({
        type: "String",
        required: true,
        description: "Required.",
        extensions: {
          protobufField: { name: "title", typeFullName: "string" },
        },
      }),
      publishedDate: t.field({
        type: DateInput$Ref,
        required: false,
        description: "Optional.",
        extensions: {
          protobufField: {
            name: "published_date",
            typeFullName: "testapis.custom_types.Date",
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.custom_types.Post",
        name: "Post",
        package: "testapis.custom_types",
      },
    },
  },
);

export function PostInput$toProto(
  input: PostInput$Shape | null | undefined,
): Post {
  return new Post({
    title: input?.title ?? undefined,
    publishedDate: input?.publishedDate
      ? DateInput$toProto(input.publishedDate)
      : undefined,
  });
}
",
    "name": "testapis/custom_types/post.pb.pothos.ts",
  },
]
`;

exports[`protobuf-es > 'testapis.deprecation' > generates files by plugin 'with import prefix' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/deprecation/deprecation.proto

/* eslint-disable */

import { EnumRef, InputObjectRef } from "@pothos/core";
import {
  DeprecatedEnum,
  DeprecatedMessage,
  DeprecatedMessage_InnerMessage,
  NotDeprecatedEnum,
  NotDeprecatedMessage,
  NotDeprecatedMessage_InnerMessage1,
  NotDeprecatedMessage_InnerMessage2,
} from "@testapis/protobuf-es/testapis/deprecation/deprecation_pb";
import { builder } from "../../builder";

export const DeprecatedMessage$Ref = builder.objectRef<DeprecatedMessage>(
  "DeprecatedMessage",
);
builder.objectType(DeprecatedMessage$Ref, {
  name: "DeprecatedMessage",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      deprecationReason:
        "testapis.deprecation.DeprecatedMessage is mark as deprecated in a *.proto file.",
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
    enum: t.field({
      type: NotDeprecatedEnum$Ref,
      nullable: true,
      deprecationReason:
        "testapis.deprecation.DeprecatedMessage is mark as deprecated in a *.proto file.",
      resolve: (source) => {
        if (source.enum === NotDeprecatedEnum.NOT_DEPRECATED_ENUM_UNSPECIFIED) {
          return null;
        }

        return source.enum;
      },
      extensions: {
        protobufField: {
          name: "enum",
          typeFullName: "testapis.deprecation.NotDeprecatedEnum",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof DeprecatedMessage;
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.deprecation.DeprecatedMessage",
      name: "DeprecatedMessage",
      package: "testapis.deprecation",
      options: { deprecated: true },
    },
  },
});

export const NotDeprecatedMessage$Ref = builder.objectRef<NotDeprecatedMessage>(
  "NotDeprecatedMessage",
);
builder.objectType(NotDeprecatedMessage$Ref, {
  name: "NotDeprecatedMessage",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      deprecationReason:
        "testapis.deprecation.NotDeprecatedMessage.body is mark as deprecated in a *.proto file.",
      extensions: {
        protobufField: {
          name: "body",
          typeFullName: "string",
          options: { deprecated: true },
        },
      },
    }),
    enum: t.field({
      type: DeprecatedEnum$Ref,
      nullable: true,
      deprecationReason:
        "testapis.deprecation.DeprecatedEnum is mark as deprecated in a *.proto file.",
      resolve: (source) => {
        if (source.enum === DeprecatedEnum.DEPRECATED_ENUM_UNSPECIFIED) {
          return null;
        }

        return source.enum;
      },
      extensions: {
        protobufField: {
          name: "enum",
          typeFullName: "testapis.deprecation.DeprecatedEnum",
        },
      },
    }),
    notDeprecatedOneof: t.field({
      type: NotDeprecatedMessageNotDeprecatedOneof$Ref,
      nullable: true,
      resolve: (source) => {
        return source.notDeprecatedOneof.value;
      },
      extensions: { protobufField: { name: "not_deprecated_oneof" } },
    }),
    deprecatedOneof: t.field({
      type: NotDeprecatedMessageDeprecatedOneof$Ref,
      nullable: true,
      deprecationReason:
        "testapis.deprecation.NotDeprecatedMessage.deprecated_oneof is mark as deprecated in a *.proto file.",
      resolve: (source) => {
        return source.deprecatedOneof.value;
      },
      extensions: { protobufField: { name: "deprecated_oneof" } },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof NotDeprecatedMessage;
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.deprecation.NotDeprecatedMessage",
      name: "NotDeprecatedMessage",
      package: "testapis.deprecation",
    },
  },
});

export const DeprecatedMessageInnerMessage$Ref = builder.objectRef<
  DeprecatedMessage_InnerMessage
>("DeprecatedMessageInnerMessage");
builder.objectType(DeprecatedMessageInnerMessage$Ref, {
  name: "DeprecatedMessageInnerMessage",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      deprecationReason:
        "testapis.deprecation.DeprecatedMessage is mark as deprecated in a *.proto file.",
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof DeprecatedMessage_InnerMessage;
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.deprecation.DeprecatedMessage.InnerMessage",
      name: "InnerMessage",
      package: "testapis.deprecation",
    },
  },
});

export const NotDeprecatedMessageInnerMessage1$Ref = builder.objectRef<
  NotDeprecatedMessage_InnerMessage1
>("NotDeprecatedMessageInnerMessage1");
builder.objectType(NotDeprecatedMessageInnerMessage1$Ref, {
  name: "NotDeprecatedMessageInnerMessage1",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof NotDeprecatedMessage_InnerMessage1;
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.deprecation.NotDeprecatedMessage.InnerMessage1",
      name: "InnerMessage1",
      package: "testapis.deprecation",
    },
  },
});

export const NotDeprecatedMessageInnerMessage2$Ref = builder.objectRef<
  NotDeprecatedMessage_InnerMessage2
>("NotDeprecatedMessageInnerMessage2");
builder.objectType(NotDeprecatedMessageInnerMessage2$Ref, {
  name: "NotDeprecatedMessageInnerMessage2",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof NotDeprecatedMessage_InnerMessage2;
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.deprecation.NotDeprecatedMessage.InnerMessage2",
      name: "InnerMessage2",
      package: "testapis.deprecation",
    },
  },
});

export type DeprecatedMessageInput$Shape = {
  body?: DeprecatedMessage["body"] | null;
  enum?: DeprecatedMessage["enum"] | null;
};

export const DeprecatedMessageInput$Ref: InputObjectRef<
  DeprecatedMessageInput$Shape
> = builder.inputRef<DeprecatedMessageInput$Shape>("DeprecatedMessageInput")
  .implement(
    {
      fields: (t) => ({
        body: t.field({
          type: "String",
          required: false,
          deprecationReason:
            "testapis.deprecation.DeprecatedMessage is mark as deprecated in a *.proto file.",
          extensions: {
            protobufField: { name: "body", typeFullName: "string" },
          },
        }),
        enum: t.field({
          type: NotDeprecatedEnum$Ref,
          required: false,
          deprecationReason:
            "testapis.deprecation.DeprecatedMessage is mark as deprecated in a *.proto file.",
          extensions: {
            protobufField: {
              name: "enum",
              typeFullName: "testapis.deprecation.NotDeprecatedEnum",
            },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.deprecation.DeprecatedMessage",
          name: "DeprecatedMessage",
          package: "testapis.deprecation",
          options: { deprecated: true },
        },
      },
    },
  );

export function DeprecatedMessageInput$toProto(
  input: DeprecatedMessageInput$Shape | null | undefined,
): DeprecatedMessage {
  return new DeprecatedMessage({
    body: input?.body ?? undefined,
    enum: input?.enum ?? undefined,
  });
}

export type NotDeprecatedMessageInput$Shape = {
  body?: NotDeprecatedMessage["body"] | null;
  enum?: NotDeprecatedMessage["enum"] | null;
  msg1?: NotDeprecatedMessageInnerMessage1Input$Shape | null;
  msg2?: NotDeprecatedMessageInnerMessage2Input$Shape | null;
  msg3?: NotDeprecatedMessageInnerMessage1Input$Shape | null;
  msg4?: NotDeprecatedMessageInnerMessage2Input$Shape | null;
};

export const NotDeprecatedMessageInput$Ref: InputObjectRef<
  NotDeprecatedMessageInput$Shape
> = builder.inputRef<NotDeprecatedMessageInput$Shape>(
  "NotDeprecatedMessageInput",
).implement(
  {
    fields: (t) => ({
      body: t.field({
        type: "String",
        required: false,
        deprecationReason:
          "testapis.deprecation.NotDeprecatedMessage.body is mark as deprecated in a *.proto file.",
        extensions: {
          protobufField: {
            name: "body",
            typeFullName: "string",
            options: { deprecated: true },
          },
        },
      }),
      enum: t.field({
        type: DeprecatedEnum$Ref,
        required: false,
        deprecationReason:
          "testapis.deprecation.DeprecatedEnum is mark as deprecated in a *.proto file.",
        extensions: {
          protobufField: {
            name: "enum",
            typeFullName: "testapis.deprecation.DeprecatedEnum",
          },
        },
      }),
      msg1: t.field({
        type: NotDeprecatedMessageInnerMessage1Input$Ref,
        required: false,
        deprecationReason:
          "testapis.deprecation.NotDeprecatedMessage.msg1 is mark as deprecated in a *.proto file.",
        extensions: {
          protobufField: {
            name: "msg1",
            typeFullName:
              "testapis.deprecation.NotDeprecatedMessage.InnerMessage1",
            options: { deprecated: true },
          },
        },
      }),
      msg2: t.field({
        type: NotDeprecatedMessageInnerMessage2Input$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "msg2",
            typeFullName:
              "testapis.deprecation.NotDeprecatedMessage.InnerMessage2",
          },
        },
      }),
      msg3: t.field({
        type: NotDeprecatedMessageInnerMessage1Input$Ref,
        required: false,
        deprecationReason:
          "testapis.deprecation.NotDeprecatedMessage.msg3 is mark as deprecated in a *.proto file.",
        extensions: {
          protobufField: {
            name: "msg3",
            typeFullName:
              "testapis.deprecation.NotDeprecatedMessage.InnerMessage1",
            options: { deprecated: true },
          },
        },
      }),
      msg4: t.field({
        type: NotDeprecatedMessageInnerMessage2Input$Ref,
        required: false,
        deprecationReason:
          "testapis.deprecation.NotDeprecatedMessage.msg4 is mark as deprecated in a *.proto file.",
        extensions: {
          protobufField: {
            name: "msg4",
            typeFullName:
              "testapis.deprecation.NotDeprecatedMessage.InnerMessage2",
            options: { deprecated: true },
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.deprecation.NotDeprecatedMessage",
        name: "NotDeprecatedMessage",
        package: "testapis.deprecation",
      },
    },
  },
);

export function NotDeprecatedMessageInput$toProto(
  input: NotDeprecatedMessageInput$Shape | null | undefined,
): NotDeprecatedMessage {
  return new NotDeprecatedMessage({
    body: input?.body ?? undefined,
    enum: input?.enum ?? undefined,
    notDeprecatedOneof: input?.msg1
      ? {
        case: "msg1",
        value: NotDeprecatedMessageInnerMessage1Input$toProto(input.msg1),
      }
      : input?.msg2
      ? {
        case: "msg2",
        value: NotDeprecatedMessageInnerMessage2Input$toProto(input.msg2),
      }
      : undefined,
    deprecatedOneof: input?.msg3
      ? {
        case: "msg3",
        value: NotDeprecatedMessageInnerMessage1Input$toProto(input.msg3),
      }
      : input?.msg4
      ? {
        case: "msg4",
        value: NotDeprecatedMessageInnerMessage2Input$toProto(input.msg4),
      }
      : undefined,
  });
}

export type DeprecatedMessageInnerMessageInput$Shape = {
  body?: DeprecatedMessage_InnerMessage["body"] | null;
};

export const DeprecatedMessageInnerMessageInput$Ref: InputObjectRef<
  DeprecatedMessageInnerMessageInput$Shape
> = builder.inputRef<DeprecatedMessageInnerMessageInput$Shape>(
  "DeprecatedMessageInnerMessageInput",
).implement(
  {
    fields: (t) => ({
      body: t.field({
        type: "String",
        required: false,
        deprecationReason:
          "testapis.deprecation.DeprecatedMessage is mark as deprecated in a *.proto file.",
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.deprecation.DeprecatedMessage.InnerMessage",
        name: "InnerMessage",
        package: "testapis.deprecation",
      },
    },
  },
);

export function DeprecatedMessageInnerMessageInput$toProto(
  input: DeprecatedMessageInnerMessageInput$Shape | null | undefined,
): DeprecatedMessage_InnerMessage {
  return new DeprecatedMessage_InnerMessage({
    body: input?.body ?? undefined,
  });
}

export type NotDeprecatedMessageInnerMessage1Input$Shape = {
  body: NotDeprecatedMessage_InnerMessage1["body"];
};

export const NotDeprecatedMessageInnerMessage1Input$Ref: InputObjectRef<
  NotDeprecatedMessageInnerMessage1Input$Shape
> = builder.inputRef<NotDeprecatedMessageInnerMessage1Input$Shape>(
  "NotDeprecatedMessageInnerMessage1Input",
).implement(
  {
    fields: (t) => ({
      body: t.field({
        type: "String",
        required: true,
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.deprecation.NotDeprecatedMessage.InnerMessage1",
        name: "InnerMessage1",
        package: "testapis.deprecation",
      },
    },
  },
);

export function NotDeprecatedMessageInnerMessage1Input$toProto(
  input: NotDeprecatedMessageInnerMessage1Input$Shape | null | undefined,
): NotDeprecatedMessage_InnerMessage1 {
  return new NotDeprecatedMessage_InnerMessage1({
    body: input?.body ?? undefined,
  });
}

export type NotDeprecatedMessageInnerMessage2Input$Shape = {
  body: NotDeprecatedMessage_InnerMessage2["body"];
};

export const NotDeprecatedMessageInnerMessage2Input$Ref: InputObjectRef<
  NotDeprecatedMessageInnerMessage2Input$Shape
> = builder.inputRef<NotDeprecatedMessageInnerMessage2Input$Shape>(
  "NotDeprecatedMessageInnerMessage2Input",
).implement(
  {
    fields: (t) => ({
      body: t.field({
        type: "String",
        required: true,
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.deprecation.NotDeprecatedMessage.InnerMessage2",
        name: "InnerMessage2",
        package: "testapis.deprecation",
      },
    },
  },
);

export function NotDeprecatedMessageInnerMessage2Input$toProto(
  input: NotDeprecatedMessageInnerMessage2Input$Shape | null | undefined,
): NotDeprecatedMessage_InnerMessage2 {
  return new NotDeprecatedMessage_InnerMessage2({
    body: input?.body ?? undefined,
  });
}

export const NotDeprecatedMessageNotDeprecatedOneof$Ref = builder.unionType(
  "NotDeprecatedMessageNotDeprecatedOneof",
  {
    types: [
      NotDeprecatedMessageInnerMessage1$Ref,
      NotDeprecatedMessageInnerMessage2$Ref,
    ],
    extensions: {
      protobufOneof: {
        fullName:
          "testapis.deprecation.NotDeprecatedMessage.not_deprecated_oneof",
        name: "not_deprecated_oneof",
        messageName: "NotDeprecatedMessage",
        package: "testapis.deprecation",
        fields: [{
          name: "msg1",
          type: "testapis.deprecation.NotDeprecatedMessage.InnerMessage1",
        }, {
          name: "msg2",
          type: "testapis.deprecation.NotDeprecatedMessage.InnerMessage2",
        }],
      },
    },
  },
);

export const NotDeprecatedMessageDeprecatedOneof$Ref = builder.unionType(
  "NotDeprecatedMessageDeprecatedOneof",
  {
    types: [
      NotDeprecatedMessageInnerMessage1$Ref,
      NotDeprecatedMessageInnerMessage2$Ref,
    ],
    extensions: {
      protobufOneof: {
        fullName: "testapis.deprecation.NotDeprecatedMessage.deprecated_oneof",
        name: "deprecated_oneof",
        messageName: "NotDeprecatedMessage",
        package: "testapis.deprecation",
        fields: [{
          name: "msg3",
          type: "testapis.deprecation.NotDeprecatedMessage.InnerMessage1",
        }, {
          name: "msg4",
          type: "testapis.deprecation.NotDeprecatedMessage.InnerMessage2",
        }],
      },
    },
  },
);

export const NotDeprecatedEnum$Ref: EnumRef<
  NotDeprecatedEnum,
  NotDeprecatedEnum
> = builder.enumType("NotDeprecatedEnum", {
  values: {
    NOT_DEPRECATED_FOO: {
      value: 1,
      extensions: { protobufEnumValue: { name: "NOT_DEPRECATED_FOO" } },
    },
    DEPRECATED_BAR: {
      deprecationReason:
        "testapis.deprecation.NotDeprecatedEnum.DEPRECATED_BAR is mark as deprecated in a *.proto file.",
      value: 2,
      extensions: {
        protobufEnumValue: {
          name: "DEPRECATED_BAR",
          options: { deprecated: true },
        },
      },
    },
  } as const,
  extensions: {
    protobufEnum: {
      name: "NotDeprecatedEnum",
      fullName: "testapis.deprecation.NotDeprecatedEnum",
      package: "testapis.deprecation",
    },
  },
});

export const DeprecatedEnum$Ref: EnumRef<DeprecatedEnum, DeprecatedEnum> =
  builder.enumType("DeprecatedEnum", {
    values: {
      DEPRECATED_BAZ: {
        deprecationReason:
          "testapis.deprecation.DeprecatedEnum is mark as deprecated in a *.proto file.",
        value: 1,
        extensions: { protobufEnumValue: { name: "DEPRECATED_BAZ" } },
      },
      DEPRECATED_QUX: {
        deprecationReason:
          "testapis.deprecation.DeprecatedEnum is mark as deprecated in a *.proto file.",
        value: 2,
        extensions: { protobufEnumValue: { name: "DEPRECATED_QUX" } },
      },
    } as const,
    extensions: {
      protobufEnum: {
        name: "DeprecatedEnum",
        fullName: "testapis.deprecation.DeprecatedEnum",
        package: "testapis.deprecation",
        options: { deprecated: true },
      },
    },
  });
",
    "name": "testapis/deprecation/deprecation.pb.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/deprecation/file_deprecation.proto

/* eslint-disable */

import { EnumRef, InputObjectRef } from "@pothos/core";
import {
  DeprecatedFileEnum,
  DeprecatedFileMessage,
  DeprecatedFileMessage_InnerMessage,
} from "@testapis/protobuf-es/testapis/deprecation/file_deprecation_pb";
import { builder } from "../../builder";

export const DeprecatedFileMessage$Ref = builder.objectRef<
  DeprecatedFileMessage
>("DeprecatedFileMessage");
builder.objectType(DeprecatedFileMessage$Ref, {
  name: "DeprecatedFileMessage",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      deprecationReason:
        "testapis/deprecation/file_deprecation.proto is mark as deprecated.",
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
    enum: t.field({
      type: DeprecatedFileEnum$Ref,
      nullable: true,
      deprecationReason:
        "testapis/deprecation/file_deprecation.proto is mark as deprecated.",
      resolve: (source) => {
        if (
          source.enum === DeprecatedFileEnum.DEPRECATED_FILE_ENUM_UNSPECIFIED
        ) {
          return null;
        }

        return source.enum;
      },
      extensions: {
        protobufField: {
          name: "enum",
          typeFullName: "testapis.deprecation.DeprecatedFileEnum",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof DeprecatedFileMessage;
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.deprecation.DeprecatedFileMessage",
      name: "DeprecatedFileMessage",
      package: "testapis.deprecation",
    },
  },
});

export const DeprecatedFileMessageInnerMessage$Ref = builder.objectRef<
  DeprecatedFileMessage_InnerMessage
>("DeprecatedFileMessageInnerMessage");
builder.objectType(DeprecatedFileMessageInnerMessage$Ref, {
  name: "DeprecatedFileMessageInnerMessage",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      deprecationReason:
        "testapis/deprecation/file_deprecation.proto is mark as deprecated.",
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof DeprecatedFileMessage_InnerMessage;
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.deprecation.DeprecatedFileMessage.InnerMessage",
      name: "InnerMessage",
      package: "testapis.deprecation",
    },
  },
});

export type DeprecatedFileMessageInput$Shape = {
  body?: DeprecatedFileMessage["body"] | null;
  enum?: DeprecatedFileMessage["enum"] | null;
};

export const DeprecatedFileMessageInput$Ref: InputObjectRef<
  DeprecatedFileMessageInput$Shape
> = builder.inputRef<DeprecatedFileMessageInput$Shape>(
  "DeprecatedFileMessageInput",
).implement(
  {
    fields: (t) => ({
      body: t.field({
        type: "String",
        required: false,
        deprecationReason:
          "testapis/deprecation/file_deprecation.proto is mark as deprecated.",
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
      enum: t.field({
        type: DeprecatedFileEnum$Ref,
        required: false,
        deprecationReason:
          "testapis/deprecation/file_deprecation.proto is mark as deprecated.",
        extensions: {
          protobufField: {
            name: "enum",
            typeFullName: "testapis.deprecation.DeprecatedFileEnum",
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.deprecation.DeprecatedFileMessage",
        name: "DeprecatedFileMessage",
        package: "testapis.deprecation",
      },
    },
  },
);

export function DeprecatedFileMessageInput$toProto(
  input: DeprecatedFileMessageInput$Shape | null | undefined,
): DeprecatedFileMessage {
  return new DeprecatedFileMessage({
    body: input?.body ?? undefined,
    enum: input?.enum ?? undefined,
  });
}

export type DeprecatedFileMessageInnerMessageInput$Shape = {
  body?: DeprecatedFileMessage_InnerMessage["body"] | null;
};

export const DeprecatedFileMessageInnerMessageInput$Ref: InputObjectRef<
  DeprecatedFileMessageInnerMessageInput$Shape
> = builder.inputRef<DeprecatedFileMessageInnerMessageInput$Shape>(
  "DeprecatedFileMessageInnerMessageInput",
).implement(
  {
    fields: (t) => ({
      body: t.field({
        type: "String",
        required: false,
        deprecationReason:
          "testapis/deprecation/file_deprecation.proto is mark as deprecated.",
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.deprecation.DeprecatedFileMessage.InnerMessage",
        name: "InnerMessage",
        package: "testapis.deprecation",
      },
    },
  },
);

export function DeprecatedFileMessageInnerMessageInput$toProto(
  input: DeprecatedFileMessageInnerMessageInput$Shape | null | undefined,
): DeprecatedFileMessage_InnerMessage {
  return new DeprecatedFileMessage_InnerMessage({
    body: input?.body ?? undefined,
  });
}

export const DeprecatedFileEnum$Ref: EnumRef<
  DeprecatedFileEnum,
  DeprecatedFileEnum
> = builder.enumType("DeprecatedFileEnum", {
  values: {
    DEPRECATED_FILE_FOO: {
      deprecationReason:
        "testapis/deprecation/file_deprecation.proto is mark as deprecated.",
      value: 1,
      extensions: { protobufEnumValue: { name: "DEPRECATED_FILE_FOO" } },
    },
    DEPRECATED_FILE_BAR: {
      deprecationReason:
        "testapis/deprecation/file_deprecation.proto is mark as deprecated.",
      value: 2,
      extensions: { protobufEnumValue: { name: "DEPRECATED_FILE_BAR" } },
    },
  } as const,
  extensions: {
    protobufEnum: {
      name: "DeprecatedFileEnum",
      fullName: "testapis.deprecation.DeprecatedFileEnum",
      package: "testapis.deprecation",
    },
  },
});
",
    "name": "testapis/deprecation/file_deprecation.pb.pothos.ts",
  },
]
`;

exports[`protobuf-es > 'testapis.deprecation' > generates files by plugin 'with partial inputs' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/deprecation/deprecation.proto

/* eslint-disable */

import { EnumRef, InputObjectRef } from "@pothos/core";
import {
  DeprecatedEnum,
  DeprecatedMessage,
  DeprecatedMessage_InnerMessage,
  NotDeprecatedEnum,
  NotDeprecatedMessage,
  NotDeprecatedMessage_InnerMessage1,
  NotDeprecatedMessage_InnerMessage2,
} from "@testapis/protobuf-es/testapis/deprecation/deprecation_pb";
import { builder } from "../../builder";

export const DeprecatedMessage$Ref = builder.objectRef<DeprecatedMessage>(
  "DeprecatedMessage",
);
builder.objectType(DeprecatedMessage$Ref, {
  name: "DeprecatedMessage",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      deprecationReason:
        "testapis.deprecation.DeprecatedMessage is mark as deprecated in a *.proto file.",
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
    enum: t.field({
      type: NotDeprecatedEnum$Ref,
      nullable: true,
      deprecationReason:
        "testapis.deprecation.DeprecatedMessage is mark as deprecated in a *.proto file.",
      resolve: (source) => {
        if (source.enum === NotDeprecatedEnum.NOT_DEPRECATED_ENUM_UNSPECIFIED) {
          return null;
        }

        return source.enum;
      },
      extensions: {
        protobufField: {
          name: "enum",
          typeFullName: "testapis.deprecation.NotDeprecatedEnum",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof DeprecatedMessage;
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.deprecation.DeprecatedMessage",
      name: "DeprecatedMessage",
      package: "testapis.deprecation",
      options: { deprecated: true },
    },
  },
});

export const NotDeprecatedMessage$Ref = builder.objectRef<NotDeprecatedMessage>(
  "NotDeprecatedMessage",
);
builder.objectType(NotDeprecatedMessage$Ref, {
  name: "NotDeprecatedMessage",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      deprecationReason:
        "testapis.deprecation.NotDeprecatedMessage.body is mark as deprecated in a *.proto file.",
      extensions: {
        protobufField: {
          name: "body",
          typeFullName: "string",
          options: { deprecated: true },
        },
      },
    }),
    enum: t.field({
      type: DeprecatedEnum$Ref,
      nullable: true,
      deprecationReason:
        "testapis.deprecation.DeprecatedEnum is mark as deprecated in a *.proto file.",
      resolve: (source) => {
        if (source.enum === DeprecatedEnum.DEPRECATED_ENUM_UNSPECIFIED) {
          return null;
        }

        return source.enum;
      },
      extensions: {
        protobufField: {
          name: "enum",
          typeFullName: "testapis.deprecation.DeprecatedEnum",
        },
      },
    }),
    notDeprecatedOneof: t.field({
      type: NotDeprecatedMessageNotDeprecatedOneof$Ref,
      nullable: true,
      resolve: (source) => {
        return source.notDeprecatedOneof.value;
      },
      extensions: { protobufField: { name: "not_deprecated_oneof" } },
    }),
    deprecatedOneof: t.field({
      type: NotDeprecatedMessageDeprecatedOneof$Ref,
      nullable: true,
      deprecationReason:
        "testapis.deprecation.NotDeprecatedMessage.deprecated_oneof is mark as deprecated in a *.proto file.",
      resolve: (source) => {
        return source.deprecatedOneof.value;
      },
      extensions: { protobufField: { name: "deprecated_oneof" } },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof NotDeprecatedMessage;
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.deprecation.NotDeprecatedMessage",
      name: "NotDeprecatedMessage",
      package: "testapis.deprecation",
    },
  },
});

export const DeprecatedMessageInnerMessage$Ref = builder.objectRef<
  DeprecatedMessage_InnerMessage
>("DeprecatedMessageInnerMessage");
builder.objectType(DeprecatedMessageInnerMessage$Ref, {
  name: "DeprecatedMessageInnerMessage",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      deprecationReason:
        "testapis.deprecation.DeprecatedMessage is mark as deprecated in a *.proto file.",
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof DeprecatedMessage_InnerMessage;
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.deprecation.DeprecatedMessage.InnerMessage",
      name: "InnerMessage",
      package: "testapis.deprecation",
    },
  },
});

export const NotDeprecatedMessageInnerMessage1$Ref = builder.objectRef<
  NotDeprecatedMessage_InnerMessage1
>("NotDeprecatedMessageInnerMessage1");
builder.objectType(NotDeprecatedMessageInnerMessage1$Ref, {
  name: "NotDeprecatedMessageInnerMessage1",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof NotDeprecatedMessage_InnerMessage1;
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.deprecation.NotDeprecatedMessage.InnerMessage1",
      name: "InnerMessage1",
      package: "testapis.deprecation",
    },
  },
});

export const NotDeprecatedMessageInnerMessage2$Ref = builder.objectRef<
  NotDeprecatedMessage_InnerMessage2
>("NotDeprecatedMessageInnerMessage2");
builder.objectType(NotDeprecatedMessageInnerMessage2$Ref, {
  name: "NotDeprecatedMessageInnerMessage2",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof NotDeprecatedMessage_InnerMessage2;
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.deprecation.NotDeprecatedMessage.InnerMessage2",
      name: "InnerMessage2",
      package: "testapis.deprecation",
    },
  },
});

export type DeprecatedMessageInput$Shape = {
  body?: DeprecatedMessage["body"] | null;
  enum?: DeprecatedMessage["enum"] | null;
};

export const DeprecatedMessageInput$Ref: InputObjectRef<
  DeprecatedMessageInput$Shape
> = builder.inputRef<DeprecatedMessageInput$Shape>("DeprecatedMessageInput")
  .implement(
    {
      fields: (t) => ({
        body: t.field({
          type: "String",
          required: false,
          deprecationReason:
            "testapis.deprecation.DeprecatedMessage is mark as deprecated in a *.proto file.",
          extensions: {
            protobufField: { name: "body", typeFullName: "string" },
          },
        }),
        enum: t.field({
          type: NotDeprecatedEnum$Ref,
          required: false,
          deprecationReason:
            "testapis.deprecation.DeprecatedMessage is mark as deprecated in a *.proto file.",
          extensions: {
            protobufField: {
              name: "enum",
              typeFullName: "testapis.deprecation.NotDeprecatedEnum",
            },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.deprecation.DeprecatedMessage",
          name: "DeprecatedMessage",
          package: "testapis.deprecation",
          options: { deprecated: true },
        },
      },
    },
  );

export function DeprecatedMessageInput$toProto(
  input: DeprecatedMessageInput$Shape | null | undefined,
): DeprecatedMessage {
  return new DeprecatedMessage({
    body: input?.body ?? undefined,
    enum: input?.enum ?? undefined,
  });
}

export type DeprecatedMessagePartialInput$Shape = {
  body?: DeprecatedMessage["body"] | null;
  enum?: DeprecatedMessage["enum"] | null;
};

export const DeprecatedMessagePartialInput$Ref: InputObjectRef<
  DeprecatedMessagePartialInput$Shape
> = builder.inputRef<DeprecatedMessagePartialInput$Shape>(
  "DeprecatedMessagePartialInput",
).implement(
  {
    fields: (t) => ({
      body: t.field({
        type: "String",
        required: false,
        deprecationReason:
          "testapis.deprecation.DeprecatedMessage is mark as deprecated in a *.proto file.",
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
      enum: t.field({
        type: NotDeprecatedEnum$Ref,
        required: false,
        deprecationReason:
          "testapis.deprecation.DeprecatedMessage is mark as deprecated in a *.proto file.",
        extensions: {
          protobufField: {
            name: "enum",
            typeFullName: "testapis.deprecation.NotDeprecatedEnum",
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.deprecation.DeprecatedMessage",
        name: "DeprecatedMessage",
        package: "testapis.deprecation",
        options: { deprecated: true },
      },
    },
  },
);

export function DeprecatedMessagePartialInput$toProto(
  input: DeprecatedMessagePartialInput$Shape | null | undefined,
): DeprecatedMessage {
  return new DeprecatedMessage({
    body: input?.body ?? undefined,
    enum: input?.enum ?? undefined,
  });
}

export type NotDeprecatedMessageInput$Shape = {
  body?: NotDeprecatedMessage["body"] | null;
  enum?: NotDeprecatedMessage["enum"] | null;
  msg1?: NotDeprecatedMessageInnerMessage1Input$Shape | null;
  msg2?: NotDeprecatedMessageInnerMessage2Input$Shape | null;
  msg3?: NotDeprecatedMessageInnerMessage1Input$Shape | null;
  msg4?: NotDeprecatedMessageInnerMessage2Input$Shape | null;
};

export const NotDeprecatedMessageInput$Ref: InputObjectRef<
  NotDeprecatedMessageInput$Shape
> = builder.inputRef<NotDeprecatedMessageInput$Shape>(
  "NotDeprecatedMessageInput",
).implement(
  {
    fields: (t) => ({
      body: t.field({
        type: "String",
        required: false,
        deprecationReason:
          "testapis.deprecation.NotDeprecatedMessage.body is mark as deprecated in a *.proto file.",
        extensions: {
          protobufField: {
            name: "body",
            typeFullName: "string",
            options: { deprecated: true },
          },
        },
      }),
      enum: t.field({
        type: DeprecatedEnum$Ref,
        required: false,
        deprecationReason:
          "testapis.deprecation.DeprecatedEnum is mark as deprecated in a *.proto file.",
        extensions: {
          protobufField: {
            name: "enum",
            typeFullName: "testapis.deprecation.DeprecatedEnum",
          },
        },
      }),
      msg1: t.field({
        type: NotDeprecatedMessageInnerMessage1Input$Ref,
        required: false,
        deprecationReason:
          "testapis.deprecation.NotDeprecatedMessage.msg1 is mark as deprecated in a *.proto file.",
        extensions: {
          protobufField: {
            name: "msg1",
            typeFullName:
              "testapis.deprecation.NotDeprecatedMessage.InnerMessage1",
            options: { deprecated: true },
          },
        },
      }),
      msg2: t.field({
        type: NotDeprecatedMessageInnerMessage2Input$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "msg2",
            typeFullName:
              "testapis.deprecation.NotDeprecatedMessage.InnerMessage2",
          },
        },
      }),
      msg3: t.field({
        type: NotDeprecatedMessageInnerMessage1Input$Ref,
        required: false,
        deprecationReason:
          "testapis.deprecation.NotDeprecatedMessage.msg3 is mark as deprecated in a *.proto file.",
        extensions: {
          protobufField: {
            name: "msg3",
            typeFullName:
              "testapis.deprecation.NotDeprecatedMessage.InnerMessage1",
            options: { deprecated: true },
          },
        },
      }),
      msg4: t.field({
        type: NotDeprecatedMessageInnerMessage2Input$Ref,
        required: false,
        deprecationReason:
          "testapis.deprecation.NotDeprecatedMessage.msg4 is mark as deprecated in a *.proto file.",
        extensions: {
          protobufField: {
            name: "msg4",
            typeFullName:
              "testapis.deprecation.NotDeprecatedMessage.InnerMessage2",
            options: { deprecated: true },
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.deprecation.NotDeprecatedMessage",
        name: "NotDeprecatedMessage",
        package: "testapis.deprecation",
      },
    },
  },
);

export function NotDeprecatedMessageInput$toProto(
  input: NotDeprecatedMessageInput$Shape | null | undefined,
): NotDeprecatedMessage {
  return new NotDeprecatedMessage({
    body: input?.body ?? undefined,
    enum: input?.enum ?? undefined,
    notDeprecatedOneof: input?.msg1
      ? {
        case: "msg1",
        value: NotDeprecatedMessageInnerMessage1Input$toProto(input.msg1),
      }
      : input?.msg2
      ? {
        case: "msg2",
        value: NotDeprecatedMessageInnerMessage2Input$toProto(input.msg2),
      }
      : undefined,
    deprecatedOneof: input?.msg3
      ? {
        case: "msg3",
        value: NotDeprecatedMessageInnerMessage1Input$toProto(input.msg3),
      }
      : input?.msg4
      ? {
        case: "msg4",
        value: NotDeprecatedMessageInnerMessage2Input$toProto(input.msg4),
      }
      : undefined,
  });
}

export type NotDeprecatedMessagePartialInput$Shape = {
  body?: NotDeprecatedMessage["body"] | null;
  enum?: NotDeprecatedMessage["enum"] | null;
  msg1?: NotDeprecatedMessageInnerMessage1PartialInput$Shape | null;
  msg2?: NotDeprecatedMessageInnerMessage2PartialInput$Shape | null;
  msg3?: NotDeprecatedMessageInnerMessage1PartialInput$Shape | null;
  msg4?: NotDeprecatedMessageInnerMessage2PartialInput$Shape | null;
};

export const NotDeprecatedMessagePartialInput$Ref: InputObjectRef<
  NotDeprecatedMessagePartialInput$Shape
> = builder.inputRef<NotDeprecatedMessagePartialInput$Shape>(
  "NotDeprecatedMessagePartialInput",
).implement(
  {
    fields: (t) => ({
      body: t.field({
        type: "String",
        required: false,
        deprecationReason:
          "testapis.deprecation.NotDeprecatedMessage.body is mark as deprecated in a *.proto file.",
        extensions: {
          protobufField: {
            name: "body",
            typeFullName: "string",
            options: { deprecated: true },
          },
        },
      }),
      enum: t.field({
        type: DeprecatedEnum$Ref,
        required: false,
        deprecationReason:
          "testapis.deprecation.DeprecatedEnum is mark as deprecated in a *.proto file.",
        extensions: {
          protobufField: {
            name: "enum",
            typeFullName: "testapis.deprecation.DeprecatedEnum",
          },
        },
      }),
      msg1: t.field({
        type: NotDeprecatedMessageInnerMessage1PartialInput$Ref,
        required: false,
        deprecationReason:
          "testapis.deprecation.NotDeprecatedMessage.msg1 is mark as deprecated in a *.proto file.",
        extensions: {
          protobufField: {
            name: "msg1",
            typeFullName:
              "testapis.deprecation.NotDeprecatedMessage.InnerMessage1",
            options: { deprecated: true },
          },
        },
      }),
      msg2: t.field({
        type: NotDeprecatedMessageInnerMessage2PartialInput$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "msg2",
            typeFullName:
              "testapis.deprecation.NotDeprecatedMessage.InnerMessage2",
          },
        },
      }),
      msg3: t.field({
        type: NotDeprecatedMessageInnerMessage1PartialInput$Ref,
        required: false,
        deprecationReason:
          "testapis.deprecation.NotDeprecatedMessage.msg3 is mark as deprecated in a *.proto file.",
        extensions: {
          protobufField: {
            name: "msg3",
            typeFullName:
              "testapis.deprecation.NotDeprecatedMessage.InnerMessage1",
            options: { deprecated: true },
          },
        },
      }),
      msg4: t.field({
        type: NotDeprecatedMessageInnerMessage2PartialInput$Ref,
        required: false,
        deprecationReason:
          "testapis.deprecation.NotDeprecatedMessage.msg4 is mark as deprecated in a *.proto file.",
        extensions: {
          protobufField: {
            name: "msg4",
            typeFullName:
              "testapis.deprecation.NotDeprecatedMessage.InnerMessage2",
            options: { deprecated: true },
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.deprecation.NotDeprecatedMessage",
        name: "NotDeprecatedMessage",
        package: "testapis.deprecation",
      },
    },
  },
);

export function NotDeprecatedMessagePartialInput$toProto(
  input: NotDeprecatedMessagePartialInput$Shape | null | undefined,
): NotDeprecatedMessage {
  return new NotDeprecatedMessage({
    body: input?.body ?? undefined,
    enum: input?.enum ?? undefined,
    notDeprecatedOneof: input?.msg1
      ? {
        case: "msg1",
        value: NotDeprecatedMessageInnerMessage1PartialInput$toProto(
          input.msg1,
        ),
      }
      : input?.msg2
      ? {
        case: "msg2",
        value: NotDeprecatedMessageInnerMessage2PartialInput$toProto(
          input.msg2,
        ),
      }
      : undefined,
    deprecatedOneof: input?.msg3
      ? {
        case: "msg3",
        value: NotDeprecatedMessageInnerMessage1PartialInput$toProto(
          input.msg3,
        ),
      }
      : input?.msg4
      ? {
        case: "msg4",
        value: NotDeprecatedMessageInnerMessage2PartialInput$toProto(
          input.msg4,
        ),
      }
      : undefined,
  });
}

export type DeprecatedMessageInnerMessageInput$Shape = {
  body?: DeprecatedMessage_InnerMessage["body"] | null;
};

export const DeprecatedMessageInnerMessageInput$Ref: InputObjectRef<
  DeprecatedMessageInnerMessageInput$Shape
> = builder.inputRef<DeprecatedMessageInnerMessageInput$Shape>(
  "DeprecatedMessageInnerMessageInput",
).implement(
  {
    fields: (t) => ({
      body: t.field({
        type: "String",
        required: false,
        deprecationReason:
          "testapis.deprecation.DeprecatedMessage is mark as deprecated in a *.proto file.",
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.deprecation.DeprecatedMessage.InnerMessage",
        name: "InnerMessage",
        package: "testapis.deprecation",
      },
    },
  },
);

export function DeprecatedMessageInnerMessageInput$toProto(
  input: DeprecatedMessageInnerMessageInput$Shape | null | undefined,
): DeprecatedMessage_InnerMessage {
  return new DeprecatedMessage_InnerMessage({
    body: input?.body ?? undefined,
  });
}

export type DeprecatedMessageInnerMessagePartialInput$Shape = {
  body?: DeprecatedMessage_InnerMessage["body"] | null;
};

export const DeprecatedMessageInnerMessagePartialInput$Ref: InputObjectRef<
  DeprecatedMessageInnerMessagePartialInput$Shape
> = builder.inputRef<DeprecatedMessageInnerMessagePartialInput$Shape>(
  "DeprecatedMessageInnerMessagePartialInput",
).implement(
  {
    fields: (t) => ({
      body: t.field({
        type: "String",
        required: false,
        deprecationReason:
          "testapis.deprecation.DeprecatedMessage is mark as deprecated in a *.proto file.",
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.deprecation.DeprecatedMessage.InnerMessage",
        name: "InnerMessage",
        package: "testapis.deprecation",
      },
    },
  },
);

export function DeprecatedMessageInnerMessagePartialInput$toProto(
  input: DeprecatedMessageInnerMessagePartialInput$Shape | null | undefined,
): DeprecatedMessage_InnerMessage {
  return new DeprecatedMessage_InnerMessage({
    body: input?.body ?? undefined,
  });
}

export type NotDeprecatedMessageInnerMessage1Input$Shape = {
  body: NotDeprecatedMessage_InnerMessage1["body"];
};

export const NotDeprecatedMessageInnerMessage1Input$Ref: InputObjectRef<
  NotDeprecatedMessageInnerMessage1Input$Shape
> = builder.inputRef<NotDeprecatedMessageInnerMessage1Input$Shape>(
  "NotDeprecatedMessageInnerMessage1Input",
).implement(
  {
    fields: (t) => ({
      body: t.field({
        type: "String",
        required: true,
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.deprecation.NotDeprecatedMessage.InnerMessage1",
        name: "InnerMessage1",
        package: "testapis.deprecation",
      },
    },
  },
);

export function NotDeprecatedMessageInnerMessage1Input$toProto(
  input: NotDeprecatedMessageInnerMessage1Input$Shape | null | undefined,
): NotDeprecatedMessage_InnerMessage1 {
  return new NotDeprecatedMessage_InnerMessage1({
    body: input?.body ?? undefined,
  });
}

export type NotDeprecatedMessageInnerMessage1PartialInput$Shape = {
  body?: NotDeprecatedMessage_InnerMessage1["body"] | null;
};

export const NotDeprecatedMessageInnerMessage1PartialInput$Ref: InputObjectRef<
  NotDeprecatedMessageInnerMessage1PartialInput$Shape
> = builder.inputRef<NotDeprecatedMessageInnerMessage1PartialInput$Shape>(
  "NotDeprecatedMessageInnerMessage1PartialInput",
).implement(
  {
    fields: (t) => ({
      body: t.field({
        type: "String",
        required: false,
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.deprecation.NotDeprecatedMessage.InnerMessage1",
        name: "InnerMessage1",
        package: "testapis.deprecation",
      },
    },
  },
);

export function NotDeprecatedMessageInnerMessage1PartialInput$toProto(
  input: NotDeprecatedMessageInnerMessage1PartialInput$Shape | null | undefined,
): NotDeprecatedMessage_InnerMessage1 {
  return new NotDeprecatedMessage_InnerMessage1({
    body: input?.body ?? undefined,
  });
}

export type NotDeprecatedMessageInnerMessage2Input$Shape = {
  body: NotDeprecatedMessage_InnerMessage2["body"];
};

export const NotDeprecatedMessageInnerMessage2Input$Ref: InputObjectRef<
  NotDeprecatedMessageInnerMessage2Input$Shape
> = builder.inputRef<NotDeprecatedMessageInnerMessage2Input$Shape>(
  "NotDeprecatedMessageInnerMessage2Input",
).implement(
  {
    fields: (t) => ({
      body: t.field({
        type: "String",
        required: true,
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.deprecation.NotDeprecatedMessage.InnerMessage2",
        name: "InnerMessage2",
        package: "testapis.deprecation",
      },
    },
  },
);

export function NotDeprecatedMessageInnerMessage2Input$toProto(
  input: NotDeprecatedMessageInnerMessage2Input$Shape | null | undefined,
): NotDeprecatedMessage_InnerMessage2 {
  return new NotDeprecatedMessage_InnerMessage2({
    body: input?.body ?? undefined,
  });
}

export type NotDeprecatedMessageInnerMessage2PartialInput$Shape = {
  body?: NotDeprecatedMessage_InnerMessage2["body"] | null;
};

export const NotDeprecatedMessageInnerMessage2PartialInput$Ref: InputObjectRef<
  NotDeprecatedMessageInnerMessage2PartialInput$Shape
> = builder.inputRef<NotDeprecatedMessageInnerMessage2PartialInput$Shape>(
  "NotDeprecatedMessageInnerMessage2PartialInput",
).implement(
  {
    fields: (t) => ({
      body: t.field({
        type: "String",
        required: false,
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.deprecation.NotDeprecatedMessage.InnerMessage2",
        name: "InnerMessage2",
        package: "testapis.deprecation",
      },
    },
  },
);

export function NotDeprecatedMessageInnerMessage2PartialInput$toProto(
  input: NotDeprecatedMessageInnerMessage2PartialInput$Shape | null | undefined,
): NotDeprecatedMessage_InnerMessage2 {
  return new NotDeprecatedMessage_InnerMessage2({
    body: input?.body ?? undefined,
  });
}

export const NotDeprecatedMessageNotDeprecatedOneof$Ref = builder.unionType(
  "NotDeprecatedMessageNotDeprecatedOneof",
  {
    types: [
      NotDeprecatedMessageInnerMessage1$Ref,
      NotDeprecatedMessageInnerMessage2$Ref,
    ],
    extensions: {
      protobufOneof: {
        fullName:
          "testapis.deprecation.NotDeprecatedMessage.not_deprecated_oneof",
        name: "not_deprecated_oneof",
        messageName: "NotDeprecatedMessage",
        package: "testapis.deprecation",
        fields: [{
          name: "msg1",
          type: "testapis.deprecation.NotDeprecatedMessage.InnerMessage1",
        }, {
          name: "msg2",
          type: "testapis.deprecation.NotDeprecatedMessage.InnerMessage2",
        }],
      },
    },
  },
);

export const NotDeprecatedMessageDeprecatedOneof$Ref = builder.unionType(
  "NotDeprecatedMessageDeprecatedOneof",
  {
    types: [
      NotDeprecatedMessageInnerMessage1$Ref,
      NotDeprecatedMessageInnerMessage2$Ref,
    ],
    extensions: {
      protobufOneof: {
        fullName: "testapis.deprecation.NotDeprecatedMessage.deprecated_oneof",
        name: "deprecated_oneof",
        messageName: "NotDeprecatedMessage",
        package: "testapis.deprecation",
        fields: [{
          name: "msg3",
          type: "testapis.deprecation.NotDeprecatedMessage.InnerMessage1",
        }, {
          name: "msg4",
          type: "testapis.deprecation.NotDeprecatedMessage.InnerMessage2",
        }],
      },
    },
  },
);

export const NotDeprecatedEnum$Ref: EnumRef<
  NotDeprecatedEnum,
  NotDeprecatedEnum
> = builder.enumType("NotDeprecatedEnum", {
  values: {
    NOT_DEPRECATED_FOO: {
      value: 1,
      extensions: { protobufEnumValue: { name: "NOT_DEPRECATED_FOO" } },
    },
    DEPRECATED_BAR: {
      deprecationReason:
        "testapis.deprecation.NotDeprecatedEnum.DEPRECATED_BAR is mark as deprecated in a *.proto file.",
      value: 2,
      extensions: {
        protobufEnumValue: {
          name: "DEPRECATED_BAR",
          options: { deprecated: true },
        },
      },
    },
  } as const,
  extensions: {
    protobufEnum: {
      name: "NotDeprecatedEnum",
      fullName: "testapis.deprecation.NotDeprecatedEnum",
      package: "testapis.deprecation",
    },
  },
});

export const DeprecatedEnum$Ref: EnumRef<DeprecatedEnum, DeprecatedEnum> =
  builder.enumType("DeprecatedEnum", {
    values: {
      DEPRECATED_BAZ: {
        deprecationReason:
          "testapis.deprecation.DeprecatedEnum is mark as deprecated in a *.proto file.",
        value: 1,
        extensions: { protobufEnumValue: { name: "DEPRECATED_BAZ" } },
      },
      DEPRECATED_QUX: {
        deprecationReason:
          "testapis.deprecation.DeprecatedEnum is mark as deprecated in a *.proto file.",
        value: 2,
        extensions: { protobufEnumValue: { name: "DEPRECATED_QUX" } },
      },
    } as const,
    extensions: {
      protobufEnum: {
        name: "DeprecatedEnum",
        fullName: "testapis.deprecation.DeprecatedEnum",
        package: "testapis.deprecation",
        options: { deprecated: true },
      },
    },
  });
",
    "name": "testapis/deprecation/deprecation.pb.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/deprecation/file_deprecation.proto

/* eslint-disable */

import { EnumRef, InputObjectRef } from "@pothos/core";
import {
  DeprecatedFileEnum,
  DeprecatedFileMessage,
  DeprecatedFileMessage_InnerMessage,
} from "@testapis/protobuf-es/testapis/deprecation/file_deprecation_pb";
import { builder } from "../../builder";

export const DeprecatedFileMessage$Ref = builder.objectRef<
  DeprecatedFileMessage
>("DeprecatedFileMessage");
builder.objectType(DeprecatedFileMessage$Ref, {
  name: "DeprecatedFileMessage",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      deprecationReason:
        "testapis/deprecation/file_deprecation.proto is mark as deprecated.",
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
    enum: t.field({
      type: DeprecatedFileEnum$Ref,
      nullable: true,
      deprecationReason:
        "testapis/deprecation/file_deprecation.proto is mark as deprecated.",
      resolve: (source) => {
        if (
          source.enum === DeprecatedFileEnum.DEPRECATED_FILE_ENUM_UNSPECIFIED
        ) {
          return null;
        }

        return source.enum;
      },
      extensions: {
        protobufField: {
          name: "enum",
          typeFullName: "testapis.deprecation.DeprecatedFileEnum",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof DeprecatedFileMessage;
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.deprecation.DeprecatedFileMessage",
      name: "DeprecatedFileMessage",
      package: "testapis.deprecation",
    },
  },
});

export const DeprecatedFileMessageInnerMessage$Ref = builder.objectRef<
  DeprecatedFileMessage_InnerMessage
>("DeprecatedFileMessageInnerMessage");
builder.objectType(DeprecatedFileMessageInnerMessage$Ref, {
  name: "DeprecatedFileMessageInnerMessage",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      deprecationReason:
        "testapis/deprecation/file_deprecation.proto is mark as deprecated.",
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof DeprecatedFileMessage_InnerMessage;
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.deprecation.DeprecatedFileMessage.InnerMessage",
      name: "InnerMessage",
      package: "testapis.deprecation",
    },
  },
});

export type DeprecatedFileMessageInput$Shape = {
  body?: DeprecatedFileMessage["body"] | null;
  enum?: DeprecatedFileMessage["enum"] | null;
};

export const DeprecatedFileMessageInput$Ref: InputObjectRef<
  DeprecatedFileMessageInput$Shape
> = builder.inputRef<DeprecatedFileMessageInput$Shape>(
  "DeprecatedFileMessageInput",
).implement(
  {
    fields: (t) => ({
      body: t.field({
        type: "String",
        required: false,
        deprecationReason:
          "testapis/deprecation/file_deprecation.proto is mark as deprecated.",
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
      enum: t.field({
        type: DeprecatedFileEnum$Ref,
        required: false,
        deprecationReason:
          "testapis/deprecation/file_deprecation.proto is mark as deprecated.",
        extensions: {
          protobufField: {
            name: "enum",
            typeFullName: "testapis.deprecation.DeprecatedFileEnum",
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.deprecation.DeprecatedFileMessage",
        name: "DeprecatedFileMessage",
        package: "testapis.deprecation",
      },
    },
  },
);

export function DeprecatedFileMessageInput$toProto(
  input: DeprecatedFileMessageInput$Shape | null | undefined,
): DeprecatedFileMessage {
  return new DeprecatedFileMessage({
    body: input?.body ?? undefined,
    enum: input?.enum ?? undefined,
  });
}

export type DeprecatedFileMessagePartialInput$Shape = {
  body?: DeprecatedFileMessage["body"] | null;
  enum?: DeprecatedFileMessage["enum"] | null;
};

export const DeprecatedFileMessagePartialInput$Ref: InputObjectRef<
  DeprecatedFileMessagePartialInput$Shape
> = builder.inputRef<DeprecatedFileMessagePartialInput$Shape>(
  "DeprecatedFileMessagePartialInput",
).implement(
  {
    fields: (t) => ({
      body: t.field({
        type: "String",
        required: false,
        deprecationReason:
          "testapis/deprecation/file_deprecation.proto is mark as deprecated.",
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
      enum: t.field({
        type: DeprecatedFileEnum$Ref,
        required: false,
        deprecationReason:
          "testapis/deprecation/file_deprecation.proto is mark as deprecated.",
        extensions: {
          protobufField: {
            name: "enum",
            typeFullName: "testapis.deprecation.DeprecatedFileEnum",
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.deprecation.DeprecatedFileMessage",
        name: "DeprecatedFileMessage",
        package: "testapis.deprecation",
      },
    },
  },
);

export function DeprecatedFileMessagePartialInput$toProto(
  input: DeprecatedFileMessagePartialInput$Shape | null | undefined,
): DeprecatedFileMessage {
  return new DeprecatedFileMessage({
    body: input?.body ?? undefined,
    enum: input?.enum ?? undefined,
  });
}

export type DeprecatedFileMessageInnerMessageInput$Shape = {
  body?: DeprecatedFileMessage_InnerMessage["body"] | null;
};

export const DeprecatedFileMessageInnerMessageInput$Ref: InputObjectRef<
  DeprecatedFileMessageInnerMessageInput$Shape
> = builder.inputRef<DeprecatedFileMessageInnerMessageInput$Shape>(
  "DeprecatedFileMessageInnerMessageInput",
).implement(
  {
    fields: (t) => ({
      body: t.field({
        type: "String",
        required: false,
        deprecationReason:
          "testapis/deprecation/file_deprecation.proto is mark as deprecated.",
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.deprecation.DeprecatedFileMessage.InnerMessage",
        name: "InnerMessage",
        package: "testapis.deprecation",
      },
    },
  },
);

export function DeprecatedFileMessageInnerMessageInput$toProto(
  input: DeprecatedFileMessageInnerMessageInput$Shape | null | undefined,
): DeprecatedFileMessage_InnerMessage {
  return new DeprecatedFileMessage_InnerMessage({
    body: input?.body ?? undefined,
  });
}

export type DeprecatedFileMessageInnerMessagePartialInput$Shape = {
  body?: DeprecatedFileMessage_InnerMessage["body"] | null;
};

export const DeprecatedFileMessageInnerMessagePartialInput$Ref: InputObjectRef<
  DeprecatedFileMessageInnerMessagePartialInput$Shape
> = builder.inputRef<DeprecatedFileMessageInnerMessagePartialInput$Shape>(
  "DeprecatedFileMessageInnerMessagePartialInput",
).implement(
  {
    fields: (t) => ({
      body: t.field({
        type: "String",
        required: false,
        deprecationReason:
          "testapis/deprecation/file_deprecation.proto is mark as deprecated.",
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.deprecation.DeprecatedFileMessage.InnerMessage",
        name: "InnerMessage",
        package: "testapis.deprecation",
      },
    },
  },
);

export function DeprecatedFileMessageInnerMessagePartialInput$toProto(
  input: DeprecatedFileMessageInnerMessagePartialInput$Shape | null | undefined,
): DeprecatedFileMessage_InnerMessage {
  return new DeprecatedFileMessage_InnerMessage({
    body: input?.body ?? undefined,
  });
}

export const DeprecatedFileEnum$Ref: EnumRef<
  DeprecatedFileEnum,
  DeprecatedFileEnum
> = builder.enumType("DeprecatedFileEnum", {
  values: {
    DEPRECATED_FILE_FOO: {
      deprecationReason:
        "testapis/deprecation/file_deprecation.proto is mark as deprecated.",
      value: 1,
      extensions: { protobufEnumValue: { name: "DEPRECATED_FILE_FOO" } },
    },
    DEPRECATED_FILE_BAR: {
      deprecationReason:
        "testapis/deprecation/file_deprecation.proto is mark as deprecated.",
      value: 2,
      extensions: { protobufEnumValue: { name: "DEPRECATED_FILE_BAR" } },
    },
  } as const,
  extensions: {
    protobufEnum: {
      name: "DeprecatedFileEnum",
      fullName: "testapis.deprecation.DeprecatedFileEnum",
      package: "testapis.deprecation",
    },
  },
});
",
    "name": "testapis/deprecation/file_deprecation.pb.pothos.ts",
  },
]
`;

exports[`protobuf-es > 'testapis.deprecation' > generates files by plugin 'without import prefix' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/deprecation/deprecation.proto

/* eslint-disable */

import { EnumRef, InputObjectRef } from "@pothos/core";
import { builder } from "../../builder";
import {
  DeprecatedEnum,
  DeprecatedMessage,
  DeprecatedMessage_InnerMessage,
  NotDeprecatedEnum,
  NotDeprecatedMessage,
  NotDeprecatedMessage_InnerMessage1,
  NotDeprecatedMessage_InnerMessage2,
} from "./testapis/deprecation/deprecation_pb";

export const DeprecatedMessage$Ref = builder.objectRef<DeprecatedMessage>(
  "DeprecatedMessage",
);
builder.objectType(DeprecatedMessage$Ref, {
  name: "DeprecatedMessage",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      deprecationReason:
        "testapis.deprecation.DeprecatedMessage is mark as deprecated in a *.proto file.",
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
    enum: t.field({
      type: NotDeprecatedEnum$Ref,
      nullable: true,
      deprecationReason:
        "testapis.deprecation.DeprecatedMessage is mark as deprecated in a *.proto file.",
      resolve: (source) => {
        if (source.enum === NotDeprecatedEnum.NOT_DEPRECATED_ENUM_UNSPECIFIED) {
          return null;
        }

        return source.enum;
      },
      extensions: {
        protobufField: {
          name: "enum",
          typeFullName: "testapis.deprecation.NotDeprecatedEnum",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof DeprecatedMessage;
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.deprecation.DeprecatedMessage",
      name: "DeprecatedMessage",
      package: "testapis.deprecation",
      options: { deprecated: true },
    },
  },
});

export const NotDeprecatedMessage$Ref = builder.objectRef<NotDeprecatedMessage>(
  "NotDeprecatedMessage",
);
builder.objectType(NotDeprecatedMessage$Ref, {
  name: "NotDeprecatedMessage",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      deprecationReason:
        "testapis.deprecation.NotDeprecatedMessage.body is mark as deprecated in a *.proto file.",
      extensions: {
        protobufField: {
          name: "body",
          typeFullName: "string",
          options: { deprecated: true },
        },
      },
    }),
    enum: t.field({
      type: DeprecatedEnum$Ref,
      nullable: true,
      deprecationReason:
        "testapis.deprecation.DeprecatedEnum is mark as deprecated in a *.proto file.",
      resolve: (source) => {
        if (source.enum === DeprecatedEnum.DEPRECATED_ENUM_UNSPECIFIED) {
          return null;
        }

        return source.enum;
      },
      extensions: {
        protobufField: {
          name: "enum",
          typeFullName: "testapis.deprecation.DeprecatedEnum",
        },
      },
    }),
    notDeprecatedOneof: t.field({
      type: NotDeprecatedMessageNotDeprecatedOneof$Ref,
      nullable: true,
      resolve: (source) => {
        return source.notDeprecatedOneof.value;
      },
      extensions: { protobufField: { name: "not_deprecated_oneof" } },
    }),
    deprecatedOneof: t.field({
      type: NotDeprecatedMessageDeprecatedOneof$Ref,
      nullable: true,
      deprecationReason:
        "testapis.deprecation.NotDeprecatedMessage.deprecated_oneof is mark as deprecated in a *.proto file.",
      resolve: (source) => {
        return source.deprecatedOneof.value;
      },
      extensions: { protobufField: { name: "deprecated_oneof" } },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof NotDeprecatedMessage;
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.deprecation.NotDeprecatedMessage",
      name: "NotDeprecatedMessage",
      package: "testapis.deprecation",
    },
  },
});

export const DeprecatedMessageInnerMessage$Ref = builder.objectRef<
  DeprecatedMessage_InnerMessage
>("DeprecatedMessageInnerMessage");
builder.objectType(DeprecatedMessageInnerMessage$Ref, {
  name: "DeprecatedMessageInnerMessage",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      deprecationReason:
        "testapis.deprecation.DeprecatedMessage is mark as deprecated in a *.proto file.",
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof DeprecatedMessage_InnerMessage;
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.deprecation.DeprecatedMessage.InnerMessage",
      name: "InnerMessage",
      package: "testapis.deprecation",
    },
  },
});

export const NotDeprecatedMessageInnerMessage1$Ref = builder.objectRef<
  NotDeprecatedMessage_InnerMessage1
>("NotDeprecatedMessageInnerMessage1");
builder.objectType(NotDeprecatedMessageInnerMessage1$Ref, {
  name: "NotDeprecatedMessageInnerMessage1",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof NotDeprecatedMessage_InnerMessage1;
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.deprecation.NotDeprecatedMessage.InnerMessage1",
      name: "InnerMessage1",
      package: "testapis.deprecation",
    },
  },
});

export const NotDeprecatedMessageInnerMessage2$Ref = builder.objectRef<
  NotDeprecatedMessage_InnerMessage2
>("NotDeprecatedMessageInnerMessage2");
builder.objectType(NotDeprecatedMessageInnerMessage2$Ref, {
  name: "NotDeprecatedMessageInnerMessage2",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof NotDeprecatedMessage_InnerMessage2;
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.deprecation.NotDeprecatedMessage.InnerMessage2",
      name: "InnerMessage2",
      package: "testapis.deprecation",
    },
  },
});

export type DeprecatedMessageInput$Shape = {
  body?: DeprecatedMessage["body"] | null;
  enum?: DeprecatedMessage["enum"] | null;
};

export const DeprecatedMessageInput$Ref: InputObjectRef<
  DeprecatedMessageInput$Shape
> = builder.inputRef<DeprecatedMessageInput$Shape>("DeprecatedMessageInput")
  .implement(
    {
      fields: (t) => ({
        body: t.field({
          type: "String",
          required: false,
          deprecationReason:
            "testapis.deprecation.DeprecatedMessage is mark as deprecated in a *.proto file.",
          extensions: {
            protobufField: { name: "body", typeFullName: "string" },
          },
        }),
        enum: t.field({
          type: NotDeprecatedEnum$Ref,
          required: false,
          deprecationReason:
            "testapis.deprecation.DeprecatedMessage is mark as deprecated in a *.proto file.",
          extensions: {
            protobufField: {
              name: "enum",
              typeFullName: "testapis.deprecation.NotDeprecatedEnum",
            },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.deprecation.DeprecatedMessage",
          name: "DeprecatedMessage",
          package: "testapis.deprecation",
          options: { deprecated: true },
        },
      },
    },
  );

export function DeprecatedMessageInput$toProto(
  input: DeprecatedMessageInput$Shape | null | undefined,
): DeprecatedMessage {
  return new DeprecatedMessage({
    body: input?.body ?? undefined,
    enum: input?.enum ?? undefined,
  });
}

export type NotDeprecatedMessageInput$Shape = {
  body?: NotDeprecatedMessage["body"] | null;
  enum?: NotDeprecatedMessage["enum"] | null;
  msg1?: NotDeprecatedMessageInnerMessage1Input$Shape | null;
  msg2?: NotDeprecatedMessageInnerMessage2Input$Shape | null;
  msg3?: NotDeprecatedMessageInnerMessage1Input$Shape | null;
  msg4?: NotDeprecatedMessageInnerMessage2Input$Shape | null;
};

export const NotDeprecatedMessageInput$Ref: InputObjectRef<
  NotDeprecatedMessageInput$Shape
> = builder.inputRef<NotDeprecatedMessageInput$Shape>(
  "NotDeprecatedMessageInput",
).implement(
  {
    fields: (t) => ({
      body: t.field({
        type: "String",
        required: false,
        deprecationReason:
          "testapis.deprecation.NotDeprecatedMessage.body is mark as deprecated in a *.proto file.",
        extensions: {
          protobufField: {
            name: "body",
            typeFullName: "string",
            options: { deprecated: true },
          },
        },
      }),
      enum: t.field({
        type: DeprecatedEnum$Ref,
        required: false,
        deprecationReason:
          "testapis.deprecation.DeprecatedEnum is mark as deprecated in a *.proto file.",
        extensions: {
          protobufField: {
            name: "enum",
            typeFullName: "testapis.deprecation.DeprecatedEnum",
          },
        },
      }),
      msg1: t.field({
        type: NotDeprecatedMessageInnerMessage1Input$Ref,
        required: false,
        deprecationReason:
          "testapis.deprecation.NotDeprecatedMessage.msg1 is mark as deprecated in a *.proto file.",
        extensions: {
          protobufField: {
            name: "msg1",
            typeFullName:
              "testapis.deprecation.NotDeprecatedMessage.InnerMessage1",
            options: { deprecated: true },
          },
        },
      }),
      msg2: t.field({
        type: NotDeprecatedMessageInnerMessage2Input$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "msg2",
            typeFullName:
              "testapis.deprecation.NotDeprecatedMessage.InnerMessage2",
          },
        },
      }),
      msg3: t.field({
        type: NotDeprecatedMessageInnerMessage1Input$Ref,
        required: false,
        deprecationReason:
          "testapis.deprecation.NotDeprecatedMessage.msg3 is mark as deprecated in a *.proto file.",
        extensions: {
          protobufField: {
            name: "msg3",
            typeFullName:
              "testapis.deprecation.NotDeprecatedMessage.InnerMessage1",
            options: { deprecated: true },
          },
        },
      }),
      msg4: t.field({
        type: NotDeprecatedMessageInnerMessage2Input$Ref,
        required: false,
        deprecationReason:
          "testapis.deprecation.NotDeprecatedMessage.msg4 is mark as deprecated in a *.proto file.",
        extensions: {
          protobufField: {
            name: "msg4",
            typeFullName:
              "testapis.deprecation.NotDeprecatedMessage.InnerMessage2",
            options: { deprecated: true },
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.deprecation.NotDeprecatedMessage",
        name: "NotDeprecatedMessage",
        package: "testapis.deprecation",
      },
    },
  },
);

export function NotDeprecatedMessageInput$toProto(
  input: NotDeprecatedMessageInput$Shape | null | undefined,
): NotDeprecatedMessage {
  return new NotDeprecatedMessage({
    body: input?.body ?? undefined,
    enum: input?.enum ?? undefined,
    notDeprecatedOneof: input?.msg1
      ? {
        case: "msg1",
        value: NotDeprecatedMessageInnerMessage1Input$toProto(input.msg1),
      }
      : input?.msg2
      ? {
        case: "msg2",
        value: NotDeprecatedMessageInnerMessage2Input$toProto(input.msg2),
      }
      : undefined,
    deprecatedOneof: input?.msg3
      ? {
        case: "msg3",
        value: NotDeprecatedMessageInnerMessage1Input$toProto(input.msg3),
      }
      : input?.msg4
      ? {
        case: "msg4",
        value: NotDeprecatedMessageInnerMessage2Input$toProto(input.msg4),
      }
      : undefined,
  });
}

export type DeprecatedMessageInnerMessageInput$Shape = {
  body?: DeprecatedMessage_InnerMessage["body"] | null;
};

export const DeprecatedMessageInnerMessageInput$Ref: InputObjectRef<
  DeprecatedMessageInnerMessageInput$Shape
> = builder.inputRef<DeprecatedMessageInnerMessageInput$Shape>(
  "DeprecatedMessageInnerMessageInput",
).implement(
  {
    fields: (t) => ({
      body: t.field({
        type: "String",
        required: false,
        deprecationReason:
          "testapis.deprecation.DeprecatedMessage is mark as deprecated in a *.proto file.",
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.deprecation.DeprecatedMessage.InnerMessage",
        name: "InnerMessage",
        package: "testapis.deprecation",
      },
    },
  },
);

export function DeprecatedMessageInnerMessageInput$toProto(
  input: DeprecatedMessageInnerMessageInput$Shape | null | undefined,
): DeprecatedMessage_InnerMessage {
  return new DeprecatedMessage_InnerMessage({
    body: input?.body ?? undefined,
  });
}

export type NotDeprecatedMessageInnerMessage1Input$Shape = {
  body: NotDeprecatedMessage_InnerMessage1["body"];
};

export const NotDeprecatedMessageInnerMessage1Input$Ref: InputObjectRef<
  NotDeprecatedMessageInnerMessage1Input$Shape
> = builder.inputRef<NotDeprecatedMessageInnerMessage1Input$Shape>(
  "NotDeprecatedMessageInnerMessage1Input",
).implement(
  {
    fields: (t) => ({
      body: t.field({
        type: "String",
        required: true,
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.deprecation.NotDeprecatedMessage.InnerMessage1",
        name: "InnerMessage1",
        package: "testapis.deprecation",
      },
    },
  },
);

export function NotDeprecatedMessageInnerMessage1Input$toProto(
  input: NotDeprecatedMessageInnerMessage1Input$Shape | null | undefined,
): NotDeprecatedMessage_InnerMessage1 {
  return new NotDeprecatedMessage_InnerMessage1({
    body: input?.body ?? undefined,
  });
}

export type NotDeprecatedMessageInnerMessage2Input$Shape = {
  body: NotDeprecatedMessage_InnerMessage2["body"];
};

export const NotDeprecatedMessageInnerMessage2Input$Ref: InputObjectRef<
  NotDeprecatedMessageInnerMessage2Input$Shape
> = builder.inputRef<NotDeprecatedMessageInnerMessage2Input$Shape>(
  "NotDeprecatedMessageInnerMessage2Input",
).implement(
  {
    fields: (t) => ({
      body: t.field({
        type: "String",
        required: true,
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.deprecation.NotDeprecatedMessage.InnerMessage2",
        name: "InnerMessage2",
        package: "testapis.deprecation",
      },
    },
  },
);

export function NotDeprecatedMessageInnerMessage2Input$toProto(
  input: NotDeprecatedMessageInnerMessage2Input$Shape | null | undefined,
): NotDeprecatedMessage_InnerMessage2 {
  return new NotDeprecatedMessage_InnerMessage2({
    body: input?.body ?? undefined,
  });
}

export const NotDeprecatedMessageNotDeprecatedOneof$Ref = builder.unionType(
  "NotDeprecatedMessageNotDeprecatedOneof",
  {
    types: [
      NotDeprecatedMessageInnerMessage1$Ref,
      NotDeprecatedMessageInnerMessage2$Ref,
    ],
    extensions: {
      protobufOneof: {
        fullName:
          "testapis.deprecation.NotDeprecatedMessage.not_deprecated_oneof",
        name: "not_deprecated_oneof",
        messageName: "NotDeprecatedMessage",
        package: "testapis.deprecation",
        fields: [{
          name: "msg1",
          type: "testapis.deprecation.NotDeprecatedMessage.InnerMessage1",
        }, {
          name: "msg2",
          type: "testapis.deprecation.NotDeprecatedMessage.InnerMessage2",
        }],
      },
    },
  },
);

export const NotDeprecatedMessageDeprecatedOneof$Ref = builder.unionType(
  "NotDeprecatedMessageDeprecatedOneof",
  {
    types: [
      NotDeprecatedMessageInnerMessage1$Ref,
      NotDeprecatedMessageInnerMessage2$Ref,
    ],
    extensions: {
      protobufOneof: {
        fullName: "testapis.deprecation.NotDeprecatedMessage.deprecated_oneof",
        name: "deprecated_oneof",
        messageName: "NotDeprecatedMessage",
        package: "testapis.deprecation",
        fields: [{
          name: "msg3",
          type: "testapis.deprecation.NotDeprecatedMessage.InnerMessage1",
        }, {
          name: "msg4",
          type: "testapis.deprecation.NotDeprecatedMessage.InnerMessage2",
        }],
      },
    },
  },
);

export const NotDeprecatedEnum$Ref: EnumRef<
  NotDeprecatedEnum,
  NotDeprecatedEnum
> = builder.enumType("NotDeprecatedEnum", {
  values: {
    NOT_DEPRECATED_FOO: {
      value: 1,
      extensions: { protobufEnumValue: { name: "NOT_DEPRECATED_FOO" } },
    },
    DEPRECATED_BAR: {
      deprecationReason:
        "testapis.deprecation.NotDeprecatedEnum.DEPRECATED_BAR is mark as deprecated in a *.proto file.",
      value: 2,
      extensions: {
        protobufEnumValue: {
          name: "DEPRECATED_BAR",
          options: { deprecated: true },
        },
      },
    },
  } as const,
  extensions: {
    protobufEnum: {
      name: "NotDeprecatedEnum",
      fullName: "testapis.deprecation.NotDeprecatedEnum",
      package: "testapis.deprecation",
    },
  },
});

export const DeprecatedEnum$Ref: EnumRef<DeprecatedEnum, DeprecatedEnum> =
  builder.enumType("DeprecatedEnum", {
    values: {
      DEPRECATED_BAZ: {
        deprecationReason:
          "testapis.deprecation.DeprecatedEnum is mark as deprecated in a *.proto file.",
        value: 1,
        extensions: { protobufEnumValue: { name: "DEPRECATED_BAZ" } },
      },
      DEPRECATED_QUX: {
        deprecationReason:
          "testapis.deprecation.DeprecatedEnum is mark as deprecated in a *.proto file.",
        value: 2,
        extensions: { protobufEnumValue: { name: "DEPRECATED_QUX" } },
      },
    } as const,
    extensions: {
      protobufEnum: {
        name: "DeprecatedEnum",
        fullName: "testapis.deprecation.DeprecatedEnum",
        package: "testapis.deprecation",
        options: { deprecated: true },
      },
    },
  });
",
    "name": "testapis/deprecation/deprecation.pb.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/deprecation/file_deprecation.proto

/* eslint-disable */

import { EnumRef, InputObjectRef } from "@pothos/core";
import { builder } from "../../builder";
import {
  DeprecatedFileEnum,
  DeprecatedFileMessage,
  DeprecatedFileMessage_InnerMessage,
} from "./testapis/deprecation/file_deprecation_pb";

export const DeprecatedFileMessage$Ref = builder.objectRef<
  DeprecatedFileMessage
>("DeprecatedFileMessage");
builder.objectType(DeprecatedFileMessage$Ref, {
  name: "DeprecatedFileMessage",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      deprecationReason:
        "testapis/deprecation/file_deprecation.proto is mark as deprecated.",
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
    enum: t.field({
      type: DeprecatedFileEnum$Ref,
      nullable: true,
      deprecationReason:
        "testapis/deprecation/file_deprecation.proto is mark as deprecated.",
      resolve: (source) => {
        if (
          source.enum === DeprecatedFileEnum.DEPRECATED_FILE_ENUM_UNSPECIFIED
        ) {
          return null;
        }

        return source.enum;
      },
      extensions: {
        protobufField: {
          name: "enum",
          typeFullName: "testapis.deprecation.DeprecatedFileEnum",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof DeprecatedFileMessage;
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.deprecation.DeprecatedFileMessage",
      name: "DeprecatedFileMessage",
      package: "testapis.deprecation",
    },
  },
});

export const DeprecatedFileMessageInnerMessage$Ref = builder.objectRef<
  DeprecatedFileMessage_InnerMessage
>("DeprecatedFileMessageInnerMessage");
builder.objectType(DeprecatedFileMessageInnerMessage$Ref, {
  name: "DeprecatedFileMessageInnerMessage",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      deprecationReason:
        "testapis/deprecation/file_deprecation.proto is mark as deprecated.",
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof DeprecatedFileMessage_InnerMessage;
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.deprecation.DeprecatedFileMessage.InnerMessage",
      name: "InnerMessage",
      package: "testapis.deprecation",
    },
  },
});

export type DeprecatedFileMessageInput$Shape = {
  body?: DeprecatedFileMessage["body"] | null;
  enum?: DeprecatedFileMessage["enum"] | null;
};

export const DeprecatedFileMessageInput$Ref: InputObjectRef<
  DeprecatedFileMessageInput$Shape
> = builder.inputRef<DeprecatedFileMessageInput$Shape>(
  "DeprecatedFileMessageInput",
).implement(
  {
    fields: (t) => ({
      body: t.field({
        type: "String",
        required: false,
        deprecationReason:
          "testapis/deprecation/file_deprecation.proto is mark as deprecated.",
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
      enum: t.field({
        type: DeprecatedFileEnum$Ref,
        required: false,
        deprecationReason:
          "testapis/deprecation/file_deprecation.proto is mark as deprecated.",
        extensions: {
          protobufField: {
            name: "enum",
            typeFullName: "testapis.deprecation.DeprecatedFileEnum",
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.deprecation.DeprecatedFileMessage",
        name: "DeprecatedFileMessage",
        package: "testapis.deprecation",
      },
    },
  },
);

export function DeprecatedFileMessageInput$toProto(
  input: DeprecatedFileMessageInput$Shape | null | undefined,
): DeprecatedFileMessage {
  return new DeprecatedFileMessage({
    body: input?.body ?? undefined,
    enum: input?.enum ?? undefined,
  });
}

export type DeprecatedFileMessageInnerMessageInput$Shape = {
  body?: DeprecatedFileMessage_InnerMessage["body"] | null;
};

export const DeprecatedFileMessageInnerMessageInput$Ref: InputObjectRef<
  DeprecatedFileMessageInnerMessageInput$Shape
> = builder.inputRef<DeprecatedFileMessageInnerMessageInput$Shape>(
  "DeprecatedFileMessageInnerMessageInput",
).implement(
  {
    fields: (t) => ({
      body: t.field({
        type: "String",
        required: false,
        deprecationReason:
          "testapis/deprecation/file_deprecation.proto is mark as deprecated.",
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.deprecation.DeprecatedFileMessage.InnerMessage",
        name: "InnerMessage",
        package: "testapis.deprecation",
      },
    },
  },
);

export function DeprecatedFileMessageInnerMessageInput$toProto(
  input: DeprecatedFileMessageInnerMessageInput$Shape | null | undefined,
): DeprecatedFileMessage_InnerMessage {
  return new DeprecatedFileMessage_InnerMessage({
    body: input?.body ?? undefined,
  });
}

export const DeprecatedFileEnum$Ref: EnumRef<
  DeprecatedFileEnum,
  DeprecatedFileEnum
> = builder.enumType("DeprecatedFileEnum", {
  values: {
    DEPRECATED_FILE_FOO: {
      deprecationReason:
        "testapis/deprecation/file_deprecation.proto is mark as deprecated.",
      value: 1,
      extensions: { protobufEnumValue: { name: "DEPRECATED_FILE_FOO" } },
    },
    DEPRECATED_FILE_BAR: {
      deprecationReason:
        "testapis/deprecation/file_deprecation.proto is mark as deprecated.",
      value: 2,
      extensions: { protobufEnumValue: { name: "DEPRECATED_FILE_BAR" } },
    },
  } as const,
  extensions: {
    protobufEnum: {
      name: "DeprecatedFileEnum",
      fullName: "testapis.deprecation.DeprecatedFileEnum",
      package: "testapis.deprecation",
    },
  },
});
",
    "name": "testapis/deprecation/file_deprecation.pb.pothos.ts",
  },
]
`;

exports[`protobuf-es > 'testapis.edgecases.import_from_same_pkg' > generates files by plugin 'with import prefix' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/edgecases/import_from_same_pkg/child.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { ChildMessage } from "@testapis/protobuf-es/testapis/edgecases/import_from_same_pkg/child_pb";
import { builder } from "../../../builder";

export const ChildMessage$Ref = builder.objectRef<ChildMessage>("ChildMessage");
builder.objectType(ChildMessage$Ref, {
  name: "ChildMessage",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof ChildMessage;
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.edgecases.import_from_same_pkg.ChildMessage",
      name: "ChildMessage",
      package: "testapis.edgecases.import_from_same_pkg",
    },
  },
});

export type ChildMessageInput$Shape = {
  body: ChildMessage["body"];
};

export const ChildMessageInput$Ref: InputObjectRef<ChildMessageInput$Shape> =
  builder.inputRef<ChildMessageInput$Shape>("ChildMessageInput").implement(
    {
      fields: (t) => ({
        body: t.field({
          type: "String",
          required: true,
          extensions: {
            protobufField: { name: "body", typeFullName: "string" },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.edgecases.import_from_same_pkg.ChildMessage",
          name: "ChildMessage",
          package: "testapis.edgecases.import_from_same_pkg",
        },
      },
    },
  );

export function ChildMessageInput$toProto(
  input: ChildMessageInput$Shape | null | undefined,
): ChildMessage {
  return new ChildMessage({
    body: input?.body ?? undefined,
  });
}
",
    "name": "testapis/edgecases/import_from_same_pkg/child.pb.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/edgecases/import_from_same_pkg/parent.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { ParentMessage } from "@testapis/protobuf-es/testapis/edgecases/import_from_same_pkg/parent_pb";
import { builder } from "../../../builder";
import {
  ChildMessage$Ref,
  ChildMessageInput$Ref,
  ChildMessageInput$Shape,
  ChildMessageInput$toProto,
} from "./child.pb.pothos";

export const ParentMessage$Ref = builder.objectRef<ParentMessage>(
  "ParentMessage",
);
builder.objectType(ParentMessage$Ref, {
  name: "ParentMessage",
  fields: (t) => ({
    child: t.expose("child", {
      type: ChildMessage$Ref,
      nullable: true,
      extensions: {
        protobufField: {
          name: "child",
          typeFullName: "testapis.edgecases.import_from_same_pkg.ChildMessage",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof ParentMessage;
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.edgecases.import_from_same_pkg.ParentMessage",
      name: "ParentMessage",
      package: "testapis.edgecases.import_from_same_pkg",
    },
  },
});

export type ParentMessageInput$Shape = {
  child?: ChildMessageInput$Shape | null;
};

export const ParentMessageInput$Ref: InputObjectRef<ParentMessageInput$Shape> =
  builder.inputRef<ParentMessageInput$Shape>("ParentMessageInput").implement(
    {
      fields: (t) => ({
        child: t.field({
          type: ChildMessageInput$Ref,
          required: false,
          extensions: {
            protobufField: {
              name: "child",
              typeFullName:
                "testapis.edgecases.import_from_same_pkg.ChildMessage",
            },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.edgecases.import_from_same_pkg.ParentMessage",
          name: "ParentMessage",
          package: "testapis.edgecases.import_from_same_pkg",
        },
      },
    },
  );

export function ParentMessageInput$toProto(
  input: ParentMessageInput$Shape | null | undefined,
): ParentMessage {
  return new ParentMessage({
    child: input?.child ? ChildMessageInput$toProto(input.child) : undefined,
  });
}
",
    "name": "testapis/edgecases/import_from_same_pkg/parent.pb.pothos.ts",
  },
]
`;

exports[`protobuf-es > 'testapis.edgecases.import_from_same_pkg' > generates files by plugin 'with partial inputs' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/edgecases/import_from_same_pkg/child.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { ChildMessage } from "@testapis/protobuf-es/testapis/edgecases/import_from_same_pkg/child_pb";
import { builder } from "../../../builder";

export const ChildMessage$Ref = builder.objectRef<ChildMessage>("ChildMessage");
builder.objectType(ChildMessage$Ref, {
  name: "ChildMessage",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof ChildMessage;
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.edgecases.import_from_same_pkg.ChildMessage",
      name: "ChildMessage",
      package: "testapis.edgecases.import_from_same_pkg",
    },
  },
});

export type ChildMessageInput$Shape = {
  body: ChildMessage["body"];
};

export const ChildMessageInput$Ref: InputObjectRef<ChildMessageInput$Shape> =
  builder.inputRef<ChildMessageInput$Shape>("ChildMessageInput").implement(
    {
      fields: (t) => ({
        body: t.field({
          type: "String",
          required: true,
          extensions: {
            protobufField: { name: "body", typeFullName: "string" },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.edgecases.import_from_same_pkg.ChildMessage",
          name: "ChildMessage",
          package: "testapis.edgecases.import_from_same_pkg",
        },
      },
    },
  );

export function ChildMessageInput$toProto(
  input: ChildMessageInput$Shape | null | undefined,
): ChildMessage {
  return new ChildMessage({
    body: input?.body ?? undefined,
  });
}

export type ChildMessagePartialInput$Shape = {
  body?: ChildMessage["body"] | null;
};

export const ChildMessagePartialInput$Ref: InputObjectRef<
  ChildMessagePartialInput$Shape
> = builder.inputRef<ChildMessagePartialInput$Shape>("ChildMessagePartialInput")
  .implement(
    {
      fields: (t) => ({
        body: t.field({
          type: "String",
          required: false,
          extensions: {
            protobufField: { name: "body", typeFullName: "string" },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.edgecases.import_from_same_pkg.ChildMessage",
          name: "ChildMessage",
          package: "testapis.edgecases.import_from_same_pkg",
        },
      },
    },
  );

export function ChildMessagePartialInput$toProto(
  input: ChildMessagePartialInput$Shape | null | undefined,
): ChildMessage {
  return new ChildMessage({
    body: input?.body ?? undefined,
  });
}
",
    "name": "testapis/edgecases/import_from_same_pkg/child.pb.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/edgecases/import_from_same_pkg/parent.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { ParentMessage } from "@testapis/protobuf-es/testapis/edgecases/import_from_same_pkg/parent_pb";
import { builder } from "../../../builder";
import {
  ChildMessage$Ref,
  ChildMessageInput$Ref,
  ChildMessageInput$Shape,
  ChildMessageInput$toProto,
  ChildMessagePartialInput$Ref,
  ChildMessagePartialInput$Shape,
  ChildMessagePartialInput$toProto,
} from "./child.pb.pothos";

export const ParentMessage$Ref = builder.objectRef<ParentMessage>(
  "ParentMessage",
);
builder.objectType(ParentMessage$Ref, {
  name: "ParentMessage",
  fields: (t) => ({
    child: t.expose("child", {
      type: ChildMessage$Ref,
      nullable: true,
      extensions: {
        protobufField: {
          name: "child",
          typeFullName: "testapis.edgecases.import_from_same_pkg.ChildMessage",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof ParentMessage;
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.edgecases.import_from_same_pkg.ParentMessage",
      name: "ParentMessage",
      package: "testapis.edgecases.import_from_same_pkg",
    },
  },
});

export type ParentMessageInput$Shape = {
  child?: ChildMessageInput$Shape | null;
};

export const ParentMessageInput$Ref: InputObjectRef<ParentMessageInput$Shape> =
  builder.inputRef<ParentMessageInput$Shape>("ParentMessageInput").implement(
    {
      fields: (t) => ({
        child: t.field({
          type: ChildMessageInput$Ref,
          required: false,
          extensions: {
            protobufField: {
              name: "child",
              typeFullName:
                "testapis.edgecases.import_from_same_pkg.ChildMessage",
            },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.edgecases.import_from_same_pkg.ParentMessage",
          name: "ParentMessage",
          package: "testapis.edgecases.import_from_same_pkg",
        },
      },
    },
  );

export function ParentMessageInput$toProto(
  input: ParentMessageInput$Shape | null | undefined,
): ParentMessage {
  return new ParentMessage({
    child: input?.child ? ChildMessageInput$toProto(input.child) : undefined,
  });
}

export type ParentMessagePartialInput$Shape = {
  child?: ChildMessagePartialInput$Shape | null;
};

export const ParentMessagePartialInput$Ref: InputObjectRef<
  ParentMessagePartialInput$Shape
> = builder.inputRef<ParentMessagePartialInput$Shape>(
  "ParentMessagePartialInput",
).implement(
  {
    fields: (t) => ({
      child: t.field({
        type: ChildMessagePartialInput$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "child",
            typeFullName:
              "testapis.edgecases.import_from_same_pkg.ChildMessage",
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.edgecases.import_from_same_pkg.ParentMessage",
        name: "ParentMessage",
        package: "testapis.edgecases.import_from_same_pkg",
      },
    },
  },
);

export function ParentMessagePartialInput$toProto(
  input: ParentMessagePartialInput$Shape | null | undefined,
): ParentMessage {
  return new ParentMessage({
    child: input?.child
      ? ChildMessagePartialInput$toProto(input.child)
      : undefined,
  });
}
",
    "name": "testapis/edgecases/import_from_same_pkg/parent.pb.pothos.ts",
  },
]
`;

exports[`protobuf-es > 'testapis.edgecases.import_from_same_pkg' > generates files by plugin 'without import prefix' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/edgecases/import_from_same_pkg/child.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { builder } from "../../../builder";
import { ChildMessage } from "./testapis/edgecases/import_from_same_pkg/child_pb";

export const ChildMessage$Ref = builder.objectRef<ChildMessage>("ChildMessage");
builder.objectType(ChildMessage$Ref, {
  name: "ChildMessage",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof ChildMessage;
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.edgecases.import_from_same_pkg.ChildMessage",
      name: "ChildMessage",
      package: "testapis.edgecases.import_from_same_pkg",
    },
  },
});

export type ChildMessageInput$Shape = {
  body: ChildMessage["body"];
};

export const ChildMessageInput$Ref: InputObjectRef<ChildMessageInput$Shape> =
  builder.inputRef<ChildMessageInput$Shape>("ChildMessageInput").implement(
    {
      fields: (t) => ({
        body: t.field({
          type: "String",
          required: true,
          extensions: {
            protobufField: { name: "body", typeFullName: "string" },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.edgecases.import_from_same_pkg.ChildMessage",
          name: "ChildMessage",
          package: "testapis.edgecases.import_from_same_pkg",
        },
      },
    },
  );

export function ChildMessageInput$toProto(
  input: ChildMessageInput$Shape | null | undefined,
): ChildMessage {
  return new ChildMessage({
    body: input?.body ?? undefined,
  });
}
",
    "name": "testapis/edgecases/import_from_same_pkg/child.pb.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/edgecases/import_from_same_pkg/parent.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { builder } from "../../../builder";
import {
  ChildMessage$Ref,
  ChildMessageInput$Ref,
  ChildMessageInput$Shape,
  ChildMessageInput$toProto,
} from "./child.pb.pothos";
import { ParentMessage } from "./testapis/edgecases/import_from_same_pkg/parent_pb";

export const ParentMessage$Ref = builder.objectRef<ParentMessage>(
  "ParentMessage",
);
builder.objectType(ParentMessage$Ref, {
  name: "ParentMessage",
  fields: (t) => ({
    child: t.expose("child", {
      type: ChildMessage$Ref,
      nullable: true,
      extensions: {
        protobufField: {
          name: "child",
          typeFullName: "testapis.edgecases.import_from_same_pkg.ChildMessage",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof ParentMessage;
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.edgecases.import_from_same_pkg.ParentMessage",
      name: "ParentMessage",
      package: "testapis.edgecases.import_from_same_pkg",
    },
  },
});

export type ParentMessageInput$Shape = {
  child?: ChildMessageInput$Shape | null;
};

export const ParentMessageInput$Ref: InputObjectRef<ParentMessageInput$Shape> =
  builder.inputRef<ParentMessageInput$Shape>("ParentMessageInput").implement(
    {
      fields: (t) => ({
        child: t.field({
          type: ChildMessageInput$Ref,
          required: false,
          extensions: {
            protobufField: {
              name: "child",
              typeFullName:
                "testapis.edgecases.import_from_same_pkg.ChildMessage",
            },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.edgecases.import_from_same_pkg.ParentMessage",
          name: "ParentMessage",
          package: "testapis.edgecases.import_from_same_pkg",
        },
      },
    },
  );

export function ParentMessageInput$toProto(
  input: ParentMessageInput$Shape | null | undefined,
): ParentMessage {
  return new ParentMessage({
    child: input?.child ? ChildMessageInput$toProto(input.child) : undefined,
  });
}
",
    "name": "testapis/edgecases/import_from_same_pkg/parent.pb.pothos.ts",
  },
]
`;

exports[`protobuf-es > 'testapis.edgecases.import_oneof_member_from_other_file' > generates files by plugin 'with import prefix' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/edgecases/import_oneof_member_from_other_file/member.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import {
  OneofMember1,
  OneofMember2,
} from "@testapis/protobuf-es/testapis/edgecases/import_oneof_member_from_other_file/member_pb";
import { builder } from "../../../builder";

export const OneofMember1$Ref = builder.objectRef<OneofMember1>("OneofMember1");
builder.objectType(OneofMember1$Ref, {
  name: "OneofMember1",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof OneofMember1;
  },
  extensions: {
    protobufMessage: {
      fullName:
        "testapis.edgecases.import_oneof_member_from_other_file.OneofMember1",
      name: "OneofMember1",
      package: "testapis.edgecases.import_oneof_member_from_other_file",
    },
  },
});

export const OneofMember2$Ref = builder.objectRef<OneofMember2>("OneofMember2");
builder.objectType(OneofMember2$Ref, {
  name: "OneofMember2",
  fields: (t) => ({
    count: t.expose("count", {
      type: "Int",
      nullable: false,
      extensions: { protobufField: { name: "count", typeFullName: "int32" } },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof OneofMember2;
  },
  extensions: {
    protobufMessage: {
      fullName:
        "testapis.edgecases.import_oneof_member_from_other_file.OneofMember2",
      name: "OneofMember2",
      package: "testapis.edgecases.import_oneof_member_from_other_file",
    },
  },
});

export type OneofMember1Input$Shape = {
  body: OneofMember1["body"];
};

export const OneofMember1Input$Ref: InputObjectRef<OneofMember1Input$Shape> =
  builder.inputRef<OneofMember1Input$Shape>("OneofMember1Input").implement(
    {
      fields: (t) => ({
        body: t.field({
          type: "String",
          required: true,
          extensions: {
            protobufField: { name: "body", typeFullName: "string" },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName:
            "testapis.edgecases.import_oneof_member_from_other_file.OneofMember1",
          name: "OneofMember1",
          package: "testapis.edgecases.import_oneof_member_from_other_file",
        },
      },
    },
  );

export function OneofMember1Input$toProto(
  input: OneofMember1Input$Shape | null | undefined,
): OneofMember1 {
  return new OneofMember1({
    body: input?.body ?? undefined,
  });
}

export type OneofMember2Input$Shape = {
  count: OneofMember2["count"];
};

export const OneofMember2Input$Ref: InputObjectRef<OneofMember2Input$Shape> =
  builder.inputRef<OneofMember2Input$Shape>("OneofMember2Input").implement(
    {
      fields: (t) => ({
        count: t.field({
          type: "Int",
          required: true,
          extensions: {
            protobufField: { name: "count", typeFullName: "int32" },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName:
            "testapis.edgecases.import_oneof_member_from_other_file.OneofMember2",
          name: "OneofMember2",
          package: "testapis.edgecases.import_oneof_member_from_other_file",
        },
      },
    },
  );

export function OneofMember2Input$toProto(
  input: OneofMember2Input$Shape | null | undefined,
): OneofMember2 {
  return new OneofMember2({
    count: input?.count ?? undefined,
  });
}
",
    "name": "testapis/edgecases/import_oneof_member_from_other_file/member.pb.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/edgecases/import_oneof_member_from_other_file/parent.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { OneofParent } from "@testapis/protobuf-es/testapis/edgecases/import_oneof_member_from_other_file/parent_pb";
import { builder } from "../../../builder";
import {
  OneofMember1$Ref,
  OneofMember1Input$Ref,
  OneofMember1Input$Shape,
  OneofMember1Input$toProto,
  OneofMember2$Ref,
  OneofMember2Input$Ref,
  OneofMember2Input$Shape,
  OneofMember2Input$toProto,
} from "./member.pb.pothos";

export const OneofParent$Ref = builder.objectRef<OneofParent>("OneofParent");
builder.objectType(OneofParent$Ref, {
  name: "OneofParent",
  fields: (t) => ({
    oneofField: t.field({
      type: OneofParentOneofField$Ref,
      nullable: true,
      resolve: (source) => {
        return source.oneofField.value;
      },
      extensions: { protobufField: { name: "oneof_field" } },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof OneofParent;
  },
  extensions: {
    protobufMessage: {
      fullName:
        "testapis.edgecases.import_oneof_member_from_other_file.OneofParent",
      name: "OneofParent",
      package: "testapis.edgecases.import_oneof_member_from_other_file",
    },
  },
});

export type OneofParentInput$Shape = {
  member1?: OneofMember1Input$Shape | null;
  member2?: OneofMember2Input$Shape | null;
};

export const OneofParentInput$Ref: InputObjectRef<OneofParentInput$Shape> =
  builder.inputRef<OneofParentInput$Shape>("OneofParentInput").implement(
    {
      fields: (t) => ({
        member1: t.field({
          type: OneofMember1Input$Ref,
          required: false,
          extensions: {
            protobufField: {
              name: "member1",
              typeFullName:
                "testapis.edgecases.import_oneof_member_from_other_file.OneofMember1",
            },
          },
        }),
        member2: t.field({
          type: OneofMember2Input$Ref,
          required: false,
          extensions: {
            protobufField: {
              name: "member2",
              typeFullName:
                "testapis.edgecases.import_oneof_member_from_other_file.OneofMember2",
            },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName:
            "testapis.edgecases.import_oneof_member_from_other_file.OneofParent",
          name: "OneofParent",
          package: "testapis.edgecases.import_oneof_member_from_other_file",
        },
      },
    },
  );

export function OneofParentInput$toProto(
  input: OneofParentInput$Shape | null | undefined,
): OneofParent {
  return new OneofParent({
    oneofField: input?.member1
      ? { case: "member1", value: OneofMember1Input$toProto(input.member1) }
      : input?.member2
      ? { case: "member2", value: OneofMember2Input$toProto(input.member2) }
      : undefined,
  });
}

export const OneofParentOneofField$Ref = builder.unionType(
  "OneofParentOneofField",
  {
    types: [OneofMember1$Ref, OneofMember2$Ref],
    extensions: {
      protobufOneof: {
        fullName:
          "testapis.edgecases.import_oneof_member_from_other_file.OneofParent.oneof_field",
        name: "oneof_field",
        messageName: "OneofParent",
        package: "testapis.edgecases.import_oneof_member_from_other_file",
        fields: [{
          name: "member1",
          type:
            "testapis.edgecases.import_oneof_member_from_other_file.OneofMember1",
        }, {
          name: "member2",
          type:
            "testapis.edgecases.import_oneof_member_from_other_file.OneofMember2",
        }],
      },
    },
  },
);
",
    "name": "testapis/edgecases/import_oneof_member_from_other_file/parent.pb.pothos.ts",
  },
]
`;

exports[`protobuf-es > 'testapis.edgecases.import_oneof_member_from_other_file' > generates files by plugin 'with partial inputs' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/edgecases/import_oneof_member_from_other_file/member.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import {
  OneofMember1,
  OneofMember2,
} from "@testapis/protobuf-es/testapis/edgecases/import_oneof_member_from_other_file/member_pb";
import { builder } from "../../../builder";

export const OneofMember1$Ref = builder.objectRef<OneofMember1>("OneofMember1");
builder.objectType(OneofMember1$Ref, {
  name: "OneofMember1",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof OneofMember1;
  },
  extensions: {
    protobufMessage: {
      fullName:
        "testapis.edgecases.import_oneof_member_from_other_file.OneofMember1",
      name: "OneofMember1",
      package: "testapis.edgecases.import_oneof_member_from_other_file",
    },
  },
});

export const OneofMember2$Ref = builder.objectRef<OneofMember2>("OneofMember2");
builder.objectType(OneofMember2$Ref, {
  name: "OneofMember2",
  fields: (t) => ({
    count: t.expose("count", {
      type: "Int",
      nullable: false,
      extensions: { protobufField: { name: "count", typeFullName: "int32" } },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof OneofMember2;
  },
  extensions: {
    protobufMessage: {
      fullName:
        "testapis.edgecases.import_oneof_member_from_other_file.OneofMember2",
      name: "OneofMember2",
      package: "testapis.edgecases.import_oneof_member_from_other_file",
    },
  },
});

export type OneofMember1Input$Shape = {
  body: OneofMember1["body"];
};

export const OneofMember1Input$Ref: InputObjectRef<OneofMember1Input$Shape> =
  builder.inputRef<OneofMember1Input$Shape>("OneofMember1Input").implement(
    {
      fields: (t) => ({
        body: t.field({
          type: "String",
          required: true,
          extensions: {
            protobufField: { name: "body", typeFullName: "string" },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName:
            "testapis.edgecases.import_oneof_member_from_other_file.OneofMember1",
          name: "OneofMember1",
          package: "testapis.edgecases.import_oneof_member_from_other_file",
        },
      },
    },
  );

export function OneofMember1Input$toProto(
  input: OneofMember1Input$Shape | null | undefined,
): OneofMember1 {
  return new OneofMember1({
    body: input?.body ?? undefined,
  });
}

export type OneofMember1PartialInput$Shape = {
  body?: OneofMember1["body"] | null;
};

export const OneofMember1PartialInput$Ref: InputObjectRef<
  OneofMember1PartialInput$Shape
> = builder.inputRef<OneofMember1PartialInput$Shape>("OneofMember1PartialInput")
  .implement(
    {
      fields: (t) => ({
        body: t.field({
          type: "String",
          required: false,
          extensions: {
            protobufField: { name: "body", typeFullName: "string" },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName:
            "testapis.edgecases.import_oneof_member_from_other_file.OneofMember1",
          name: "OneofMember1",
          package: "testapis.edgecases.import_oneof_member_from_other_file",
        },
      },
    },
  );

export function OneofMember1PartialInput$toProto(
  input: OneofMember1PartialInput$Shape | null | undefined,
): OneofMember1 {
  return new OneofMember1({
    body: input?.body ?? undefined,
  });
}

export type OneofMember2Input$Shape = {
  count: OneofMember2["count"];
};

export const OneofMember2Input$Ref: InputObjectRef<OneofMember2Input$Shape> =
  builder.inputRef<OneofMember2Input$Shape>("OneofMember2Input").implement(
    {
      fields: (t) => ({
        count: t.field({
          type: "Int",
          required: true,
          extensions: {
            protobufField: { name: "count", typeFullName: "int32" },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName:
            "testapis.edgecases.import_oneof_member_from_other_file.OneofMember2",
          name: "OneofMember2",
          package: "testapis.edgecases.import_oneof_member_from_other_file",
        },
      },
    },
  );

export function OneofMember2Input$toProto(
  input: OneofMember2Input$Shape | null | undefined,
): OneofMember2 {
  return new OneofMember2({
    count: input?.count ?? undefined,
  });
}

export type OneofMember2PartialInput$Shape = {
  count?: OneofMember2["count"] | null;
};

export const OneofMember2PartialInput$Ref: InputObjectRef<
  OneofMember2PartialInput$Shape
> = builder.inputRef<OneofMember2PartialInput$Shape>("OneofMember2PartialInput")
  .implement(
    {
      fields: (t) => ({
        count: t.field({
          type: "Int",
          required: false,
          extensions: {
            protobufField: { name: "count", typeFullName: "int32" },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName:
            "testapis.edgecases.import_oneof_member_from_other_file.OneofMember2",
          name: "OneofMember2",
          package: "testapis.edgecases.import_oneof_member_from_other_file",
        },
      },
    },
  );

export function OneofMember2PartialInput$toProto(
  input: OneofMember2PartialInput$Shape | null | undefined,
): OneofMember2 {
  return new OneofMember2({
    count: input?.count ?? undefined,
  });
}
",
    "name": "testapis/edgecases/import_oneof_member_from_other_file/member.pb.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/edgecases/import_oneof_member_from_other_file/parent.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { OneofParent } from "@testapis/protobuf-es/testapis/edgecases/import_oneof_member_from_other_file/parent_pb";
import { builder } from "../../../builder";
import {
  OneofMember1$Ref,
  OneofMember1Input$Ref,
  OneofMember1Input$Shape,
  OneofMember1Input$toProto,
  OneofMember1PartialInput$Ref,
  OneofMember1PartialInput$Shape,
  OneofMember1PartialInput$toProto,
  OneofMember2$Ref,
  OneofMember2Input$Ref,
  OneofMember2Input$Shape,
  OneofMember2Input$toProto,
  OneofMember2PartialInput$Ref,
  OneofMember2PartialInput$Shape,
  OneofMember2PartialInput$toProto,
} from "./member.pb.pothos";

export const OneofParent$Ref = builder.objectRef<OneofParent>("OneofParent");
builder.objectType(OneofParent$Ref, {
  name: "OneofParent",
  fields: (t) => ({
    oneofField: t.field({
      type: OneofParentOneofField$Ref,
      nullable: true,
      resolve: (source) => {
        return source.oneofField.value;
      },
      extensions: { protobufField: { name: "oneof_field" } },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof OneofParent;
  },
  extensions: {
    protobufMessage: {
      fullName:
        "testapis.edgecases.import_oneof_member_from_other_file.OneofParent",
      name: "OneofParent",
      package: "testapis.edgecases.import_oneof_member_from_other_file",
    },
  },
});

export type OneofParentInput$Shape = {
  member1?: OneofMember1Input$Shape | null;
  member2?: OneofMember2Input$Shape | null;
};

export const OneofParentInput$Ref: InputObjectRef<OneofParentInput$Shape> =
  builder.inputRef<OneofParentInput$Shape>("OneofParentInput").implement(
    {
      fields: (t) => ({
        member1: t.field({
          type: OneofMember1Input$Ref,
          required: false,
          extensions: {
            protobufField: {
              name: "member1",
              typeFullName:
                "testapis.edgecases.import_oneof_member_from_other_file.OneofMember1",
            },
          },
        }),
        member2: t.field({
          type: OneofMember2Input$Ref,
          required: false,
          extensions: {
            protobufField: {
              name: "member2",
              typeFullName:
                "testapis.edgecases.import_oneof_member_from_other_file.OneofMember2",
            },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName:
            "testapis.edgecases.import_oneof_member_from_other_file.OneofParent",
          name: "OneofParent",
          package: "testapis.edgecases.import_oneof_member_from_other_file",
        },
      },
    },
  );

export function OneofParentInput$toProto(
  input: OneofParentInput$Shape | null | undefined,
): OneofParent {
  return new OneofParent({
    oneofField: input?.member1
      ? { case: "member1", value: OneofMember1Input$toProto(input.member1) }
      : input?.member2
      ? { case: "member2", value: OneofMember2Input$toProto(input.member2) }
      : undefined,
  });
}

export type OneofParentPartialInput$Shape = {
  member1?: OneofMember1PartialInput$Shape | null;
  member2?: OneofMember2PartialInput$Shape | null;
};

export const OneofParentPartialInput$Ref: InputObjectRef<
  OneofParentPartialInput$Shape
> = builder.inputRef<OneofParentPartialInput$Shape>("OneofParentPartialInput")
  .implement(
    {
      fields: (t) => ({
        member1: t.field({
          type: OneofMember1PartialInput$Ref,
          required: false,
          extensions: {
            protobufField: {
              name: "member1",
              typeFullName:
                "testapis.edgecases.import_oneof_member_from_other_file.OneofMember1",
            },
          },
        }),
        member2: t.field({
          type: OneofMember2PartialInput$Ref,
          required: false,
          extensions: {
            protobufField: {
              name: "member2",
              typeFullName:
                "testapis.edgecases.import_oneof_member_from_other_file.OneofMember2",
            },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName:
            "testapis.edgecases.import_oneof_member_from_other_file.OneofParent",
          name: "OneofParent",
          package: "testapis.edgecases.import_oneof_member_from_other_file",
        },
      },
    },
  );

export function OneofParentPartialInput$toProto(
  input: OneofParentPartialInput$Shape | null | undefined,
): OneofParent {
  return new OneofParent({
    oneofField: input?.member1
      ? {
        case: "member1",
        value: OneofMember1PartialInput$toProto(input.member1),
      }
      : input?.member2
      ? {
        case: "member2",
        value: OneofMember2PartialInput$toProto(input.member2),
      }
      : undefined,
  });
}

export const OneofParentOneofField$Ref = builder.unionType(
  "OneofParentOneofField",
  {
    types: [OneofMember1$Ref, OneofMember2$Ref],
    extensions: {
      protobufOneof: {
        fullName:
          "testapis.edgecases.import_oneof_member_from_other_file.OneofParent.oneof_field",
        name: "oneof_field",
        messageName: "OneofParent",
        package: "testapis.edgecases.import_oneof_member_from_other_file",
        fields: [{
          name: "member1",
          type:
            "testapis.edgecases.import_oneof_member_from_other_file.OneofMember1",
        }, {
          name: "member2",
          type:
            "testapis.edgecases.import_oneof_member_from_other_file.OneofMember2",
        }],
      },
    },
  },
);
",
    "name": "testapis/edgecases/import_oneof_member_from_other_file/parent.pb.pothos.ts",
  },
]
`;

exports[`protobuf-es > 'testapis.edgecases.import_oneof_member_from_other_file' > generates files by plugin 'without import prefix' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/edgecases/import_oneof_member_from_other_file/member.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { builder } from "../../../builder";
import {
  OneofMember1,
  OneofMember2,
} from "./testapis/edgecases/import_oneof_member_from_other_file/member_pb";

export const OneofMember1$Ref = builder.objectRef<OneofMember1>("OneofMember1");
builder.objectType(OneofMember1$Ref, {
  name: "OneofMember1",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof OneofMember1;
  },
  extensions: {
    protobufMessage: {
      fullName:
        "testapis.edgecases.import_oneof_member_from_other_file.OneofMember1",
      name: "OneofMember1",
      package: "testapis.edgecases.import_oneof_member_from_other_file",
    },
  },
});

export const OneofMember2$Ref = builder.objectRef<OneofMember2>("OneofMember2");
builder.objectType(OneofMember2$Ref, {
  name: "OneofMember2",
  fields: (t) => ({
    count: t.expose("count", {
      type: "Int",
      nullable: false,
      extensions: { protobufField: { name: "count", typeFullName: "int32" } },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof OneofMember2;
  },
  extensions: {
    protobufMessage: {
      fullName:
        "testapis.edgecases.import_oneof_member_from_other_file.OneofMember2",
      name: "OneofMember2",
      package: "testapis.edgecases.import_oneof_member_from_other_file",
    },
  },
});

export type OneofMember1Input$Shape = {
  body: OneofMember1["body"];
};

export const OneofMember1Input$Ref: InputObjectRef<OneofMember1Input$Shape> =
  builder.inputRef<OneofMember1Input$Shape>("OneofMember1Input").implement(
    {
      fields: (t) => ({
        body: t.field({
          type: "String",
          required: true,
          extensions: {
            protobufField: { name: "body", typeFullName: "string" },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName:
            "testapis.edgecases.import_oneof_member_from_other_file.OneofMember1",
          name: "OneofMember1",
          package: "testapis.edgecases.import_oneof_member_from_other_file",
        },
      },
    },
  );

export function OneofMember1Input$toProto(
  input: OneofMember1Input$Shape | null | undefined,
): OneofMember1 {
  return new OneofMember1({
    body: input?.body ?? undefined,
  });
}

export type OneofMember2Input$Shape = {
  count: OneofMember2["count"];
};

export const OneofMember2Input$Ref: InputObjectRef<OneofMember2Input$Shape> =
  builder.inputRef<OneofMember2Input$Shape>("OneofMember2Input").implement(
    {
      fields: (t) => ({
        count: t.field({
          type: "Int",
          required: true,
          extensions: {
            protobufField: { name: "count", typeFullName: "int32" },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName:
            "testapis.edgecases.import_oneof_member_from_other_file.OneofMember2",
          name: "OneofMember2",
          package: "testapis.edgecases.import_oneof_member_from_other_file",
        },
      },
    },
  );

export function OneofMember2Input$toProto(
  input: OneofMember2Input$Shape | null | undefined,
): OneofMember2 {
  return new OneofMember2({
    count: input?.count ?? undefined,
  });
}
",
    "name": "testapis/edgecases/import_oneof_member_from_other_file/member.pb.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/edgecases/import_oneof_member_from_other_file/parent.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { builder } from "../../../builder";
import {
  OneofMember1$Ref,
  OneofMember1Input$Ref,
  OneofMember1Input$Shape,
  OneofMember1Input$toProto,
  OneofMember2$Ref,
  OneofMember2Input$Ref,
  OneofMember2Input$Shape,
  OneofMember2Input$toProto,
} from "./member.pb.pothos";
import { OneofParent } from "./testapis/edgecases/import_oneof_member_from_other_file/parent_pb";

export const OneofParent$Ref = builder.objectRef<OneofParent>("OneofParent");
builder.objectType(OneofParent$Ref, {
  name: "OneofParent",
  fields: (t) => ({
    oneofField: t.field({
      type: OneofParentOneofField$Ref,
      nullable: true,
      resolve: (source) => {
        return source.oneofField.value;
      },
      extensions: { protobufField: { name: "oneof_field" } },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof OneofParent;
  },
  extensions: {
    protobufMessage: {
      fullName:
        "testapis.edgecases.import_oneof_member_from_other_file.OneofParent",
      name: "OneofParent",
      package: "testapis.edgecases.import_oneof_member_from_other_file",
    },
  },
});

export type OneofParentInput$Shape = {
  member1?: OneofMember1Input$Shape | null;
  member2?: OneofMember2Input$Shape | null;
};

export const OneofParentInput$Ref: InputObjectRef<OneofParentInput$Shape> =
  builder.inputRef<OneofParentInput$Shape>("OneofParentInput").implement(
    {
      fields: (t) => ({
        member1: t.field({
          type: OneofMember1Input$Ref,
          required: false,
          extensions: {
            protobufField: {
              name: "member1",
              typeFullName:
                "testapis.edgecases.import_oneof_member_from_other_file.OneofMember1",
            },
          },
        }),
        member2: t.field({
          type: OneofMember2Input$Ref,
          required: false,
          extensions: {
            protobufField: {
              name: "member2",
              typeFullName:
                "testapis.edgecases.import_oneof_member_from_other_file.OneofMember2",
            },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName:
            "testapis.edgecases.import_oneof_member_from_other_file.OneofParent",
          name: "OneofParent",
          package: "testapis.edgecases.import_oneof_member_from_other_file",
        },
      },
    },
  );

export function OneofParentInput$toProto(
  input: OneofParentInput$Shape | null | undefined,
): OneofParent {
  return new OneofParent({
    oneofField: input?.member1
      ? { case: "member1", value: OneofMember1Input$toProto(input.member1) }
      : input?.member2
      ? { case: "member2", value: OneofMember2Input$toProto(input.member2) }
      : undefined,
  });
}

export const OneofParentOneofField$Ref = builder.unionType(
  "OneofParentOneofField",
  {
    types: [OneofMember1$Ref, OneofMember2$Ref],
    extensions: {
      protobufOneof: {
        fullName:
          "testapis.edgecases.import_oneof_member_from_other_file.OneofParent.oneof_field",
        name: "oneof_field",
        messageName: "OneofParent",
        package: "testapis.edgecases.import_oneof_member_from_other_file",
        fields: [{
          name: "member1",
          type:
            "testapis.edgecases.import_oneof_member_from_other_file.OneofMember1",
        }, {
          name: "member2",
          type:
            "testapis.edgecases.import_oneof_member_from_other_file.OneofMember2",
        }],
      },
    },
  },
);
",
    "name": "testapis/edgecases/import_oneof_member_from_other_file/parent.pb.pothos.ts",
  },
]
`;

exports[`protobuf-es > 'testapis.edgecases.import_squashed_union' > generates files by plugin 'with import prefix' 1`] = `[]`;

exports[`protobuf-es > 'testapis.edgecases.import_squashed_union' > generates files by plugin 'with partial inputs' 1`] = `[]`;

exports[`protobuf-es > 'testapis.edgecases.import_squashed_union' > generates files by plugin 'without import prefix' 1`] = `[]`;

exports[`protobuf-es > 'testapis.edgecases.import_squashed_union.pkg1' > generates files by plugin 'with import prefix' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/edgecases/import_squashed_union/pkg1/types.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import {
  OneofMessage1,
  SquashedOneof,
} from "@testapis/protobuf-es/testapis/edgecases/import_squashed_union/pkg1/types_pb";
import { builder } from "../../../../builder";

export const OneofMessage1$Ref = builder.objectRef<OneofMessage1>(
  "OneofMessage1",
);
builder.objectType(OneofMessage1$Ref, {
  name: "OneofMessage1",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof OneofMessage1;
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.edgecases.import_squashed_union.pkg1.OneofMessage1",
      name: "OneofMessage1",
      package: "testapis.edgecases.import_squashed_union.pkg1",
    },
  },
});

export type OneofMessage1Input$Shape = {
  body: OneofMessage1["body"];
};

export const OneofMessage1Input$Ref: InputObjectRef<OneofMessage1Input$Shape> =
  builder.inputRef<OneofMessage1Input$Shape>("OneofMessage1Input").implement(
    {
      fields: (t) => ({
        body: t.field({
          type: "String",
          required: true,
          extensions: {
            protobufField: { name: "body", typeFullName: "string" },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName:
            "testapis.edgecases.import_squashed_union.pkg1.OneofMessage1",
          name: "OneofMessage1",
          package: "testapis.edgecases.import_squashed_union.pkg1",
        },
      },
    },
  );

export function OneofMessage1Input$toProto(
  input: OneofMessage1Input$Shape | null | undefined,
): OneofMessage1 {
  return new OneofMessage1({
    body: input?.body ?? undefined,
  });
}

export type SquashedOneofInput$Shape = {
  msg1?: OneofMessage1Input$Shape | null;
};

export const SquashedOneofInput$Ref: InputObjectRef<SquashedOneofInput$Shape> =
  builder.inputRef<SquashedOneofInput$Shape>("SquashedOneofInput").implement(
    {
      fields: (t) => ({
        msg1: t.field({
          type: OneofMessage1Input$Ref,
          required: false,
          extensions: {
            protobufField: {
              name: "msg1",
              typeFullName:
                "testapis.edgecases.import_squashed_union.pkg1.OneofMessage1",
            },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName:
            "testapis.edgecases.import_squashed_union.pkg1.SquashedOneof",
          name: "SquashedOneof",
          package: "testapis.edgecases.import_squashed_union.pkg1",
          options: { "[graphql.object_type]": { squashUnion: true } },
        },
      },
    },
  );

export function SquashedOneofInput$toProto(
  input: SquashedOneofInput$Shape | null | undefined,
): SquashedOneof {
  return new SquashedOneof({
    message: input?.msg1
      ? { case: "msg1", value: OneofMessage1Input$toProto(input.msg1) }
      : undefined,
  });
}

export const SquashedOneof$Ref = builder.unionType("SquashedOneof", {
  types: [OneofMessage1$Ref],
  extensions: {
    protobufOneof: {
      fullName: "testapis.edgecases.import_squashed_union.pkg1.SquashedOneof",
      name: "SquashedOneof",
      package: "testapis.edgecases.import_squashed_union.pkg1",
      fields: [{
        name: "msg1",
        type: "testapis.edgecases.import_squashed_union.pkg1.OneofMessage1",
        options: { "[graphql.object_type]": { squashUnion: true } },
      }],
    },
  },
});
",
    "name": "testapis/edgecases/import_squashed_union/pkg1/types.pb.pothos.ts",
  },
]
`;

exports[`protobuf-es > 'testapis.edgecases.import_squashed_union.pkg1' > generates files by plugin 'with partial inputs' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/edgecases/import_squashed_union/pkg1/types.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import {
  OneofMessage1,
  SquashedOneof,
} from "@testapis/protobuf-es/testapis/edgecases/import_squashed_union/pkg1/types_pb";
import { builder } from "../../../../builder";

export const OneofMessage1$Ref = builder.objectRef<OneofMessage1>(
  "OneofMessage1",
);
builder.objectType(OneofMessage1$Ref, {
  name: "OneofMessage1",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof OneofMessage1;
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.edgecases.import_squashed_union.pkg1.OneofMessage1",
      name: "OneofMessage1",
      package: "testapis.edgecases.import_squashed_union.pkg1",
    },
  },
});

export type OneofMessage1Input$Shape = {
  body: OneofMessage1["body"];
};

export const OneofMessage1Input$Ref: InputObjectRef<OneofMessage1Input$Shape> =
  builder.inputRef<OneofMessage1Input$Shape>("OneofMessage1Input").implement(
    {
      fields: (t) => ({
        body: t.field({
          type: "String",
          required: true,
          extensions: {
            protobufField: { name: "body", typeFullName: "string" },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName:
            "testapis.edgecases.import_squashed_union.pkg1.OneofMessage1",
          name: "OneofMessage1",
          package: "testapis.edgecases.import_squashed_union.pkg1",
        },
      },
    },
  );

export function OneofMessage1Input$toProto(
  input: OneofMessage1Input$Shape | null | undefined,
): OneofMessage1 {
  return new OneofMessage1({
    body: input?.body ?? undefined,
  });
}

export type OneofMessage1PartialInput$Shape = {
  body?: OneofMessage1["body"] | null;
};

export const OneofMessage1PartialInput$Ref: InputObjectRef<
  OneofMessage1PartialInput$Shape
> = builder.inputRef<OneofMessage1PartialInput$Shape>(
  "OneofMessage1PartialInput",
).implement(
  {
    fields: (t) => ({
      body: t.field({
        type: "String",
        required: false,
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.edgecases.import_squashed_union.pkg1.OneofMessage1",
        name: "OneofMessage1",
        package: "testapis.edgecases.import_squashed_union.pkg1",
      },
    },
  },
);

export function OneofMessage1PartialInput$toProto(
  input: OneofMessage1PartialInput$Shape | null | undefined,
): OneofMessage1 {
  return new OneofMessage1({
    body: input?.body ?? undefined,
  });
}

export type SquashedOneofInput$Shape = {
  msg1?: OneofMessage1Input$Shape | null;
};

export const SquashedOneofInput$Ref: InputObjectRef<SquashedOneofInput$Shape> =
  builder.inputRef<SquashedOneofInput$Shape>("SquashedOneofInput").implement(
    {
      fields: (t) => ({
        msg1: t.field({
          type: OneofMessage1Input$Ref,
          required: false,
          extensions: {
            protobufField: {
              name: "msg1",
              typeFullName:
                "testapis.edgecases.import_squashed_union.pkg1.OneofMessage1",
            },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName:
            "testapis.edgecases.import_squashed_union.pkg1.SquashedOneof",
          name: "SquashedOneof",
          package: "testapis.edgecases.import_squashed_union.pkg1",
          options: { "[graphql.object_type]": { squashUnion: true } },
        },
      },
    },
  );

export function SquashedOneofInput$toProto(
  input: SquashedOneofInput$Shape | null | undefined,
): SquashedOneof {
  return new SquashedOneof({
    message: input?.msg1
      ? { case: "msg1", value: OneofMessage1Input$toProto(input.msg1) }
      : undefined,
  });
}

export type SquashedOneofPartialInput$Shape = {
  msg1?: OneofMessage1PartialInput$Shape | null;
};

export const SquashedOneofPartialInput$Ref: InputObjectRef<
  SquashedOneofPartialInput$Shape
> = builder.inputRef<SquashedOneofPartialInput$Shape>(
  "SquashedOneofPartialInput",
).implement(
  {
    fields: (t) => ({
      msg1: t.field({
        type: OneofMessage1PartialInput$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "msg1",
            typeFullName:
              "testapis.edgecases.import_squashed_union.pkg1.OneofMessage1",
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.edgecases.import_squashed_union.pkg1.SquashedOneof",
        name: "SquashedOneof",
        package: "testapis.edgecases.import_squashed_union.pkg1",
        options: { "[graphql.object_type]": { squashUnion: true } },
      },
    },
  },
);

export function SquashedOneofPartialInput$toProto(
  input: SquashedOneofPartialInput$Shape | null | undefined,
): SquashedOneof {
  return new SquashedOneof({
    message: input?.msg1
      ? { case: "msg1", value: OneofMessage1PartialInput$toProto(input.msg1) }
      : undefined,
  });
}

export const SquashedOneof$Ref = builder.unionType("SquashedOneof", {
  types: [OneofMessage1$Ref],
  extensions: {
    protobufOneof: {
      fullName: "testapis.edgecases.import_squashed_union.pkg1.SquashedOneof",
      name: "SquashedOneof",
      package: "testapis.edgecases.import_squashed_union.pkg1",
      fields: [{
        name: "msg1",
        type: "testapis.edgecases.import_squashed_union.pkg1.OneofMessage1",
        options: { "[graphql.object_type]": { squashUnion: true } },
      }],
    },
  },
});
",
    "name": "testapis/edgecases/import_squashed_union/pkg1/types.pb.pothos.ts",
  },
]
`;

exports[`protobuf-es > 'testapis.edgecases.import_squashed_union.pkg1' > generates files by plugin 'without import prefix' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/edgecases/import_squashed_union/pkg1/types.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { builder } from "../../../../builder";
import {
  OneofMessage1,
  SquashedOneof,
} from "./testapis/edgecases/import_squashed_union/pkg1/types_pb";

export const OneofMessage1$Ref = builder.objectRef<OneofMessage1>(
  "OneofMessage1",
);
builder.objectType(OneofMessage1$Ref, {
  name: "OneofMessage1",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof OneofMessage1;
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.edgecases.import_squashed_union.pkg1.OneofMessage1",
      name: "OneofMessage1",
      package: "testapis.edgecases.import_squashed_union.pkg1",
    },
  },
});

export type OneofMessage1Input$Shape = {
  body: OneofMessage1["body"];
};

export const OneofMessage1Input$Ref: InputObjectRef<OneofMessage1Input$Shape> =
  builder.inputRef<OneofMessage1Input$Shape>("OneofMessage1Input").implement(
    {
      fields: (t) => ({
        body: t.field({
          type: "String",
          required: true,
          extensions: {
            protobufField: { name: "body", typeFullName: "string" },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName:
            "testapis.edgecases.import_squashed_union.pkg1.OneofMessage1",
          name: "OneofMessage1",
          package: "testapis.edgecases.import_squashed_union.pkg1",
        },
      },
    },
  );

export function OneofMessage1Input$toProto(
  input: OneofMessage1Input$Shape | null | undefined,
): OneofMessage1 {
  return new OneofMessage1({
    body: input?.body ?? undefined,
  });
}

export type SquashedOneofInput$Shape = {
  msg1?: OneofMessage1Input$Shape | null;
};

export const SquashedOneofInput$Ref: InputObjectRef<SquashedOneofInput$Shape> =
  builder.inputRef<SquashedOneofInput$Shape>("SquashedOneofInput").implement(
    {
      fields: (t) => ({
        msg1: t.field({
          type: OneofMessage1Input$Ref,
          required: false,
          extensions: {
            protobufField: {
              name: "msg1",
              typeFullName:
                "testapis.edgecases.import_squashed_union.pkg1.OneofMessage1",
            },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName:
            "testapis.edgecases.import_squashed_union.pkg1.SquashedOneof",
          name: "SquashedOneof",
          package: "testapis.edgecases.import_squashed_union.pkg1",
          options: { "[graphql.object_type]": { squashUnion: true } },
        },
      },
    },
  );

export function SquashedOneofInput$toProto(
  input: SquashedOneofInput$Shape | null | undefined,
): SquashedOneof {
  return new SquashedOneof({
    message: input?.msg1
      ? { case: "msg1", value: OneofMessage1Input$toProto(input.msg1) }
      : undefined,
  });
}

export const SquashedOneof$Ref = builder.unionType("SquashedOneof", {
  types: [OneofMessage1$Ref],
  extensions: {
    protobufOneof: {
      fullName: "testapis.edgecases.import_squashed_union.pkg1.SquashedOneof",
      name: "SquashedOneof",
      package: "testapis.edgecases.import_squashed_union.pkg1",
      fields: [{
        name: "msg1",
        type: "testapis.edgecases.import_squashed_union.pkg1.OneofMessage1",
        options: { "[graphql.object_type]": { squashUnion: true } },
      }],
    },
  },
});
",
    "name": "testapis/edgecases/import_squashed_union/pkg1/types.pb.pothos.ts",
  },
]
`;

exports[`protobuf-es > 'testapis.edgecases.import_squashed_union.pkg2' > generates files by plugin 'with import prefix' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/edgecases/import_squashed_union/pkg2/types.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { Message } from "@testapis/protobuf-es/testapis/edgecases/import_squashed_union/pkg2/types_pb";
import { builder } from "../../../../builder";
import {
  SquashedOneof$Ref,
  SquashedOneofInput$Ref,
  SquashedOneofInput$Shape,
  SquashedOneofInput$toProto,
} from "../pkg1/types.pb.pothos";

export const Message$Ref = builder.objectRef<Message>("Message");
builder.objectType(Message$Ref, {
  name: "Message",
  fields: (t) => ({
    msg: t.field({
      type: SquashedOneof$Ref,
      nullable: true,
      resolve: (source) => {
        return source.msg?.message.value;
      },
      extensions: {
        protobufField: {
          name: "msg",
          typeFullName:
            "testapis.edgecases.import_squashed_union.pkg1.SquashedOneof",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof Message;
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.edgecases.import_squashed_union.pkg2.Message",
      name: "Message",
      package: "testapis.edgecases.import_squashed_union.pkg2",
    },
  },
});

export type MessageInput$Shape = {
  msg?: SquashedOneofInput$Shape | null;
};

export const MessageInput$Ref: InputObjectRef<MessageInput$Shape> = builder
  .inputRef<MessageInput$Shape>("MessageInput").implement(
    {
      fields: (t) => ({
        msg: t.field({
          type: SquashedOneofInput$Ref,
          required: false,
          extensions: {
            protobufField: {
              name: "msg",
              typeFullName:
                "testapis.edgecases.import_squashed_union.pkg1.SquashedOneof",
            },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.edgecases.import_squashed_union.pkg2.Message",
          name: "Message",
          package: "testapis.edgecases.import_squashed_union.pkg2",
        },
      },
    },
  );

export function MessageInput$toProto(
  input: MessageInput$Shape | null | undefined,
): Message {
  return new Message({
    msg: input?.msg ? SquashedOneofInput$toProto(input.msg) : undefined,
  });
}
",
    "name": "testapis/edgecases/import_squashed_union/pkg2/types.pb.pothos.ts",
  },
]
`;

exports[`protobuf-es > 'testapis.edgecases.import_squashed_union.pkg2' > generates files by plugin 'with partial inputs' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/edgecases/import_squashed_union/pkg2/types.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { Message } from "@testapis/protobuf-es/testapis/edgecases/import_squashed_union/pkg2/types_pb";
import { builder } from "../../../../builder";
import {
  SquashedOneof$Ref,
  SquashedOneofInput$Ref,
  SquashedOneofInput$Shape,
  SquashedOneofInput$toProto,
  SquashedOneofPartialInput$Ref,
  SquashedOneofPartialInput$Shape,
  SquashedOneofPartialInput$toProto,
} from "../pkg1/types.pb.pothos";

export const Message$Ref = builder.objectRef<Message>("Message");
builder.objectType(Message$Ref, {
  name: "Message",
  fields: (t) => ({
    msg: t.field({
      type: SquashedOneof$Ref,
      nullable: true,
      resolve: (source) => {
        return source.msg?.message.value;
      },
      extensions: {
        protobufField: {
          name: "msg",
          typeFullName:
            "testapis.edgecases.import_squashed_union.pkg1.SquashedOneof",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof Message;
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.edgecases.import_squashed_union.pkg2.Message",
      name: "Message",
      package: "testapis.edgecases.import_squashed_union.pkg2",
    },
  },
});

export type MessageInput$Shape = {
  msg?: SquashedOneofInput$Shape | null;
};

export const MessageInput$Ref: InputObjectRef<MessageInput$Shape> = builder
  .inputRef<MessageInput$Shape>("MessageInput").implement(
    {
      fields: (t) => ({
        msg: t.field({
          type: SquashedOneofInput$Ref,
          required: false,
          extensions: {
            protobufField: {
              name: "msg",
              typeFullName:
                "testapis.edgecases.import_squashed_union.pkg1.SquashedOneof",
            },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.edgecases.import_squashed_union.pkg2.Message",
          name: "Message",
          package: "testapis.edgecases.import_squashed_union.pkg2",
        },
      },
    },
  );

export function MessageInput$toProto(
  input: MessageInput$Shape | null | undefined,
): Message {
  return new Message({
    msg: input?.msg ? SquashedOneofInput$toProto(input.msg) : undefined,
  });
}

export type MessagePartialInput$Shape = {
  msg?: SquashedOneofPartialInput$Shape | null;
};

export const MessagePartialInput$Ref: InputObjectRef<
  MessagePartialInput$Shape
> = builder.inputRef<MessagePartialInput$Shape>("MessagePartialInput")
  .implement(
    {
      fields: (t) => ({
        msg: t.field({
          type: SquashedOneofPartialInput$Ref,
          required: false,
          extensions: {
            protobufField: {
              name: "msg",
              typeFullName:
                "testapis.edgecases.import_squashed_union.pkg1.SquashedOneof",
            },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.edgecases.import_squashed_union.pkg2.Message",
          name: "Message",
          package: "testapis.edgecases.import_squashed_union.pkg2",
        },
      },
    },
  );

export function MessagePartialInput$toProto(
  input: MessagePartialInput$Shape | null | undefined,
): Message {
  return new Message({
    msg: input?.msg ? SquashedOneofPartialInput$toProto(input.msg) : undefined,
  });
}
",
    "name": "testapis/edgecases/import_squashed_union/pkg2/types.pb.pothos.ts",
  },
]
`;

exports[`protobuf-es > 'testapis.edgecases.import_squashed_union.pkg2' > generates files by plugin 'without import prefix' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/edgecases/import_squashed_union/pkg2/types.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { builder } from "../../../../builder";
import {
  SquashedOneof$Ref,
  SquashedOneofInput$Ref,
  SquashedOneofInput$Shape,
  SquashedOneofInput$toProto,
} from "../pkg1/types.pb.pothos";
import { Message } from "./testapis/edgecases/import_squashed_union/pkg2/types_pb";

export const Message$Ref = builder.objectRef<Message>("Message");
builder.objectType(Message$Ref, {
  name: "Message",
  fields: (t) => ({
    msg: t.field({
      type: SquashedOneof$Ref,
      nullable: true,
      resolve: (source) => {
        return source.msg?.message.value;
      },
      extensions: {
        protobufField: {
          name: "msg",
          typeFullName:
            "testapis.edgecases.import_squashed_union.pkg1.SquashedOneof",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof Message;
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.edgecases.import_squashed_union.pkg2.Message",
      name: "Message",
      package: "testapis.edgecases.import_squashed_union.pkg2",
    },
  },
});

export type MessageInput$Shape = {
  msg?: SquashedOneofInput$Shape | null;
};

export const MessageInput$Ref: InputObjectRef<MessageInput$Shape> = builder
  .inputRef<MessageInput$Shape>("MessageInput").implement(
    {
      fields: (t) => ({
        msg: t.field({
          type: SquashedOneofInput$Ref,
          required: false,
          extensions: {
            protobufField: {
              name: "msg",
              typeFullName:
                "testapis.edgecases.import_squashed_union.pkg1.SquashedOneof",
            },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.edgecases.import_squashed_union.pkg2.Message",
          name: "Message",
          package: "testapis.edgecases.import_squashed_union.pkg2",
        },
      },
    },
  );

export function MessageInput$toProto(
  input: MessageInput$Shape | null | undefined,
): Message {
  return new Message({
    msg: input?.msg ? SquashedOneofInput$toProto(input.msg) : undefined,
  });
}
",
    "name": "testapis/edgecases/import_squashed_union/pkg2/types.pb.pothos.ts",
  },
]
`;

exports[`protobuf-es > 'testapis.empty_types' > generates files by plugin 'with import prefix' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/empty_types/empty.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { EmptyMessage } from "@testapis/protobuf-es/testapis/empty_types/empty_pb";
import { builder } from "../../builder";

export const EmptyMessage$Ref = builder.objectRef<EmptyMessage>("EmptyMessage");
builder.objectType(EmptyMessage$Ref, {
  name: "EmptyMessage",
  fields: (t) => ({
    _: t.field({
      type: "Boolean",
      nullable: true,
      description: "noop field",
      resolve: () => true,
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof EmptyMessage;
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.empty_types.EmptyMessage",
      name: "EmptyMessage",
      package: "testapis.empty_types",
    },
  },
});

export type EmptyMessageInput$Shape = {};

export const EmptyMessageInput$Ref: InputObjectRef<EmptyMessageInput$Shape> =
  builder.inputRef<EmptyMessageInput$Shape>("EmptyMessageInput").implement(
    {
      fields: (t) => ({
        _: t.field({
          type: "Boolean",
          required: false,
          description: "noop field",
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.empty_types.EmptyMessage",
          name: "EmptyMessage",
          package: "testapis.empty_types",
        },
      },
    },
  );

export function EmptyMessageInput$toProto(
  input: EmptyMessageInput$Shape | null | undefined,
): EmptyMessage {
  return new EmptyMessage({});
}
",
    "name": "testapis/empty_types/empty.pb.pothos.ts",
  },
]
`;

exports[`protobuf-es > 'testapis.empty_types' > generates files by plugin 'with partial inputs' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/empty_types/empty.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { EmptyMessage } from "@testapis/protobuf-es/testapis/empty_types/empty_pb";
import { builder } from "../../builder";

export const EmptyMessage$Ref = builder.objectRef<EmptyMessage>("EmptyMessage");
builder.objectType(EmptyMessage$Ref, {
  name: "EmptyMessage",
  fields: (t) => ({
    _: t.field({
      type: "Boolean",
      nullable: true,
      description: "noop field",
      resolve: () => true,
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof EmptyMessage;
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.empty_types.EmptyMessage",
      name: "EmptyMessage",
      package: "testapis.empty_types",
    },
  },
});

export type EmptyMessageInput$Shape = {};

export const EmptyMessageInput$Ref: InputObjectRef<EmptyMessageInput$Shape> =
  builder.inputRef<EmptyMessageInput$Shape>("EmptyMessageInput").implement(
    {
      fields: (t) => ({
        _: t.field({
          type: "Boolean",
          required: false,
          description: "noop field",
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.empty_types.EmptyMessage",
          name: "EmptyMessage",
          package: "testapis.empty_types",
        },
      },
    },
  );

export function EmptyMessageInput$toProto(
  input: EmptyMessageInput$Shape | null | undefined,
): EmptyMessage {
  return new EmptyMessage({});
}

export type EmptyMessagePartialInput$Shape = {};

export const EmptyMessagePartialInput$Ref: InputObjectRef<
  EmptyMessagePartialInput$Shape
> = builder.inputRef<EmptyMessagePartialInput$Shape>("EmptyMessagePartialInput")
  .implement(
    {
      fields: (t) => ({
        _: t.field({
          type: "Boolean",
          required: false,
          description: "noop field",
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.empty_types.EmptyMessage",
          name: "EmptyMessage",
          package: "testapis.empty_types",
        },
      },
    },
  );

export function EmptyMessagePartialInput$toProto(
  input: EmptyMessagePartialInput$Shape | null | undefined,
): EmptyMessage {
  return new EmptyMessage({});
}
",
    "name": "testapis/empty_types/empty.pb.pothos.ts",
  },
]
`;

exports[`protobuf-es > 'testapis.empty_types' > generates files by plugin 'without import prefix' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/empty_types/empty.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { builder } from "../../builder";
import { EmptyMessage } from "./testapis/empty_types/empty_pb";

export const EmptyMessage$Ref = builder.objectRef<EmptyMessage>("EmptyMessage");
builder.objectType(EmptyMessage$Ref, {
  name: "EmptyMessage",
  fields: (t) => ({
    _: t.field({
      type: "Boolean",
      nullable: true,
      description: "noop field",
      resolve: () => true,
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof EmptyMessage;
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.empty_types.EmptyMessage",
      name: "EmptyMessage",
      package: "testapis.empty_types",
    },
  },
});

export type EmptyMessageInput$Shape = {};

export const EmptyMessageInput$Ref: InputObjectRef<EmptyMessageInput$Shape> =
  builder.inputRef<EmptyMessageInput$Shape>("EmptyMessageInput").implement(
    {
      fields: (t) => ({
        _: t.field({
          type: "Boolean",
          required: false,
          description: "noop field",
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.empty_types.EmptyMessage",
          name: "EmptyMessage",
          package: "testapis.empty_types",
        },
      },
    },
  );

export function EmptyMessageInput$toProto(
  input: EmptyMessageInput$Shape | null | undefined,
): EmptyMessage {
  return new EmptyMessage({});
}
",
    "name": "testapis/empty_types/empty.pb.pothos.ts",
  },
]
`;

exports[`protobuf-es > 'testapis.enums' > generates files by plugin 'with import prefix' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/enums/enums.proto

/* eslint-disable */

import { EnumRef, InputObjectRef } from "@pothos/core";
import {
  MessageWithEnums,
  MyEnum,
  MyEnumWithoutUnspecified,
} from "@testapis/protobuf-es/testapis/enums/enums_pb";
import { builder } from "../../builder";

export const MessageWithEnums$Ref = builder.objectRef<MessageWithEnums>(
  "MessageWithEnums",
);
builder.objectType(MessageWithEnums$Ref, {
  name: "MessageWithEnums",
  fields: (t) => ({
    requiredMyEnum: t.field({
      type: MyEnum$Ref,
      nullable: false,
      description: "Required.",
      resolve: (source) => {
        if (source.requiredMyEnum === MyEnum.UNSPECIFIED) {
          throw new Error(
            "requiredMyEnum is required field. But got unspecified.",
          );
        }

        return source.requiredMyEnum;
      },
      extensions: {
        protobufField: {
          name: "required_my_enum",
          typeFullName: "testapi.enums.MyEnum",
        },
      },
    }),
    optionalMyEnum: t.field({
      type: MyEnum$Ref,
      nullable: true,
      description: "Optional.",
      resolve: (source) => {
        if (source.optionalMyEnum === MyEnum.UNSPECIFIED) {
          return null;
        }

        return source.optionalMyEnum;
      },
      extensions: {
        protobufField: {
          name: "optional_my_enum",
          typeFullName: "testapi.enums.MyEnum",
        },
      },
    }),
    requiredMyEnumWithoutUnspecified: t.field({
      type: MyEnumWithoutUnspecified$Ref,
      nullable: false,
      description: "Required.",
      resolve: (source) => {
        return source.requiredMyEnumWithoutUnspecified;
      },
      extensions: {
        protobufField: {
          name: "required_my_enum_without_unspecified",
          typeFullName: "testapi.enums.MyEnumWithoutUnspecified",
        },
      },
    }),
    optionalMyEnumWithoutUnspecified: t.field({
      type: MyEnumWithoutUnspecified$Ref,
      nullable: true,
      description: "Optional.",
      resolve: (source) => {
        return source.optionalMyEnumWithoutUnspecified;
      },
      extensions: {
        protobufField: {
          name: "optional_my_enum_without_unspecified",
          typeFullName: "testapi.enums.MyEnumWithoutUnspecified",
        },
      },
    }),
    requiredMyEnums: t.field({
      type: [MyEnum$Ref],
      nullable: { list: false, items: false },
      description: "Required.",
      resolve: (source) => {
        return source.requiredMyEnums.map((item) => {
          if (item === MyEnum.UNSPECIFIED) {
            throw new Error(
              "requiredMyEnums is required field. But got unspecified.",
            );
          }

          return item;
        });
      },
      extensions: {
        protobufField: {
          name: "required_my_enums",
          typeFullName: "testapi.enums.MyEnum",
        },
      },
    }),
    optionalMyEnums: t.field({
      type: [MyEnum$Ref],
      nullable: { list: true, items: false },
      description: "Optional.",
      resolve: (source) => {
        return source.optionalMyEnums.map((item) => {
          if (item === MyEnum.UNSPECIFIED) {
            throw new Error(
              "optionalMyEnums is required field. But got unspecified.",
            );
          }

          return item;
        });
      },
      extensions: {
        protobufField: {
          name: "optional_my_enums",
          typeFullName: "testapi.enums.MyEnum",
        },
      },
    }),
    requiredMyEnumWithoutUnspecifieds: t.field({
      type: [MyEnumWithoutUnspecified$Ref],
      nullable: { list: false, items: false },
      description: "Required.",
      resolve: (source) => {
        return source.requiredMyEnumWithoutUnspecifieds;
      },
      extensions: {
        protobufField: {
          name: "required_my_enum_without_unspecifieds",
          typeFullName: "testapi.enums.MyEnumWithoutUnspecified",
        },
      },
    }),
    optionalMyEnumWithoutUnspecifieds: t.field({
      type: [MyEnumWithoutUnspecified$Ref],
      nullable: { list: true, items: false },
      description: "Optional.",
      resolve: (source) => {
        return source.optionalMyEnumWithoutUnspecifieds;
      },
      extensions: {
        protobufField: {
          name: "optional_my_enum_without_unspecifieds",
          typeFullName: "testapi.enums.MyEnumWithoutUnspecified",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof MessageWithEnums;
  },
  extensions: {
    protobufMessage: {
      fullName: "testapi.enums.MessageWithEnums",
      name: "MessageWithEnums",
      package: "testapi.enums",
    },
  },
});

export type MessageWithEnumsInput$Shape = {
  requiredMyEnum: MessageWithEnums["requiredMyEnum"];
  optionalMyEnum?: MessageWithEnums["optionalMyEnum"] | null;
  requiredMyEnumWithoutUnspecified:
    MessageWithEnums["requiredMyEnumWithoutUnspecified"];
  optionalMyEnumWithoutUnspecified?:
    | MessageWithEnums["optionalMyEnumWithoutUnspecified"]
    | null;
  requiredMyEnums: MessageWithEnums["requiredMyEnums"];
  optionalMyEnums?: MessageWithEnums["optionalMyEnums"] | null;
  requiredMyEnumWithoutUnspecifieds:
    MessageWithEnums["requiredMyEnumWithoutUnspecifieds"];
  optionalMyEnumWithoutUnspecifieds?:
    | MessageWithEnums["optionalMyEnumWithoutUnspecifieds"]
    | null;
};

export const MessageWithEnumsInput$Ref: InputObjectRef<
  MessageWithEnumsInput$Shape
> = builder.inputRef<MessageWithEnumsInput$Shape>("MessageWithEnumsInput")
  .implement(
    {
      fields: (t) => ({
        requiredMyEnum: t.field({
          type: MyEnum$Ref,
          required: true,
          description: "Required.",
          extensions: {
            protobufField: {
              name: "required_my_enum",
              typeFullName: "testapi.enums.MyEnum",
            },
          },
        }),
        optionalMyEnum: t.field({
          type: MyEnum$Ref,
          required: false,
          description: "Optional.",
          extensions: {
            protobufField: {
              name: "optional_my_enum",
              typeFullName: "testapi.enums.MyEnum",
            },
          },
        }),
        requiredMyEnumWithoutUnspecified: t.field({
          type: MyEnumWithoutUnspecified$Ref,
          required: true,
          description: "Required.",
          extensions: {
            protobufField: {
              name: "required_my_enum_without_unspecified",
              typeFullName: "testapi.enums.MyEnumWithoutUnspecified",
            },
          },
        }),
        optionalMyEnumWithoutUnspecified: t.field({
          type: MyEnumWithoutUnspecified$Ref,
          required: false,
          description: "Optional.",
          extensions: {
            protobufField: {
              name: "optional_my_enum_without_unspecified",
              typeFullName: "testapi.enums.MyEnumWithoutUnspecified",
            },
          },
        }),
        requiredMyEnums: t.field({
          type: [MyEnum$Ref],
          required: { list: true, items: true },
          description: "Required.",
          extensions: {
            protobufField: {
              name: "required_my_enums",
              typeFullName: "testapi.enums.MyEnum",
            },
          },
        }),
        optionalMyEnums: t.field({
          type: [MyEnum$Ref],
          required: { list: false, items: true },
          description: "Optional.",
          extensions: {
            protobufField: {
              name: "optional_my_enums",
              typeFullName: "testapi.enums.MyEnum",
            },
          },
        }),
        requiredMyEnumWithoutUnspecifieds: t.field({
          type: [MyEnumWithoutUnspecified$Ref],
          required: { list: true, items: true },
          description: "Required.",
          extensions: {
            protobufField: {
              name: "required_my_enum_without_unspecifieds",
              typeFullName: "testapi.enums.MyEnumWithoutUnspecified",
            },
          },
        }),
        optionalMyEnumWithoutUnspecifieds: t.field({
          type: [MyEnumWithoutUnspecified$Ref],
          required: { list: false, items: true },
          description: "Optional.",
          extensions: {
            protobufField: {
              name: "optional_my_enum_without_unspecifieds",
              typeFullName: "testapi.enums.MyEnumWithoutUnspecified",
            },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapi.enums.MessageWithEnums",
          name: "MessageWithEnums",
          package: "testapi.enums",
        },
      },
    },
  );

export function MessageWithEnumsInput$toProto(
  input: MessageWithEnumsInput$Shape | null | undefined,
): MessageWithEnums {
  return new MessageWithEnums({
    requiredMyEnum: input?.requiredMyEnum ?? undefined,
    optionalMyEnum: input?.optionalMyEnum ?? undefined,
    requiredMyEnumWithoutUnspecified: input?.requiredMyEnumWithoutUnspecified ??
      undefined,
    optionalMyEnumWithoutUnspecified: input?.optionalMyEnumWithoutUnspecified ??
      undefined,
    requiredMyEnums: input?.requiredMyEnums ?? undefined,
    optionalMyEnums: input?.optionalMyEnums ?? undefined,
    requiredMyEnumWithoutUnspecifieds:
      input?.requiredMyEnumWithoutUnspecifieds ?? undefined,
    optionalMyEnumWithoutUnspecifieds:
      input?.optionalMyEnumWithoutUnspecifieds ?? undefined,
  });
}

export const MyEnum$Ref: EnumRef<MyEnum, MyEnum> = builder.enumType("MyEnum", {
  values: {
    FOO: {
      value: 1,
      extensions: { protobufEnumValue: { name: "MY_ENUM_FOO" } },
    },
    BAR: {
      description: "This is Bar.",
      value: 2,
      extensions: { protobufEnumValue: { name: "MY_ENUM_BAR" } },
    },
    BAZ: {
      value: 3,
      extensions: { protobufEnumValue: { name: "MY_ENUM_BAZ" } },
    },
  } as const,
  extensions: {
    protobufEnum: {
      name: "MyEnum",
      fullName: "testapi.enums.MyEnum",
      package: "testapi.enums",
    },
  },
});

export const MyEnumWithoutUnspecified$Ref: EnumRef<
  MyEnumWithoutUnspecified,
  MyEnumWithoutUnspecified
> = builder.enumType("MyEnumWithoutUnspecified", {
  values: {
    FOO: {
      value: 0,
      extensions: {
        protobufEnumValue: { name: "MY_ENUM_WITHOUT_UNSPECIFIED_FOO" },
      },
    },
    BAR: {
      value: 1,
      extensions: {
        protobufEnumValue: { name: "MY_ENUM_WITHOUT_UNSPECIFIED_BAR" },
      },
    },
    BAZ: {
      value: 2,
      extensions: {
        protobufEnumValue: { name: "MY_ENUM_WITHOUT_UNSPECIFIED_BAZ" },
      },
    },
  } as const,
  extensions: {
    protobufEnum: {
      name: "MyEnumWithoutUnspecified",
      fullName: "testapi.enums.MyEnumWithoutUnspecified",
      package: "testapi.enums",
    },
  },
});
",
    "name": "testapis/enums/enums.pb.pothos.ts",
  },
]
`;

exports[`protobuf-es > 'testapis.enums' > generates files by plugin 'with partial inputs' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/enums/enums.proto

/* eslint-disable */

import { EnumRef, InputObjectRef } from "@pothos/core";
import {
  MessageWithEnums,
  MyEnum,
  MyEnumWithoutUnspecified,
} from "@testapis/protobuf-es/testapis/enums/enums_pb";
import { builder } from "../../builder";

export const MessageWithEnums$Ref = builder.objectRef<MessageWithEnums>(
  "MessageWithEnums",
);
builder.objectType(MessageWithEnums$Ref, {
  name: "MessageWithEnums",
  fields: (t) => ({
    requiredMyEnum: t.field({
      type: MyEnum$Ref,
      nullable: false,
      description: "Required.",
      resolve: (source) => {
        if (source.requiredMyEnum === MyEnum.UNSPECIFIED) {
          throw new Error(
            "requiredMyEnum is required field. But got unspecified.",
          );
        }

        return source.requiredMyEnum;
      },
      extensions: {
        protobufField: {
          name: "required_my_enum",
          typeFullName: "testapi.enums.MyEnum",
        },
      },
    }),
    optionalMyEnum: t.field({
      type: MyEnum$Ref,
      nullable: true,
      description: "Optional.",
      resolve: (source) => {
        if (source.optionalMyEnum === MyEnum.UNSPECIFIED) {
          return null;
        }

        return source.optionalMyEnum;
      },
      extensions: {
        protobufField: {
          name: "optional_my_enum",
          typeFullName: "testapi.enums.MyEnum",
        },
      },
    }),
    requiredMyEnumWithoutUnspecified: t.field({
      type: MyEnumWithoutUnspecified$Ref,
      nullable: false,
      description: "Required.",
      resolve: (source) => {
        return source.requiredMyEnumWithoutUnspecified;
      },
      extensions: {
        protobufField: {
          name: "required_my_enum_without_unspecified",
          typeFullName: "testapi.enums.MyEnumWithoutUnspecified",
        },
      },
    }),
    optionalMyEnumWithoutUnspecified: t.field({
      type: MyEnumWithoutUnspecified$Ref,
      nullable: true,
      description: "Optional.",
      resolve: (source) => {
        return source.optionalMyEnumWithoutUnspecified;
      },
      extensions: {
        protobufField: {
          name: "optional_my_enum_without_unspecified",
          typeFullName: "testapi.enums.MyEnumWithoutUnspecified",
        },
      },
    }),
    requiredMyEnums: t.field({
      type: [MyEnum$Ref],
      nullable: { list: false, items: false },
      description: "Required.",
      resolve: (source) => {
        return source.requiredMyEnums.map((item) => {
          if (item === MyEnum.UNSPECIFIED) {
            throw new Error(
              "requiredMyEnums is required field. But got unspecified.",
            );
          }

          return item;
        });
      },
      extensions: {
        protobufField: {
          name: "required_my_enums",
          typeFullName: "testapi.enums.MyEnum",
        },
      },
    }),
    optionalMyEnums: t.field({
      type: [MyEnum$Ref],
      nullable: { list: true, items: false },
      description: "Optional.",
      resolve: (source) => {
        return source.optionalMyEnums.map((item) => {
          if (item === MyEnum.UNSPECIFIED) {
            throw new Error(
              "optionalMyEnums is required field. But got unspecified.",
            );
          }

          return item;
        });
      },
      extensions: {
        protobufField: {
          name: "optional_my_enums",
          typeFullName: "testapi.enums.MyEnum",
        },
      },
    }),
    requiredMyEnumWithoutUnspecifieds: t.field({
      type: [MyEnumWithoutUnspecified$Ref],
      nullable: { list: false, items: false },
      description: "Required.",
      resolve: (source) => {
        return source.requiredMyEnumWithoutUnspecifieds;
      },
      extensions: {
        protobufField: {
          name: "required_my_enum_without_unspecifieds",
          typeFullName: "testapi.enums.MyEnumWithoutUnspecified",
        },
      },
    }),
    optionalMyEnumWithoutUnspecifieds: t.field({
      type: [MyEnumWithoutUnspecified$Ref],
      nullable: { list: true, items: false },
      description: "Optional.",
      resolve: (source) => {
        return source.optionalMyEnumWithoutUnspecifieds;
      },
      extensions: {
        protobufField: {
          name: "optional_my_enum_without_unspecifieds",
          typeFullName: "testapi.enums.MyEnumWithoutUnspecified",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof MessageWithEnums;
  },
  extensions: {
    protobufMessage: {
      fullName: "testapi.enums.MessageWithEnums",
      name: "MessageWithEnums",
      package: "testapi.enums",
    },
  },
});

export type MessageWithEnumsInput$Shape = {
  requiredMyEnum: MessageWithEnums["requiredMyEnum"];
  optionalMyEnum?: MessageWithEnums["optionalMyEnum"] | null;
  requiredMyEnumWithoutUnspecified:
    MessageWithEnums["requiredMyEnumWithoutUnspecified"];
  optionalMyEnumWithoutUnspecified?:
    | MessageWithEnums["optionalMyEnumWithoutUnspecified"]
    | null;
  requiredMyEnums: MessageWithEnums["requiredMyEnums"];
  optionalMyEnums?: MessageWithEnums["optionalMyEnums"] | null;
  requiredMyEnumWithoutUnspecifieds:
    MessageWithEnums["requiredMyEnumWithoutUnspecifieds"];
  optionalMyEnumWithoutUnspecifieds?:
    | MessageWithEnums["optionalMyEnumWithoutUnspecifieds"]
    | null;
};

export const MessageWithEnumsInput$Ref: InputObjectRef<
  MessageWithEnumsInput$Shape
> = builder.inputRef<MessageWithEnumsInput$Shape>("MessageWithEnumsInput")
  .implement(
    {
      fields: (t) => ({
        requiredMyEnum: t.field({
          type: MyEnum$Ref,
          required: true,
          description: "Required.",
          extensions: {
            protobufField: {
              name: "required_my_enum",
              typeFullName: "testapi.enums.MyEnum",
            },
          },
        }),
        optionalMyEnum: t.field({
          type: MyEnum$Ref,
          required: false,
          description: "Optional.",
          extensions: {
            protobufField: {
              name: "optional_my_enum",
              typeFullName: "testapi.enums.MyEnum",
            },
          },
        }),
        requiredMyEnumWithoutUnspecified: t.field({
          type: MyEnumWithoutUnspecified$Ref,
          required: true,
          description: "Required.",
          extensions: {
            protobufField: {
              name: "required_my_enum_without_unspecified",
              typeFullName: "testapi.enums.MyEnumWithoutUnspecified",
            },
          },
        }),
        optionalMyEnumWithoutUnspecified: t.field({
          type: MyEnumWithoutUnspecified$Ref,
          required: false,
          description: "Optional.",
          extensions: {
            protobufField: {
              name: "optional_my_enum_without_unspecified",
              typeFullName: "testapi.enums.MyEnumWithoutUnspecified",
            },
          },
        }),
        requiredMyEnums: t.field({
          type: [MyEnum$Ref],
          required: { list: true, items: true },
          description: "Required.",
          extensions: {
            protobufField: {
              name: "required_my_enums",
              typeFullName: "testapi.enums.MyEnum",
            },
          },
        }),
        optionalMyEnums: t.field({
          type: [MyEnum$Ref],
          required: { list: false, items: true },
          description: "Optional.",
          extensions: {
            protobufField: {
              name: "optional_my_enums",
              typeFullName: "testapi.enums.MyEnum",
            },
          },
        }),
        requiredMyEnumWithoutUnspecifieds: t.field({
          type: [MyEnumWithoutUnspecified$Ref],
          required: { list: true, items: true },
          description: "Required.",
          extensions: {
            protobufField: {
              name: "required_my_enum_without_unspecifieds",
              typeFullName: "testapi.enums.MyEnumWithoutUnspecified",
            },
          },
        }),
        optionalMyEnumWithoutUnspecifieds: t.field({
          type: [MyEnumWithoutUnspecified$Ref],
          required: { list: false, items: true },
          description: "Optional.",
          extensions: {
            protobufField: {
              name: "optional_my_enum_without_unspecifieds",
              typeFullName: "testapi.enums.MyEnumWithoutUnspecified",
            },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapi.enums.MessageWithEnums",
          name: "MessageWithEnums",
          package: "testapi.enums",
        },
      },
    },
  );

export function MessageWithEnumsInput$toProto(
  input: MessageWithEnumsInput$Shape | null | undefined,
): MessageWithEnums {
  return new MessageWithEnums({
    requiredMyEnum: input?.requiredMyEnum ?? undefined,
    optionalMyEnum: input?.optionalMyEnum ?? undefined,
    requiredMyEnumWithoutUnspecified: input?.requiredMyEnumWithoutUnspecified ??
      undefined,
    optionalMyEnumWithoutUnspecified: input?.optionalMyEnumWithoutUnspecified ??
      undefined,
    requiredMyEnums: input?.requiredMyEnums ?? undefined,
    optionalMyEnums: input?.optionalMyEnums ?? undefined,
    requiredMyEnumWithoutUnspecifieds:
      input?.requiredMyEnumWithoutUnspecifieds ?? undefined,
    optionalMyEnumWithoutUnspecifieds:
      input?.optionalMyEnumWithoutUnspecifieds ?? undefined,
  });
}

export type MessageWithEnumsPartialInput$Shape = {
  requiredMyEnum?: MessageWithEnums["requiredMyEnum"] | null;
  optionalMyEnum?: MessageWithEnums["optionalMyEnum"] | null;
  requiredMyEnumWithoutUnspecified?:
    | MessageWithEnums["requiredMyEnumWithoutUnspecified"]
    | null;
  optionalMyEnumWithoutUnspecified?:
    | MessageWithEnums["optionalMyEnumWithoutUnspecified"]
    | null;
  requiredMyEnums?: MessageWithEnums["requiredMyEnums"] | null;
  optionalMyEnums?: MessageWithEnums["optionalMyEnums"] | null;
  requiredMyEnumWithoutUnspecifieds?:
    | MessageWithEnums["requiredMyEnumWithoutUnspecifieds"]
    | null;
  optionalMyEnumWithoutUnspecifieds?:
    | MessageWithEnums["optionalMyEnumWithoutUnspecifieds"]
    | null;
};

export const MessageWithEnumsPartialInput$Ref: InputObjectRef<
  MessageWithEnumsPartialInput$Shape
> = builder.inputRef<MessageWithEnumsPartialInput$Shape>(
  "MessageWithEnumsPartialInput",
).implement(
  {
    fields: (t) => ({
      requiredMyEnum: t.field({
        type: MyEnum$Ref,
        required: false,
        description: "Required.",
        extensions: {
          protobufField: {
            name: "required_my_enum",
            typeFullName: "testapi.enums.MyEnum",
          },
        },
      }),
      optionalMyEnum: t.field({
        type: MyEnum$Ref,
        required: false,
        description: "Optional.",
        extensions: {
          protobufField: {
            name: "optional_my_enum",
            typeFullName: "testapi.enums.MyEnum",
          },
        },
      }),
      requiredMyEnumWithoutUnspecified: t.field({
        type: MyEnumWithoutUnspecified$Ref,
        required: false,
        description: "Required.",
        extensions: {
          protobufField: {
            name: "required_my_enum_without_unspecified",
            typeFullName: "testapi.enums.MyEnumWithoutUnspecified",
          },
        },
      }),
      optionalMyEnumWithoutUnspecified: t.field({
        type: MyEnumWithoutUnspecified$Ref,
        required: false,
        description: "Optional.",
        extensions: {
          protobufField: {
            name: "optional_my_enum_without_unspecified",
            typeFullName: "testapi.enums.MyEnumWithoutUnspecified",
          },
        },
      }),
      requiredMyEnums: t.field({
        type: [MyEnum$Ref],
        required: { list: false, items: true },
        description: "Required.",
        extensions: {
          protobufField: {
            name: "required_my_enums",
            typeFullName: "testapi.enums.MyEnum",
          },
        },
      }),
      optionalMyEnums: t.field({
        type: [MyEnum$Ref],
        required: { list: false, items: true },
        description: "Optional.",
        extensions: {
          protobufField: {
            name: "optional_my_enums",
            typeFullName: "testapi.enums.MyEnum",
          },
        },
      }),
      requiredMyEnumWithoutUnspecifieds: t.field({
        type: [MyEnumWithoutUnspecified$Ref],
        required: { list: false, items: true },
        description: "Required.",
        extensions: {
          protobufField: {
            name: "required_my_enum_without_unspecifieds",
            typeFullName: "testapi.enums.MyEnumWithoutUnspecified",
          },
        },
      }),
      optionalMyEnumWithoutUnspecifieds: t.field({
        type: [MyEnumWithoutUnspecified$Ref],
        required: { list: false, items: true },
        description: "Optional.",
        extensions: {
          protobufField: {
            name: "optional_my_enum_without_unspecifieds",
            typeFullName: "testapi.enums.MyEnumWithoutUnspecified",
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapi.enums.MessageWithEnums",
        name: "MessageWithEnums",
        package: "testapi.enums",
      },
    },
  },
);

export function MessageWithEnumsPartialInput$toProto(
  input: MessageWithEnumsPartialInput$Shape | null | undefined,
): MessageWithEnums {
  return new MessageWithEnums({
    requiredMyEnum: input?.requiredMyEnum ?? undefined,
    optionalMyEnum: input?.optionalMyEnum ?? undefined,
    requiredMyEnumWithoutUnspecified: input?.requiredMyEnumWithoutUnspecified ??
      undefined,
    optionalMyEnumWithoutUnspecified: input?.optionalMyEnumWithoutUnspecified ??
      undefined,
    requiredMyEnums: input?.requiredMyEnums ?? undefined,
    optionalMyEnums: input?.optionalMyEnums ?? undefined,
    requiredMyEnumWithoutUnspecifieds:
      input?.requiredMyEnumWithoutUnspecifieds ?? undefined,
    optionalMyEnumWithoutUnspecifieds:
      input?.optionalMyEnumWithoutUnspecifieds ?? undefined,
  });
}

export const MyEnum$Ref: EnumRef<MyEnum, MyEnum> = builder.enumType("MyEnum", {
  values: {
    FOO: {
      value: 1,
      extensions: { protobufEnumValue: { name: "MY_ENUM_FOO" } },
    },
    BAR: {
      description: "This is Bar.",
      value: 2,
      extensions: { protobufEnumValue: { name: "MY_ENUM_BAR" } },
    },
    BAZ: {
      value: 3,
      extensions: { protobufEnumValue: { name: "MY_ENUM_BAZ" } },
    },
  } as const,
  extensions: {
    protobufEnum: {
      name: "MyEnum",
      fullName: "testapi.enums.MyEnum",
      package: "testapi.enums",
    },
  },
});

export const MyEnumWithoutUnspecified$Ref: EnumRef<
  MyEnumWithoutUnspecified,
  MyEnumWithoutUnspecified
> = builder.enumType("MyEnumWithoutUnspecified", {
  values: {
    FOO: {
      value: 0,
      extensions: {
        protobufEnumValue: { name: "MY_ENUM_WITHOUT_UNSPECIFIED_FOO" },
      },
    },
    BAR: {
      value: 1,
      extensions: {
        protobufEnumValue: { name: "MY_ENUM_WITHOUT_UNSPECIFIED_BAR" },
      },
    },
    BAZ: {
      value: 2,
      extensions: {
        protobufEnumValue: { name: "MY_ENUM_WITHOUT_UNSPECIFIED_BAZ" },
      },
    },
  } as const,
  extensions: {
    protobufEnum: {
      name: "MyEnumWithoutUnspecified",
      fullName: "testapi.enums.MyEnumWithoutUnspecified",
      package: "testapi.enums",
    },
  },
});
",
    "name": "testapis/enums/enums.pb.pothos.ts",
  },
]
`;

exports[`protobuf-es > 'testapis.enums' > generates files by plugin 'without import prefix' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/enums/enums.proto

/* eslint-disable */

import { EnumRef, InputObjectRef } from "@pothos/core";
import { builder } from "../../builder";
import {
  MessageWithEnums,
  MyEnum,
  MyEnumWithoutUnspecified,
} from "./testapis/enums/enums_pb";

export const MessageWithEnums$Ref = builder.objectRef<MessageWithEnums>(
  "MessageWithEnums",
);
builder.objectType(MessageWithEnums$Ref, {
  name: "MessageWithEnums",
  fields: (t) => ({
    requiredMyEnum: t.field({
      type: MyEnum$Ref,
      nullable: false,
      description: "Required.",
      resolve: (source) => {
        if (source.requiredMyEnum === MyEnum.UNSPECIFIED) {
          throw new Error(
            "requiredMyEnum is required field. But got unspecified.",
          );
        }

        return source.requiredMyEnum;
      },
      extensions: {
        protobufField: {
          name: "required_my_enum",
          typeFullName: "testapi.enums.MyEnum",
        },
      },
    }),
    optionalMyEnum: t.field({
      type: MyEnum$Ref,
      nullable: true,
      description: "Optional.",
      resolve: (source) => {
        if (source.optionalMyEnum === MyEnum.UNSPECIFIED) {
          return null;
        }

        return source.optionalMyEnum;
      },
      extensions: {
        protobufField: {
          name: "optional_my_enum",
          typeFullName: "testapi.enums.MyEnum",
        },
      },
    }),
    requiredMyEnumWithoutUnspecified: t.field({
      type: MyEnumWithoutUnspecified$Ref,
      nullable: false,
      description: "Required.",
      resolve: (source) => {
        return source.requiredMyEnumWithoutUnspecified;
      },
      extensions: {
        protobufField: {
          name: "required_my_enum_without_unspecified",
          typeFullName: "testapi.enums.MyEnumWithoutUnspecified",
        },
      },
    }),
    optionalMyEnumWithoutUnspecified: t.field({
      type: MyEnumWithoutUnspecified$Ref,
      nullable: true,
      description: "Optional.",
      resolve: (source) => {
        return source.optionalMyEnumWithoutUnspecified;
      },
      extensions: {
        protobufField: {
          name: "optional_my_enum_without_unspecified",
          typeFullName: "testapi.enums.MyEnumWithoutUnspecified",
        },
      },
    }),
    requiredMyEnums: t.field({
      type: [MyEnum$Ref],
      nullable: { list: false, items: false },
      description: "Required.",
      resolve: (source) => {
        return source.requiredMyEnums.map((item) => {
          if (item === MyEnum.UNSPECIFIED) {
            throw new Error(
              "requiredMyEnums is required field. But got unspecified.",
            );
          }

          return item;
        });
      },
      extensions: {
        protobufField: {
          name: "required_my_enums",
          typeFullName: "testapi.enums.MyEnum",
        },
      },
    }),
    optionalMyEnums: t.field({
      type: [MyEnum$Ref],
      nullable: { list: true, items: false },
      description: "Optional.",
      resolve: (source) => {
        return source.optionalMyEnums.map((item) => {
          if (item === MyEnum.UNSPECIFIED) {
            throw new Error(
              "optionalMyEnums is required field. But got unspecified.",
            );
          }

          return item;
        });
      },
      extensions: {
        protobufField: {
          name: "optional_my_enums",
          typeFullName: "testapi.enums.MyEnum",
        },
      },
    }),
    requiredMyEnumWithoutUnspecifieds: t.field({
      type: [MyEnumWithoutUnspecified$Ref],
      nullable: { list: false, items: false },
      description: "Required.",
      resolve: (source) => {
        return source.requiredMyEnumWithoutUnspecifieds;
      },
      extensions: {
        protobufField: {
          name: "required_my_enum_without_unspecifieds",
          typeFullName: "testapi.enums.MyEnumWithoutUnspecified",
        },
      },
    }),
    optionalMyEnumWithoutUnspecifieds: t.field({
      type: [MyEnumWithoutUnspecified$Ref],
      nullable: { list: true, items: false },
      description: "Optional.",
      resolve: (source) => {
        return source.optionalMyEnumWithoutUnspecifieds;
      },
      extensions: {
        protobufField: {
          name: "optional_my_enum_without_unspecifieds",
          typeFullName: "testapi.enums.MyEnumWithoutUnspecified",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof MessageWithEnums;
  },
  extensions: {
    protobufMessage: {
      fullName: "testapi.enums.MessageWithEnums",
      name: "MessageWithEnums",
      package: "testapi.enums",
    },
  },
});

export type MessageWithEnumsInput$Shape = {
  requiredMyEnum: MessageWithEnums["requiredMyEnum"];
  optionalMyEnum?: MessageWithEnums["optionalMyEnum"] | null;
  requiredMyEnumWithoutUnspecified:
    MessageWithEnums["requiredMyEnumWithoutUnspecified"];
  optionalMyEnumWithoutUnspecified?:
    | MessageWithEnums["optionalMyEnumWithoutUnspecified"]
    | null;
  requiredMyEnums: MessageWithEnums["requiredMyEnums"];
  optionalMyEnums?: MessageWithEnums["optionalMyEnums"] | null;
  requiredMyEnumWithoutUnspecifieds:
    MessageWithEnums["requiredMyEnumWithoutUnspecifieds"];
  optionalMyEnumWithoutUnspecifieds?:
    | MessageWithEnums["optionalMyEnumWithoutUnspecifieds"]
    | null;
};

export const MessageWithEnumsInput$Ref: InputObjectRef<
  MessageWithEnumsInput$Shape
> = builder.inputRef<MessageWithEnumsInput$Shape>("MessageWithEnumsInput")
  .implement(
    {
      fields: (t) => ({
        requiredMyEnum: t.field({
          type: MyEnum$Ref,
          required: true,
          description: "Required.",
          extensions: {
            protobufField: {
              name: "required_my_enum",
              typeFullName: "testapi.enums.MyEnum",
            },
          },
        }),
        optionalMyEnum: t.field({
          type: MyEnum$Ref,
          required: false,
          description: "Optional.",
          extensions: {
            protobufField: {
              name: "optional_my_enum",
              typeFullName: "testapi.enums.MyEnum",
            },
          },
        }),
        requiredMyEnumWithoutUnspecified: t.field({
          type: MyEnumWithoutUnspecified$Ref,
          required: true,
          description: "Required.",
          extensions: {
            protobufField: {
              name: "required_my_enum_without_unspecified",
              typeFullName: "testapi.enums.MyEnumWithoutUnspecified",
            },
          },
        }),
        optionalMyEnumWithoutUnspecified: t.field({
          type: MyEnumWithoutUnspecified$Ref,
          required: false,
          description: "Optional.",
          extensions: {
            protobufField: {
              name: "optional_my_enum_without_unspecified",
              typeFullName: "testapi.enums.MyEnumWithoutUnspecified",
            },
          },
        }),
        requiredMyEnums: t.field({
          type: [MyEnum$Ref],
          required: { list: true, items: true },
          description: "Required.",
          extensions: {
            protobufField: {
              name: "required_my_enums",
              typeFullName: "testapi.enums.MyEnum",
            },
          },
        }),
        optionalMyEnums: t.field({
          type: [MyEnum$Ref],
          required: { list: false, items: true },
          description: "Optional.",
          extensions: {
            protobufField: {
              name: "optional_my_enums",
              typeFullName: "testapi.enums.MyEnum",
            },
          },
        }),
        requiredMyEnumWithoutUnspecifieds: t.field({
          type: [MyEnumWithoutUnspecified$Ref],
          required: { list: true, items: true },
          description: "Required.",
          extensions: {
            protobufField: {
              name: "required_my_enum_without_unspecifieds",
              typeFullName: "testapi.enums.MyEnumWithoutUnspecified",
            },
          },
        }),
        optionalMyEnumWithoutUnspecifieds: t.field({
          type: [MyEnumWithoutUnspecified$Ref],
          required: { list: false, items: true },
          description: "Optional.",
          extensions: {
            protobufField: {
              name: "optional_my_enum_without_unspecifieds",
              typeFullName: "testapi.enums.MyEnumWithoutUnspecified",
            },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapi.enums.MessageWithEnums",
          name: "MessageWithEnums",
          package: "testapi.enums",
        },
      },
    },
  );

export function MessageWithEnumsInput$toProto(
  input: MessageWithEnumsInput$Shape | null | undefined,
): MessageWithEnums {
  return new MessageWithEnums({
    requiredMyEnum: input?.requiredMyEnum ?? undefined,
    optionalMyEnum: input?.optionalMyEnum ?? undefined,
    requiredMyEnumWithoutUnspecified: input?.requiredMyEnumWithoutUnspecified ??
      undefined,
    optionalMyEnumWithoutUnspecified: input?.optionalMyEnumWithoutUnspecified ??
      undefined,
    requiredMyEnums: input?.requiredMyEnums ?? undefined,
    optionalMyEnums: input?.optionalMyEnums ?? undefined,
    requiredMyEnumWithoutUnspecifieds:
      input?.requiredMyEnumWithoutUnspecifieds ?? undefined,
    optionalMyEnumWithoutUnspecifieds:
      input?.optionalMyEnumWithoutUnspecifieds ?? undefined,
  });
}

export const MyEnum$Ref: EnumRef<MyEnum, MyEnum> = builder.enumType("MyEnum", {
  values: {
    FOO: {
      value: 1,
      extensions: { protobufEnumValue: { name: "MY_ENUM_FOO" } },
    },
    BAR: {
      description: "This is Bar.",
      value: 2,
      extensions: { protobufEnumValue: { name: "MY_ENUM_BAR" } },
    },
    BAZ: {
      value: 3,
      extensions: { protobufEnumValue: { name: "MY_ENUM_BAZ" } },
    },
  } as const,
  extensions: {
    protobufEnum: {
      name: "MyEnum",
      fullName: "testapi.enums.MyEnum",
      package: "testapi.enums",
    },
  },
});

export const MyEnumWithoutUnspecified$Ref: EnumRef<
  MyEnumWithoutUnspecified,
  MyEnumWithoutUnspecified
> = builder.enumType("MyEnumWithoutUnspecified", {
  values: {
    FOO: {
      value: 0,
      extensions: {
        protobufEnumValue: { name: "MY_ENUM_WITHOUT_UNSPECIFIED_FOO" },
      },
    },
    BAR: {
      value: 1,
      extensions: {
        protobufEnumValue: { name: "MY_ENUM_WITHOUT_UNSPECIFIED_BAR" },
      },
    },
    BAZ: {
      value: 2,
      extensions: {
        protobufEnumValue: { name: "MY_ENUM_WITHOUT_UNSPECIFIED_BAZ" },
      },
    },
  } as const,
  extensions: {
    protobufEnum: {
      name: "MyEnumWithoutUnspecified",
      fullName: "testapi.enums.MyEnumWithoutUnspecified",
      package: "testapi.enums",
    },
  },
});
",
    "name": "testapis/enums/enums.pb.pothos.ts",
  },
]
`;

exports[`protobuf-es > 'testapis.extensions' > generates files by plugin 'with import prefix' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/extensions/extensions.proto

/* eslint-disable */

import { EnumRef, InputObjectRef } from "@pothos/core";
import {
  EnumWillRename,
  IgnoredMessage_NotIgnored,
  InterfaceMessage,
  InterfaceMessage_Type,
  MessageOnlyOutput,
  MessageWillRename,
  PrefixedEnum,
  PrefixedMessage,
  PrefixedMessage_InnerMessage,
  PrefixedMessage_InnerMessage2,
  PrefixedMessage_SquashedMessage,
} from "@testapis/protobuf-es/testapis/extensions/extensions_pb";
import { builder } from "../../builder";

export const TestPrefixPrefixedMessage$Ref = builder.objectRef<PrefixedMessage>(
  "TestPrefixPrefixedMessage",
);
builder.objectType(TestPrefixPrefixedMessage$Ref, {
  name: "TestPrefixPrefixedMessage",
  fields: (t) => ({
    id: t.expose("id", {
      type: "Int64",
      nullable: false,
      description: "Output only.",
      extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
    }),
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
    prefixedEnum: t.field({
      type: TestPrefixPrefixedEnum$Ref,
      nullable: true,
      resolve: (source) => {
        if (source.prefixedEnum === PrefixedEnum.PREFIXED_ENUM_UNSPECIFIED) {
          return null;
        }

        if (source.prefixedEnum === PrefixedEnum.PREFIXED_IGNORED) {
          throw new Error("PREFIXED_IGNORED is ignored in GraphQL schema");
        }

        return source.prefixedEnum;
      },
      extensions: {
        protobufField: {
          name: "prefixed_enum",
          typeFullName: "testapis.extensions.PrefixedEnum",
        },
      },
    }),
    notIgnoredMessage: t.expose("notIgnoredMessage", {
      type: TestPrefixIgnoredMessageNotIgnored$Ref,
      nullable: true,
      extensions: {
        protobufField: {
          name: "not_ignored_message",
          typeFullName: "testapis.extensions.IgnoredMessage.NotIgnored",
        },
      },
    }),
    squashedMessage: t.field({
      type: TestPrefixPrefixedMessageSquashedMessage$Ref,
      nullable: true,
      resolve: (source) => {
        return source.squashedMessage?.squashedMessage.value;
      },
      extensions: {
        protobufField: {
          name: "squashed_message",
          typeFullName: "testapis.extensions.PrefixedMessage.SquashedMessage",
        },
      },
    }),
    thisFieldWasRenamed: t.expose("thisFieldWillBeRenamed", {
      type: "String",
      nullable: false,
      extensions: {
        protobufField: {
          name: "this_field_will_be_renamed",
          typeFullName: "string",
          options: { "[graphql.field]": { name: "thisFieldWasRenamed" } },
        },
      },
    }),
    skipResolver: t.expose("skipResolver", {
      type: "String",
      nullable: false,
      extensions: {
        protobufField: {
          name: "skip_resolver",
          typeFullName: "string",
          options: { "[graphql.field]": { skipResolver: true } },
        },
      },
    }),
    squashedMessages: t.field({
      type: [TestPrefixPrefixedMessageSquashedMessage$Ref],
      nullable: { list: true, items: false },
      resolve: (source) => {
        return source.squashedMessages.map((item) => {
          const value = item.squashedMessage.value;
          if (value == null) {
            throw new Error("squashedMessages should not be null");
          }
          return value;
        });
      },
      extensions: {
        protobufField: {
          name: "squashed_messages",
          typeFullName: "testapis.extensions.PrefixedMessage.SquashedMessage",
        },
      },
    }),
    renamedMessage: t.expose("renamedMessage", {
      type: TestPrefixRenamedMessage$Ref,
      nullable: true,
      extensions: {
        protobufField: {
          name: "renamed_message",
          typeFullName: "testapis.extensions.MessageWillRename",
        },
      },
    }),
    renamedEnum: t.field({
      type: TestPrefixRenamedEnum$Ref,
      nullable: true,
      resolve: (source) => {
        if (source.renamedEnum === EnumWillRename.UNSPECIFIED) {
          return null;
        }

        return source.renamedEnum;
      },
      extensions: {
        protobufField: {
          name: "renamed_enum",
          typeFullName: "testapis.extensions.EnumWillRename",
        },
      },
    }),
    partialIgnoreOneof: t.field({
      type: TestPrefixPrefixedMessagePartialIgnoreOneof$Ref,
      nullable: true,
      resolve: (source) => {
        return source.partialIgnoreOneof.value;
      },
      extensions: { protobufField: { name: "partial_ignore_oneof" } },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof PrefixedMessage;
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.PrefixedMessage",
      name: "PrefixedMessage",
      package: "testapis.extensions",
    },
  },
});

export const TestPrefixRenamedMessage$Ref = builder.objectRef<
  MessageWillRename
>("TestPrefixRenamedMessage");
builder.objectType(TestPrefixRenamedMessage$Ref, {
  name: "TestPrefixRenamedMessage",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof MessageWillRename;
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.MessageWillRename",
      name: "MessageWillRename",
      package: "testapis.extensions",
      options: { "[graphql.object_type]": { name: "RenamedMessage" } },
    },
  },
});

export const TestPrefixMessageOnlyOutput$Ref = builder.objectRef<
  MessageOnlyOutput
>("TestPrefixMessageOnlyOutput");
builder.objectType(TestPrefixMessageOnlyOutput$Ref, {
  name: "TestPrefixMessageOnlyOutput",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof MessageOnlyOutput;
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.MessageOnlyOutput",
      name: "MessageOnlyOutput",
      package: "testapis.extensions",
      options: { "[graphql.input_type]": { ignore: true } },
    },
  },
});

export const TestPrefixPrefixedMessageInnerMessage$Ref = builder.objectRef<
  PrefixedMessage_InnerMessage
>("TestPrefixPrefixedMessageInnerMessage");
builder.objectType(TestPrefixPrefixedMessageInnerMessage$Ref, {
  name: "TestPrefixPrefixedMessageInnerMessage",
  fields: (t) => ({
    id: t.expose("id", {
      type: "Int64",
      nullable: false,
      extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
    }),
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof PrefixedMessage_InnerMessage;
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.PrefixedMessage.InnerMessage",
      name: "InnerMessage",
      package: "testapis.extensions",
    },
  },
});

export const TestPrefixPrefixedMessageInnerMessage2$Ref = builder.objectRef<
  PrefixedMessage_InnerMessage2
>("TestPrefixPrefixedMessageInnerMessage2");
builder.objectType(TestPrefixPrefixedMessageInnerMessage2$Ref, {
  name: "TestPrefixPrefixedMessageInnerMessage2",
  fields: (t) => ({
    id: t.expose("id", {
      type: "Int64",
      nullable: false,
      extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
    }),
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof PrefixedMessage_InnerMessage2;
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.PrefixedMessage.InnerMessage2",
      name: "InnerMessage2",
      package: "testapis.extensions",
    },
  },
});

export const TestPrefixIgnoredMessageNotIgnored$Ref = builder.objectRef<
  IgnoredMessage_NotIgnored
>("TestPrefixIgnoredMessageNotIgnored");
builder.objectType(TestPrefixIgnoredMessageNotIgnored$Ref, {
  name: "TestPrefixIgnoredMessageNotIgnored",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof IgnoredMessage_NotIgnored;
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.IgnoredMessage.NotIgnored",
      name: "NotIgnored",
      package: "testapis.extensions",
    },
  },
});

export type TestPrefixPrefixedMessageInput$Shape = {
  body: PrefixedMessage["body"];
  prefixedEnum?: PrefixedMessage["prefixedEnum"] | null;
  notIgnoredMessage?: TestPrefixIgnoredMessageNotIgnoredInput$Shape | null;
  squashedMessage?: TestPrefixPrefixedMessageSquashedMessageInput$Shape | null;
  thisFieldWasRenamed: PrefixedMessage["thisFieldWillBeRenamed"];
  oneofNotIgnoredField?:
    | TestPrefixPrefixedMessageInnerMessageInput$Shape
    | null;
  skipResolver: PrefixedMessage["skipResolver"];
  squashedMessages?:
    | Array<TestPrefixPrefixedMessageSquashedMessageInput$Shape>
    | null;
  renamedMessage?: TestPrefixRenamedMessageInput$Shape | null;
  renamedEnum?: PrefixedMessage["renamedEnum"] | null;
};

export const TestPrefixPrefixedMessageInput$Ref: InputObjectRef<
  TestPrefixPrefixedMessageInput$Shape
> = builder.inputRef<TestPrefixPrefixedMessageInput$Shape>(
  "TestPrefixPrefixedMessageInput",
).implement(
  {
    fields: (t) => ({
      body: t.field({
        type: "String",
        required: true,
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
      prefixedEnum: t.field({
        type: TestPrefixPrefixedEnum$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "prefixed_enum",
            typeFullName: "testapis.extensions.PrefixedEnum",
          },
        },
      }),
      notIgnoredMessage: t.field({
        type: TestPrefixIgnoredMessageNotIgnoredInput$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "not_ignored_message",
            typeFullName: "testapis.extensions.IgnoredMessage.NotIgnored",
          },
        },
      }),
      squashedMessage: t.field({
        type: TestPrefixPrefixedMessageSquashedMessageInput$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "squashed_message",
            typeFullName: "testapis.extensions.PrefixedMessage.SquashedMessage",
          },
        },
      }),
      thisFieldWasRenamed: t.field({
        type: "String",
        required: true,
        extensions: {
          protobufField: {
            name: "this_field_will_be_renamed",
            typeFullName: "string",
            options: { "[graphql.field]": { name: "thisFieldWasRenamed" } },
          },
        },
      }),
      oneofNotIgnoredField: t.field({
        type: TestPrefixPrefixedMessageInnerMessageInput$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "oneof_not_ignored_field",
            typeFullName: "testapis.extensions.PrefixedMessage.InnerMessage",
          },
        },
      }),
      skipResolver: t.field({
        type: "String",
        required: true,
        extensions: {
          protobufField: {
            name: "skip_resolver",
            typeFullName: "string",
            options: { "[graphql.field]": { skipResolver: true } },
          },
        },
      }),
      squashedMessages: t.field({
        type: [TestPrefixPrefixedMessageSquashedMessageInput$Ref],
        required: { list: false, items: true },
        extensions: {
          protobufField: {
            name: "squashed_messages",
            typeFullName: "testapis.extensions.PrefixedMessage.SquashedMessage",
          },
        },
      }),
      renamedMessage: t.field({
        type: TestPrefixRenamedMessageInput$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "renamed_message",
            typeFullName: "testapis.extensions.MessageWillRename",
          },
        },
      }),
      renamedEnum: t.field({
        type: TestPrefixRenamedEnum$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "renamed_enum",
            typeFullName: "testapis.extensions.EnumWillRename",
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.extensions.PrefixedMessage",
        name: "PrefixedMessage",
        package: "testapis.extensions",
      },
    },
  },
);

export function TestPrefixPrefixedMessageInput$toProto(
  input: TestPrefixPrefixedMessageInput$Shape | null | undefined,
): PrefixedMessage {
  return new PrefixedMessage({
    body: input?.body ?? undefined,
    prefixedEnum: input?.prefixedEnum ?? undefined,
    notIgnoredMessage: input?.notIgnoredMessage
      ? TestPrefixIgnoredMessageNotIgnoredInput$toProto(input.notIgnoredMessage)
      : undefined,
    squashedMessage: input?.squashedMessage
      ? TestPrefixPrefixedMessageSquashedMessageInput$toProto(
        input.squashedMessage,
      )
      : undefined,
    thisFieldWillBeRenamed: input?.thisFieldWasRenamed ?? undefined,
    skipResolver: input?.skipResolver ?? undefined,
    squashedMessages: input?.squashedMessages?.map((v) =>
      TestPrefixPrefixedMessageSquashedMessageInput$toProto(v)
    ),
    renamedMessage: input?.renamedMessage
      ? TestPrefixRenamedMessageInput$toProto(input.renamedMessage)
      : undefined,
    renamedEnum: input?.renamedEnum ?? undefined,
    partialIgnoreOneof: input?.oneofNotIgnoredField
      ? {
        case: "oneofNotIgnoredField",
        value: TestPrefixPrefixedMessageInnerMessageInput$toProto(
          input.oneofNotIgnoredField,
        ),
      }
      : undefined,
  });
}

export type TestPrefixRenamedMessageInput$Shape = {
  body: MessageWillRename["body"];
};

export const TestPrefixRenamedMessageInput$Ref: InputObjectRef<
  TestPrefixRenamedMessageInput$Shape
> = builder.inputRef<TestPrefixRenamedMessageInput$Shape>(
  "TestPrefixRenamedMessageInput",
).implement(
  {
    fields: (t) => ({
      body: t.field({
        type: "String",
        required: true,
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.extensions.MessageWillRename",
        name: "MessageWillRename",
        package: "testapis.extensions",
        options: { "[graphql.object_type]": { name: "RenamedMessage" } },
      },
    },
  },
);

export function TestPrefixRenamedMessageInput$toProto(
  input: TestPrefixRenamedMessageInput$Shape | null | undefined,
): MessageWillRename {
  return new MessageWillRename({
    body: input?.body ?? undefined,
  });
}

export type TestPrefixInterfaceMessageInput$Shape = {
  id: InterfaceMessage["id"];
};

export const TestPrefixInterfaceMessageInput$Ref: InputObjectRef<
  TestPrefixInterfaceMessageInput$Shape
> = builder.inputRef<TestPrefixInterfaceMessageInput$Shape>(
  "TestPrefixInterfaceMessageInput",
).implement(
  {
    fields: (t) => ({
      id: t.field({
        type: "Int64",
        required: true,
        extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.extensions.InterfaceMessage",
        name: "InterfaceMessage",
        package: "testapis.extensions",
        options: { "[graphql.object_type]": { interface: true } },
      },
    },
  },
);

export function TestPrefixInterfaceMessageInput$toProto(
  input: TestPrefixInterfaceMessageInput$Shape | null | undefined,
): InterfaceMessage {
  return new InterfaceMessage({
    id: input?.id ?? undefined,
  });
}

export type TestPrefixPrefixedMessageInnerMessageInput$Shape = {
  id: PrefixedMessage_InnerMessage["id"];
  body: PrefixedMessage_InnerMessage["body"];
};

export const TestPrefixPrefixedMessageInnerMessageInput$Ref: InputObjectRef<
  TestPrefixPrefixedMessageInnerMessageInput$Shape
> = builder.inputRef<TestPrefixPrefixedMessageInnerMessageInput$Shape>(
  "TestPrefixPrefixedMessageInnerMessageInput",
).implement(
  {
    fields: (t) => ({
      id: t.field({
        type: "Int64",
        required: true,
        extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
      }),
      body: t.field({
        type: "String",
        required: true,
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.extensions.PrefixedMessage.InnerMessage",
        name: "InnerMessage",
        package: "testapis.extensions",
      },
    },
  },
);

export function TestPrefixPrefixedMessageInnerMessageInput$toProto(
  input: TestPrefixPrefixedMessageInnerMessageInput$Shape | null | undefined,
): PrefixedMessage_InnerMessage {
  return new PrefixedMessage_InnerMessage({
    id: input?.id ?? undefined,
    body: input?.body ?? undefined,
  });
}

export type TestPrefixPrefixedMessageInnerMessage2Input$Shape = {
  id: PrefixedMessage_InnerMessage2["id"];
  body: PrefixedMessage_InnerMessage2["body"];
};

export const TestPrefixPrefixedMessageInnerMessage2Input$Ref: InputObjectRef<
  TestPrefixPrefixedMessageInnerMessage2Input$Shape
> = builder.inputRef<TestPrefixPrefixedMessageInnerMessage2Input$Shape>(
  "TestPrefixPrefixedMessageInnerMessage2Input",
).implement(
  {
    fields: (t) => ({
      id: t.field({
        type: "Int64",
        required: true,
        extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
      }),
      body: t.field({
        type: "String",
        required: true,
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.extensions.PrefixedMessage.InnerMessage2",
        name: "InnerMessage2",
        package: "testapis.extensions",
      },
    },
  },
);

export function TestPrefixPrefixedMessageInnerMessage2Input$toProto(
  input: TestPrefixPrefixedMessageInnerMessage2Input$Shape | null | undefined,
): PrefixedMessage_InnerMessage2 {
  return new PrefixedMessage_InnerMessage2({
    id: input?.id ?? undefined,
    body: input?.body ?? undefined,
  });
}

export type TestPrefixPrefixedMessageSquashedMessageInput$Shape = {
  oneofField?: TestPrefixPrefixedMessageInnerMessageInput$Shape | null;
  oneofField2?: TestPrefixPrefixedMessageInnerMessage2Input$Shape | null;
};

export const TestPrefixPrefixedMessageSquashedMessageInput$Ref: InputObjectRef<
  TestPrefixPrefixedMessageSquashedMessageInput$Shape
> = builder.inputRef<TestPrefixPrefixedMessageSquashedMessageInput$Shape>(
  "TestPrefixPrefixedMessageSquashedMessageInput",
).implement(
  {
    fields: (t) => ({
      oneofField: t.field({
        type: TestPrefixPrefixedMessageInnerMessageInput$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "oneof_field",
            typeFullName: "testapis.extensions.PrefixedMessage.InnerMessage",
          },
        },
      }),
      oneofField2: t.field({
        type: TestPrefixPrefixedMessageInnerMessage2Input$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "oneof_field_2",
            typeFullName: "testapis.extensions.PrefixedMessage.InnerMessage2",
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.extensions.PrefixedMessage.SquashedMessage",
        name: "SquashedMessage",
        package: "testapis.extensions",
        options: { "[graphql.object_type]": { squashUnion: true } },
      },
    },
  },
);

export function TestPrefixPrefixedMessageSquashedMessageInput$toProto(
  input: TestPrefixPrefixedMessageSquashedMessageInput$Shape | null | undefined,
): PrefixedMessage_SquashedMessage {
  return new PrefixedMessage_SquashedMessage({
    squashedMessage: input?.oneofField
      ? {
        case: "oneofField",
        value: TestPrefixPrefixedMessageInnerMessageInput$toProto(
          input.oneofField,
        ),
      }
      : input?.oneofField2
      ? {
        case: "oneofField2",
        value: TestPrefixPrefixedMessageInnerMessage2Input$toProto(
          input.oneofField2,
        ),
      }
      : undefined,
  });
}

export type TestPrefixIgnoredMessageNotIgnoredInput$Shape = {
  body: IgnoredMessage_NotIgnored["body"];
};

export const TestPrefixIgnoredMessageNotIgnoredInput$Ref: InputObjectRef<
  TestPrefixIgnoredMessageNotIgnoredInput$Shape
> = builder.inputRef<TestPrefixIgnoredMessageNotIgnoredInput$Shape>(
  "TestPrefixIgnoredMessageNotIgnoredInput",
).implement(
  {
    fields: (t) => ({
      body: t.field({
        type: "String",
        required: true,
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.extensions.IgnoredMessage.NotIgnored",
        name: "NotIgnored",
        package: "testapis.extensions",
      },
    },
  },
);

export function TestPrefixIgnoredMessageNotIgnoredInput$toProto(
  input: TestPrefixIgnoredMessageNotIgnoredInput$Shape | null | undefined,
): IgnoredMessage_NotIgnored {
  return new IgnoredMessage_NotIgnored({
    body: input?.body ?? undefined,
  });
}

export const TestPrefixInterfaceMessage$Ref = builder.interfaceRef<
  Pick<
    InterfaceMessage,
    "id"
  >
>("TestPrefixInterfaceMessage");
builder.interfaceType(TestPrefixInterfaceMessage$Ref, {
  name: "TestPrefixInterfaceMessage",
  fields: (t) => ({
    id: t.expose("id", {
      type: "Int64",
      nullable: false,
      extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.InterfaceMessage",
      name: "InterfaceMessage",
      package: "testapis.extensions",
      options: { "[graphql.object_type]": { interface: true } },
    },
  },
});

export const TestPrefixPrefixedMessageSquashedMessage$Ref = builder.unionType(
  "TestPrefixPrefixedMessageSquashedMessage",
  {
    types: [
      TestPrefixPrefixedMessageInnerMessage$Ref,
      TestPrefixPrefixedMessageInnerMessage2$Ref,
    ],
    extensions: {
      protobufOneof: {
        fullName: "testapis.extensions.PrefixedMessage.SquashedMessage",
        name: "SquashedMessage",
        package: "testapis.extensions",
        fields: [{
          name: "oneof_field",
          type: "testapis.extensions.PrefixedMessage.InnerMessage",
          options: { "[graphql.object_type]": { squashUnion: true } },
        }, {
          name: "oneof_field_2",
          type: "testapis.extensions.PrefixedMessage.InnerMessage2",
          options: { "[graphql.object_type]": { squashUnion: true } },
        }],
      },
    },
  },
);

export const TestPrefixPrefixedMessagePartialIgnoreOneof$Ref = builder
  .unionType("TestPrefixPrefixedMessagePartialIgnoreOneof", {
    types: [TestPrefixPrefixedMessageInnerMessage$Ref],
    extensions: {
      protobufOneof: {
        fullName: "testapis.extensions.PrefixedMessage.partial_ignore_oneof",
        name: "partial_ignore_oneof",
        messageName: "PrefixedMessage",
        package: "testapis.extensions",
        fields: [{
          name: "oneof_not_ignored_field",
          type: "testapis.extensions.PrefixedMessage.InnerMessage",
        }],
      },
    },
  });

export const TestPrefixPrefixedEnum$Ref: EnumRef<PrefixedEnum, PrefixedEnum> =
  builder.enumType("TestPrefixPrefixedEnum", {
    values: {
      PREFIXED_FOO: {
        value: 1,
        extensions: { protobufEnumValue: { name: "PREFIXED_FOO" } },
      },
      PREFIXED_BAR: {
        value: 2,
        extensions: { protobufEnumValue: { name: "PREFIXED_BAR" } },
      },
    } as const,
    extensions: {
      protobufEnum: {
        name: "PrefixedEnum",
        fullName: "testapis.extensions.PrefixedEnum",
        package: "testapis.extensions",
      },
    },
  });

export const TestPrefixRenamedEnum$Ref: EnumRef<
  EnumWillRename,
  EnumWillRename
> = builder.enumType("TestPrefixRenamedEnum", {
  values: {
    FOO: {
      value: 1,
      extensions: { protobufEnumValue: { name: "ENUM_WILL_RENAME_FOO" } },
    },
    BAR: {
      value: 2,
      extensions: { protobufEnumValue: { name: "ENUM_WILL_RENAME_BAR" } },
    },
  } as const,
  extensions: {
    protobufEnum: {
      name: "EnumWillRename",
      fullName: "testapis.extensions.EnumWillRename",
      package: "testapis.extensions",
      options: { "[graphql.enum_type]": { name: "RenamedEnum" } },
    },
  },
});

export const TestPrefixInterfaceMessageType$Ref: EnumRef<
  InterfaceMessage_Type,
  InterfaceMessage_Type
> = builder.enumType("TestPrefixInterfaceMessageType", {
  values: {
    INNER: { value: 1, extensions: { protobufEnumValue: { name: "INNER" } } },
    INNER2: { value: 2, extensions: { protobufEnumValue: { name: "INNER2" } } },
  } as const,
  extensions: {
    protobufEnum: {
      name: "Type",
      fullName: "testapis.extensions.InterfaceMessage.Type",
      package: "testapis.extensions",
    },
  },
});
",
    "name": "testapis/extensions/extensions.pb.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/extensions/ignored.proto

/* eslint-disable */

export {};
",
    "name": "testapis/extensions/ignored.pb.pothos.ts",
  },
]
`;

exports[`protobuf-es > 'testapis.extensions' > generates files by plugin 'with partial inputs' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/extensions/extensions.proto

/* eslint-disable */

import { EnumRef, InputObjectRef } from "@pothos/core";
import {
  EnumWillRename,
  IgnoredMessage_NotIgnored,
  InterfaceMessage,
  InterfaceMessage_Type,
  MessageOnlyOutput,
  MessageWillRename,
  PrefixedEnum,
  PrefixedMessage,
  PrefixedMessage_InnerMessage,
  PrefixedMessage_InnerMessage2,
  PrefixedMessage_SquashedMessage,
} from "@testapis/protobuf-es/testapis/extensions/extensions_pb";
import { builder } from "../../builder";

export const TestPrefixPrefixedMessage$Ref = builder.objectRef<PrefixedMessage>(
  "TestPrefixPrefixedMessage",
);
builder.objectType(TestPrefixPrefixedMessage$Ref, {
  name: "TestPrefixPrefixedMessage",
  fields: (t) => ({
    id: t.expose("id", {
      type: "Int64",
      nullable: false,
      description: "Output only.",
      extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
    }),
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
    prefixedEnum: t.field({
      type: TestPrefixPrefixedEnum$Ref,
      nullable: true,
      resolve: (source) => {
        if (source.prefixedEnum === PrefixedEnum.PREFIXED_ENUM_UNSPECIFIED) {
          return null;
        }

        if (source.prefixedEnum === PrefixedEnum.PREFIXED_IGNORED) {
          throw new Error("PREFIXED_IGNORED is ignored in GraphQL schema");
        }

        return source.prefixedEnum;
      },
      extensions: {
        protobufField: {
          name: "prefixed_enum",
          typeFullName: "testapis.extensions.PrefixedEnum",
        },
      },
    }),
    notIgnoredMessage: t.expose("notIgnoredMessage", {
      type: TestPrefixIgnoredMessageNotIgnored$Ref,
      nullable: true,
      extensions: {
        protobufField: {
          name: "not_ignored_message",
          typeFullName: "testapis.extensions.IgnoredMessage.NotIgnored",
        },
      },
    }),
    squashedMessage: t.field({
      type: TestPrefixPrefixedMessageSquashedMessage$Ref,
      nullable: true,
      resolve: (source) => {
        return source.squashedMessage?.squashedMessage.value;
      },
      extensions: {
        protobufField: {
          name: "squashed_message",
          typeFullName: "testapis.extensions.PrefixedMessage.SquashedMessage",
        },
      },
    }),
    thisFieldWasRenamed: t.expose("thisFieldWillBeRenamed", {
      type: "String",
      nullable: false,
      extensions: {
        protobufField: {
          name: "this_field_will_be_renamed",
          typeFullName: "string",
          options: { "[graphql.field]": { name: "thisFieldWasRenamed" } },
        },
      },
    }),
    skipResolver: t.expose("skipResolver", {
      type: "String",
      nullable: false,
      extensions: {
        protobufField: {
          name: "skip_resolver",
          typeFullName: "string",
          options: { "[graphql.field]": { skipResolver: true } },
        },
      },
    }),
    squashedMessages: t.field({
      type: [TestPrefixPrefixedMessageSquashedMessage$Ref],
      nullable: { list: true, items: false },
      resolve: (source) => {
        return source.squashedMessages.map((item) => {
          const value = item.squashedMessage.value;
          if (value == null) {
            throw new Error("squashedMessages should not be null");
          }
          return value;
        });
      },
      extensions: {
        protobufField: {
          name: "squashed_messages",
          typeFullName: "testapis.extensions.PrefixedMessage.SquashedMessage",
        },
      },
    }),
    renamedMessage: t.expose("renamedMessage", {
      type: TestPrefixRenamedMessage$Ref,
      nullable: true,
      extensions: {
        protobufField: {
          name: "renamed_message",
          typeFullName: "testapis.extensions.MessageWillRename",
        },
      },
    }),
    renamedEnum: t.field({
      type: TestPrefixRenamedEnum$Ref,
      nullable: true,
      resolve: (source) => {
        if (source.renamedEnum === EnumWillRename.UNSPECIFIED) {
          return null;
        }

        return source.renamedEnum;
      },
      extensions: {
        protobufField: {
          name: "renamed_enum",
          typeFullName: "testapis.extensions.EnumWillRename",
        },
      },
    }),
    partialIgnoreOneof: t.field({
      type: TestPrefixPrefixedMessagePartialIgnoreOneof$Ref,
      nullable: true,
      resolve: (source) => {
        return source.partialIgnoreOneof.value;
      },
      extensions: { protobufField: { name: "partial_ignore_oneof" } },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof PrefixedMessage;
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.PrefixedMessage",
      name: "PrefixedMessage",
      package: "testapis.extensions",
    },
  },
});

export const TestPrefixRenamedMessage$Ref = builder.objectRef<
  MessageWillRename
>("TestPrefixRenamedMessage");
builder.objectType(TestPrefixRenamedMessage$Ref, {
  name: "TestPrefixRenamedMessage",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof MessageWillRename;
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.MessageWillRename",
      name: "MessageWillRename",
      package: "testapis.extensions",
      options: { "[graphql.object_type]": { name: "RenamedMessage" } },
    },
  },
});

export const TestPrefixMessageOnlyOutput$Ref = builder.objectRef<
  MessageOnlyOutput
>("TestPrefixMessageOnlyOutput");
builder.objectType(TestPrefixMessageOnlyOutput$Ref, {
  name: "TestPrefixMessageOnlyOutput",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof MessageOnlyOutput;
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.MessageOnlyOutput",
      name: "MessageOnlyOutput",
      package: "testapis.extensions",
      options: { "[graphql.input_type]": { ignore: true } },
    },
  },
});

export const TestPrefixPrefixedMessageInnerMessage$Ref = builder.objectRef<
  PrefixedMessage_InnerMessage
>("TestPrefixPrefixedMessageInnerMessage");
builder.objectType(TestPrefixPrefixedMessageInnerMessage$Ref, {
  name: "TestPrefixPrefixedMessageInnerMessage",
  fields: (t) => ({
    id: t.expose("id", {
      type: "Int64",
      nullable: false,
      extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
    }),
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof PrefixedMessage_InnerMessage;
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.PrefixedMessage.InnerMessage",
      name: "InnerMessage",
      package: "testapis.extensions",
    },
  },
});

export const TestPrefixPrefixedMessageInnerMessage2$Ref = builder.objectRef<
  PrefixedMessage_InnerMessage2
>("TestPrefixPrefixedMessageInnerMessage2");
builder.objectType(TestPrefixPrefixedMessageInnerMessage2$Ref, {
  name: "TestPrefixPrefixedMessageInnerMessage2",
  fields: (t) => ({
    id: t.expose("id", {
      type: "Int64",
      nullable: false,
      extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
    }),
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof PrefixedMessage_InnerMessage2;
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.PrefixedMessage.InnerMessage2",
      name: "InnerMessage2",
      package: "testapis.extensions",
    },
  },
});

export const TestPrefixIgnoredMessageNotIgnored$Ref = builder.objectRef<
  IgnoredMessage_NotIgnored
>("TestPrefixIgnoredMessageNotIgnored");
builder.objectType(TestPrefixIgnoredMessageNotIgnored$Ref, {
  name: "TestPrefixIgnoredMessageNotIgnored",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof IgnoredMessage_NotIgnored;
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.IgnoredMessage.NotIgnored",
      name: "NotIgnored",
      package: "testapis.extensions",
    },
  },
});

export type TestPrefixPrefixedMessageInput$Shape = {
  body: PrefixedMessage["body"];
  prefixedEnum?: PrefixedMessage["prefixedEnum"] | null;
  notIgnoredMessage?: TestPrefixIgnoredMessageNotIgnoredInput$Shape | null;
  squashedMessage?: TestPrefixPrefixedMessageSquashedMessageInput$Shape | null;
  thisFieldWasRenamed: PrefixedMessage["thisFieldWillBeRenamed"];
  oneofNotIgnoredField?:
    | TestPrefixPrefixedMessageInnerMessageInput$Shape
    | null;
  skipResolver: PrefixedMessage["skipResolver"];
  squashedMessages?:
    | Array<TestPrefixPrefixedMessageSquashedMessageInput$Shape>
    | null;
  renamedMessage?: TestPrefixRenamedMessageInput$Shape | null;
  renamedEnum?: PrefixedMessage["renamedEnum"] | null;
};

export const TestPrefixPrefixedMessageInput$Ref: InputObjectRef<
  TestPrefixPrefixedMessageInput$Shape
> = builder.inputRef<TestPrefixPrefixedMessageInput$Shape>(
  "TestPrefixPrefixedMessageInput",
).implement(
  {
    fields: (t) => ({
      body: t.field({
        type: "String",
        required: true,
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
      prefixedEnum: t.field({
        type: TestPrefixPrefixedEnum$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "prefixed_enum",
            typeFullName: "testapis.extensions.PrefixedEnum",
          },
        },
      }),
      notIgnoredMessage: t.field({
        type: TestPrefixIgnoredMessageNotIgnoredInput$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "not_ignored_message",
            typeFullName: "testapis.extensions.IgnoredMessage.NotIgnored",
          },
        },
      }),
      squashedMessage: t.field({
        type: TestPrefixPrefixedMessageSquashedMessageInput$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "squashed_message",
            typeFullName: "testapis.extensions.PrefixedMessage.SquashedMessage",
          },
        },
      }),
      thisFieldWasRenamed: t.field({
        type: "String",
        required: true,
        extensions: {
          protobufField: {
            name: "this_field_will_be_renamed",
            typeFullName: "string",
            options: { "[graphql.field]": { name: "thisFieldWasRenamed" } },
          },
        },
      }),
      oneofNotIgnoredField: t.field({
        type: TestPrefixPrefixedMessageInnerMessageInput$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "oneof_not_ignored_field",
            typeFullName: "testapis.extensions.PrefixedMessage.InnerMessage",
          },
        },
      }),
      skipResolver: t.field({
        type: "String",
        required: true,
        extensions: {
          protobufField: {
            name: "skip_resolver",
            typeFullName: "string",
            options: { "[graphql.field]": { skipResolver: true } },
          },
        },
      }),
      squashedMessages: t.field({
        type: [TestPrefixPrefixedMessageSquashedMessageInput$Ref],
        required: { list: false, items: true },
        extensions: {
          protobufField: {
            name: "squashed_messages",
            typeFullName: "testapis.extensions.PrefixedMessage.SquashedMessage",
          },
        },
      }),
      renamedMessage: t.field({
        type: TestPrefixRenamedMessageInput$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "renamed_message",
            typeFullName: "testapis.extensions.MessageWillRename",
          },
        },
      }),
      renamedEnum: t.field({
        type: TestPrefixRenamedEnum$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "renamed_enum",
            typeFullName: "testapis.extensions.EnumWillRename",
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.extensions.PrefixedMessage",
        name: "PrefixedMessage",
        package: "testapis.extensions",
      },
    },
  },
);

export function TestPrefixPrefixedMessageInput$toProto(
  input: TestPrefixPrefixedMessageInput$Shape | null | undefined,
): PrefixedMessage {
  return new PrefixedMessage({
    body: input?.body ?? undefined,
    prefixedEnum: input?.prefixedEnum ?? undefined,
    notIgnoredMessage: input?.notIgnoredMessage
      ? TestPrefixIgnoredMessageNotIgnoredInput$toProto(input.notIgnoredMessage)
      : undefined,
    squashedMessage: input?.squashedMessage
      ? TestPrefixPrefixedMessageSquashedMessageInput$toProto(
        input.squashedMessage,
      )
      : undefined,
    thisFieldWillBeRenamed: input?.thisFieldWasRenamed ?? undefined,
    skipResolver: input?.skipResolver ?? undefined,
    squashedMessages: input?.squashedMessages?.map((v) =>
      TestPrefixPrefixedMessageSquashedMessageInput$toProto(v)
    ),
    renamedMessage: input?.renamedMessage
      ? TestPrefixRenamedMessageInput$toProto(input.renamedMessage)
      : undefined,
    renamedEnum: input?.renamedEnum ?? undefined,
    partialIgnoreOneof: input?.oneofNotIgnoredField
      ? {
        case: "oneofNotIgnoredField",
        value: TestPrefixPrefixedMessageInnerMessageInput$toProto(
          input.oneofNotIgnoredField,
        ),
      }
      : undefined,
  });
}

export type TestPrefixPrefixedMessagePartialInput$Shape = {
  body?: PrefixedMessage["body"] | null;
  prefixedEnum?: PrefixedMessage["prefixedEnum"] | null;
  notIgnoredMessage?:
    | TestPrefixIgnoredMessageNotIgnoredPartialInput$Shape
    | null;
  squashedMessage?:
    | TestPrefixPrefixedMessageSquashedMessagePartialInput$Shape
    | null;
  thisFieldWasRenamed?: PrefixedMessage["thisFieldWillBeRenamed"] | null;
  oneofNotIgnoredField?:
    | TestPrefixPrefixedMessageInnerMessagePartialInput$Shape
    | null;
  skipResolver?: PrefixedMessage["skipResolver"] | null;
  squashedMessages?:
    | Array<TestPrefixPrefixedMessageSquashedMessagePartialInput$Shape>
    | null;
  renamedMessage?: TestPrefixRenamedMessagePartialInput$Shape | null;
  renamedEnum?: PrefixedMessage["renamedEnum"] | null;
};

export const TestPrefixPrefixedMessagePartialInput$Ref: InputObjectRef<
  TestPrefixPrefixedMessagePartialInput$Shape
> = builder.inputRef<TestPrefixPrefixedMessagePartialInput$Shape>(
  "TestPrefixPrefixedMessagePartialInput",
).implement(
  {
    fields: (t) => ({
      body: t.field({
        type: "String",
        required: false,
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
      prefixedEnum: t.field({
        type: TestPrefixPrefixedEnum$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "prefixed_enum",
            typeFullName: "testapis.extensions.PrefixedEnum",
          },
        },
      }),
      notIgnoredMessage: t.field({
        type: TestPrefixIgnoredMessageNotIgnoredPartialInput$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "not_ignored_message",
            typeFullName: "testapis.extensions.IgnoredMessage.NotIgnored",
          },
        },
      }),
      squashedMessage: t.field({
        type: TestPrefixPrefixedMessageSquashedMessagePartialInput$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "squashed_message",
            typeFullName: "testapis.extensions.PrefixedMessage.SquashedMessage",
          },
        },
      }),
      thisFieldWasRenamed: t.field({
        type: "String",
        required: false,
        extensions: {
          protobufField: {
            name: "this_field_will_be_renamed",
            typeFullName: "string",
            options: { "[graphql.field]": { name: "thisFieldWasRenamed" } },
          },
        },
      }),
      oneofNotIgnoredField: t.field({
        type: TestPrefixPrefixedMessageInnerMessagePartialInput$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "oneof_not_ignored_field",
            typeFullName: "testapis.extensions.PrefixedMessage.InnerMessage",
          },
        },
      }),
      skipResolver: t.field({
        type: "String",
        required: false,
        extensions: {
          protobufField: {
            name: "skip_resolver",
            typeFullName: "string",
            options: { "[graphql.field]": { skipResolver: true } },
          },
        },
      }),
      squashedMessages: t.field({
        type: [TestPrefixPrefixedMessageSquashedMessagePartialInput$Ref],
        required: { list: false, items: true },
        extensions: {
          protobufField: {
            name: "squashed_messages",
            typeFullName: "testapis.extensions.PrefixedMessage.SquashedMessage",
          },
        },
      }),
      renamedMessage: t.field({
        type: TestPrefixRenamedMessagePartialInput$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "renamed_message",
            typeFullName: "testapis.extensions.MessageWillRename",
          },
        },
      }),
      renamedEnum: t.field({
        type: TestPrefixRenamedEnum$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "renamed_enum",
            typeFullName: "testapis.extensions.EnumWillRename",
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.extensions.PrefixedMessage",
        name: "PrefixedMessage",
        package: "testapis.extensions",
      },
    },
  },
);

export function TestPrefixPrefixedMessagePartialInput$toProto(
  input: TestPrefixPrefixedMessagePartialInput$Shape | null | undefined,
): PrefixedMessage {
  return new PrefixedMessage({
    body: input?.body ?? undefined,
    prefixedEnum: input?.prefixedEnum ?? undefined,
    notIgnoredMessage: input?.notIgnoredMessage
      ? TestPrefixIgnoredMessageNotIgnoredPartialInput$toProto(
        input.notIgnoredMessage,
      )
      : undefined,
    squashedMessage: input?.squashedMessage
      ? TestPrefixPrefixedMessageSquashedMessagePartialInput$toProto(
        input.squashedMessage,
      )
      : undefined,
    thisFieldWillBeRenamed: input?.thisFieldWasRenamed ?? undefined,
    skipResolver: input?.skipResolver ?? undefined,
    squashedMessages: input?.squashedMessages?.map((v) =>
      TestPrefixPrefixedMessageSquashedMessagePartialInput$toProto(v)
    ),
    renamedMessage: input?.renamedMessage
      ? TestPrefixRenamedMessagePartialInput$toProto(input.renamedMessage)
      : undefined,
    renamedEnum: input?.renamedEnum ?? undefined,
    partialIgnoreOneof: input?.oneofNotIgnoredField
      ? {
        case: "oneofNotIgnoredField",
        value: TestPrefixPrefixedMessageInnerMessagePartialInput$toProto(
          input.oneofNotIgnoredField,
        ),
      }
      : undefined,
  });
}

export type TestPrefixRenamedMessageInput$Shape = {
  body: MessageWillRename["body"];
};

export const TestPrefixRenamedMessageInput$Ref: InputObjectRef<
  TestPrefixRenamedMessageInput$Shape
> = builder.inputRef<TestPrefixRenamedMessageInput$Shape>(
  "TestPrefixRenamedMessageInput",
).implement(
  {
    fields: (t) => ({
      body: t.field({
        type: "String",
        required: true,
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.extensions.MessageWillRename",
        name: "MessageWillRename",
        package: "testapis.extensions",
        options: { "[graphql.object_type]": { name: "RenamedMessage" } },
      },
    },
  },
);

export function TestPrefixRenamedMessageInput$toProto(
  input: TestPrefixRenamedMessageInput$Shape | null | undefined,
): MessageWillRename {
  return new MessageWillRename({
    body: input?.body ?? undefined,
  });
}

export type TestPrefixRenamedMessagePartialInput$Shape = {
  body?: MessageWillRename["body"] | null;
};

export const TestPrefixRenamedMessagePartialInput$Ref: InputObjectRef<
  TestPrefixRenamedMessagePartialInput$Shape
> = builder.inputRef<TestPrefixRenamedMessagePartialInput$Shape>(
  "TestPrefixRenamedMessagePartialInput",
).implement(
  {
    fields: (t) => ({
      body: t.field({
        type: "String",
        required: false,
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.extensions.MessageWillRename",
        name: "MessageWillRename",
        package: "testapis.extensions",
        options: { "[graphql.object_type]": { name: "RenamedMessage" } },
      },
    },
  },
);

export function TestPrefixRenamedMessagePartialInput$toProto(
  input: TestPrefixRenamedMessagePartialInput$Shape | null | undefined,
): MessageWillRename {
  return new MessageWillRename({
    body: input?.body ?? undefined,
  });
}

export type TestPrefixInterfaceMessageInput$Shape = {
  id: InterfaceMessage["id"];
};

export const TestPrefixInterfaceMessageInput$Ref: InputObjectRef<
  TestPrefixInterfaceMessageInput$Shape
> = builder.inputRef<TestPrefixInterfaceMessageInput$Shape>(
  "TestPrefixInterfaceMessageInput",
).implement(
  {
    fields: (t) => ({
      id: t.field({
        type: "Int64",
        required: true,
        extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.extensions.InterfaceMessage",
        name: "InterfaceMessage",
        package: "testapis.extensions",
        options: { "[graphql.object_type]": { interface: true } },
      },
    },
  },
);

export function TestPrefixInterfaceMessageInput$toProto(
  input: TestPrefixInterfaceMessageInput$Shape | null | undefined,
): InterfaceMessage {
  return new InterfaceMessage({
    id: input?.id ?? undefined,
  });
}

export type TestPrefixInterfaceMessagePartialInput$Shape = {
  id?: InterfaceMessage["id"] | null;
};

export const TestPrefixInterfaceMessagePartialInput$Ref: InputObjectRef<
  TestPrefixInterfaceMessagePartialInput$Shape
> = builder.inputRef<TestPrefixInterfaceMessagePartialInput$Shape>(
  "TestPrefixInterfaceMessagePartialInput",
).implement(
  {
    fields: (t) => ({
      id: t.field({
        type: "Int64",
        required: false,
        extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.extensions.InterfaceMessage",
        name: "InterfaceMessage",
        package: "testapis.extensions",
        options: { "[graphql.object_type]": { interface: true } },
      },
    },
  },
);

export function TestPrefixInterfaceMessagePartialInput$toProto(
  input: TestPrefixInterfaceMessagePartialInput$Shape | null | undefined,
): InterfaceMessage {
  return new InterfaceMessage({
    id: input?.id ?? undefined,
  });
}

export type TestPrefixPrefixedMessageInnerMessageInput$Shape = {
  id: PrefixedMessage_InnerMessage["id"];
  body: PrefixedMessage_InnerMessage["body"];
};

export const TestPrefixPrefixedMessageInnerMessageInput$Ref: InputObjectRef<
  TestPrefixPrefixedMessageInnerMessageInput$Shape
> = builder.inputRef<TestPrefixPrefixedMessageInnerMessageInput$Shape>(
  "TestPrefixPrefixedMessageInnerMessageInput",
).implement(
  {
    fields: (t) => ({
      id: t.field({
        type: "Int64",
        required: true,
        extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
      }),
      body: t.field({
        type: "String",
        required: true,
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.extensions.PrefixedMessage.InnerMessage",
        name: "InnerMessage",
        package: "testapis.extensions",
      },
    },
  },
);

export function TestPrefixPrefixedMessageInnerMessageInput$toProto(
  input: TestPrefixPrefixedMessageInnerMessageInput$Shape | null | undefined,
): PrefixedMessage_InnerMessage {
  return new PrefixedMessage_InnerMessage({
    id: input?.id ?? undefined,
    body: input?.body ?? undefined,
  });
}

export type TestPrefixPrefixedMessageInnerMessagePartialInput$Shape = {
  id?: PrefixedMessage_InnerMessage["id"] | null;
  body?: PrefixedMessage_InnerMessage["body"] | null;
};

export const TestPrefixPrefixedMessageInnerMessagePartialInput$Ref:
  InputObjectRef<TestPrefixPrefixedMessageInnerMessagePartialInput$Shape> =
    builder.inputRef<TestPrefixPrefixedMessageInnerMessagePartialInput$Shape>(
      "TestPrefixPrefixedMessageInnerMessagePartialInput",
    ).implement(
      {
        fields: (t) => ({
          id: t.field({
            type: "Int64",
            required: false,
            extensions: {
              protobufField: { name: "id", typeFullName: "uint64" },
            },
          }),
          body: t.field({
            type: "String",
            required: false,
            extensions: {
              protobufField: { name: "body", typeFullName: "string" },
            },
          }),
        }),
        extensions: {
          protobufMessage: {
            fullName: "testapis.extensions.PrefixedMessage.InnerMessage",
            name: "InnerMessage",
            package: "testapis.extensions",
          },
        },
      },
    );

export function TestPrefixPrefixedMessageInnerMessagePartialInput$toProto(
  input:
    | TestPrefixPrefixedMessageInnerMessagePartialInput$Shape
    | null
    | undefined,
): PrefixedMessage_InnerMessage {
  return new PrefixedMessage_InnerMessage({
    id: input?.id ?? undefined,
    body: input?.body ?? undefined,
  });
}

export type TestPrefixPrefixedMessageInnerMessage2Input$Shape = {
  id: PrefixedMessage_InnerMessage2["id"];
  body: PrefixedMessage_InnerMessage2["body"];
};

export const TestPrefixPrefixedMessageInnerMessage2Input$Ref: InputObjectRef<
  TestPrefixPrefixedMessageInnerMessage2Input$Shape
> = builder.inputRef<TestPrefixPrefixedMessageInnerMessage2Input$Shape>(
  "TestPrefixPrefixedMessageInnerMessage2Input",
).implement(
  {
    fields: (t) => ({
      id: t.field({
        type: "Int64",
        required: true,
        extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
      }),
      body: t.field({
        type: "String",
        required: true,
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.extensions.PrefixedMessage.InnerMessage2",
        name: "InnerMessage2",
        package: "testapis.extensions",
      },
    },
  },
);

export function TestPrefixPrefixedMessageInnerMessage2Input$toProto(
  input: TestPrefixPrefixedMessageInnerMessage2Input$Shape | null | undefined,
): PrefixedMessage_InnerMessage2 {
  return new PrefixedMessage_InnerMessage2({
    id: input?.id ?? undefined,
    body: input?.body ?? undefined,
  });
}

export type TestPrefixPrefixedMessageInnerMessage2PartialInput$Shape = {
  id?: PrefixedMessage_InnerMessage2["id"] | null;
  body?: PrefixedMessage_InnerMessage2["body"] | null;
};

export const TestPrefixPrefixedMessageInnerMessage2PartialInput$Ref:
  InputObjectRef<TestPrefixPrefixedMessageInnerMessage2PartialInput$Shape> =
    builder.inputRef<TestPrefixPrefixedMessageInnerMessage2PartialInput$Shape>(
      "TestPrefixPrefixedMessageInnerMessage2PartialInput",
    ).implement(
      {
        fields: (t) => ({
          id: t.field({
            type: "Int64",
            required: false,
            extensions: {
              protobufField: { name: "id", typeFullName: "uint64" },
            },
          }),
          body: t.field({
            type: "String",
            required: false,
            extensions: {
              protobufField: { name: "body", typeFullName: "string" },
            },
          }),
        }),
        extensions: {
          protobufMessage: {
            fullName: "testapis.extensions.PrefixedMessage.InnerMessage2",
            name: "InnerMessage2",
            package: "testapis.extensions",
          },
        },
      },
    );

export function TestPrefixPrefixedMessageInnerMessage2PartialInput$toProto(
  input:
    | TestPrefixPrefixedMessageInnerMessage2PartialInput$Shape
    | null
    | undefined,
): PrefixedMessage_InnerMessage2 {
  return new PrefixedMessage_InnerMessage2({
    id: input?.id ?? undefined,
    body: input?.body ?? undefined,
  });
}

export type TestPrefixPrefixedMessageSquashedMessageInput$Shape = {
  oneofField?: TestPrefixPrefixedMessageInnerMessageInput$Shape | null;
  oneofField2?: TestPrefixPrefixedMessageInnerMessage2Input$Shape | null;
};

export const TestPrefixPrefixedMessageSquashedMessageInput$Ref: InputObjectRef<
  TestPrefixPrefixedMessageSquashedMessageInput$Shape
> = builder.inputRef<TestPrefixPrefixedMessageSquashedMessageInput$Shape>(
  "TestPrefixPrefixedMessageSquashedMessageInput",
).implement(
  {
    fields: (t) => ({
      oneofField: t.field({
        type: TestPrefixPrefixedMessageInnerMessageInput$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "oneof_field",
            typeFullName: "testapis.extensions.PrefixedMessage.InnerMessage",
          },
        },
      }),
      oneofField2: t.field({
        type: TestPrefixPrefixedMessageInnerMessage2Input$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "oneof_field_2",
            typeFullName: "testapis.extensions.PrefixedMessage.InnerMessage2",
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.extensions.PrefixedMessage.SquashedMessage",
        name: "SquashedMessage",
        package: "testapis.extensions",
        options: { "[graphql.object_type]": { squashUnion: true } },
      },
    },
  },
);

export function TestPrefixPrefixedMessageSquashedMessageInput$toProto(
  input: TestPrefixPrefixedMessageSquashedMessageInput$Shape | null | undefined,
): PrefixedMessage_SquashedMessage {
  return new PrefixedMessage_SquashedMessage({
    squashedMessage: input?.oneofField
      ? {
        case: "oneofField",
        value: TestPrefixPrefixedMessageInnerMessageInput$toProto(
          input.oneofField,
        ),
      }
      : input?.oneofField2
      ? {
        case: "oneofField2",
        value: TestPrefixPrefixedMessageInnerMessage2Input$toProto(
          input.oneofField2,
        ),
      }
      : undefined,
  });
}

export type TestPrefixPrefixedMessageSquashedMessagePartialInput$Shape = {
  oneofField?: TestPrefixPrefixedMessageInnerMessagePartialInput$Shape | null;
  oneofField2?: TestPrefixPrefixedMessageInnerMessage2PartialInput$Shape | null;
};

export const TestPrefixPrefixedMessageSquashedMessagePartialInput$Ref:
  InputObjectRef<TestPrefixPrefixedMessageSquashedMessagePartialInput$Shape> =
    builder.inputRef<
      TestPrefixPrefixedMessageSquashedMessagePartialInput$Shape
    >("TestPrefixPrefixedMessageSquashedMessagePartialInput").implement(
      {
        fields: (t) => ({
          oneofField: t.field({
            type: TestPrefixPrefixedMessageInnerMessagePartialInput$Ref,
            required: false,
            extensions: {
              protobufField: {
                name: "oneof_field",
                typeFullName:
                  "testapis.extensions.PrefixedMessage.InnerMessage",
              },
            },
          }),
          oneofField2: t.field({
            type: TestPrefixPrefixedMessageInnerMessage2PartialInput$Ref,
            required: false,
            extensions: {
              protobufField: {
                name: "oneof_field_2",
                typeFullName:
                  "testapis.extensions.PrefixedMessage.InnerMessage2",
              },
            },
          }),
        }),
        extensions: {
          protobufMessage: {
            fullName: "testapis.extensions.PrefixedMessage.SquashedMessage",
            name: "SquashedMessage",
            package: "testapis.extensions",
            options: { "[graphql.object_type]": { squashUnion: true } },
          },
        },
      },
    );

export function TestPrefixPrefixedMessageSquashedMessagePartialInput$toProto(
  input:
    | TestPrefixPrefixedMessageSquashedMessagePartialInput$Shape
    | null
    | undefined,
): PrefixedMessage_SquashedMessage {
  return new PrefixedMessage_SquashedMessage({
    squashedMessage: input?.oneofField
      ? {
        case: "oneofField",
        value: TestPrefixPrefixedMessageInnerMessagePartialInput$toProto(
          input.oneofField,
        ),
      }
      : input?.oneofField2
      ? {
        case: "oneofField2",
        value: TestPrefixPrefixedMessageInnerMessage2PartialInput$toProto(
          input.oneofField2,
        ),
      }
      : undefined,
  });
}

export type TestPrefixIgnoredMessageNotIgnoredInput$Shape = {
  body: IgnoredMessage_NotIgnored["body"];
};

export const TestPrefixIgnoredMessageNotIgnoredInput$Ref: InputObjectRef<
  TestPrefixIgnoredMessageNotIgnoredInput$Shape
> = builder.inputRef<TestPrefixIgnoredMessageNotIgnoredInput$Shape>(
  "TestPrefixIgnoredMessageNotIgnoredInput",
).implement(
  {
    fields: (t) => ({
      body: t.field({
        type: "String",
        required: true,
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.extensions.IgnoredMessage.NotIgnored",
        name: "NotIgnored",
        package: "testapis.extensions",
      },
    },
  },
);

export function TestPrefixIgnoredMessageNotIgnoredInput$toProto(
  input: TestPrefixIgnoredMessageNotIgnoredInput$Shape | null | undefined,
): IgnoredMessage_NotIgnored {
  return new IgnoredMessage_NotIgnored({
    body: input?.body ?? undefined,
  });
}

export type TestPrefixIgnoredMessageNotIgnoredPartialInput$Shape = {
  body?: IgnoredMessage_NotIgnored["body"] | null;
};

export const TestPrefixIgnoredMessageNotIgnoredPartialInput$Ref: InputObjectRef<
  TestPrefixIgnoredMessageNotIgnoredPartialInput$Shape
> = builder.inputRef<TestPrefixIgnoredMessageNotIgnoredPartialInput$Shape>(
  "TestPrefixIgnoredMessageNotIgnoredPartialInput",
).implement(
  {
    fields: (t) => ({
      body: t.field({
        type: "String",
        required: false,
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.extensions.IgnoredMessage.NotIgnored",
        name: "NotIgnored",
        package: "testapis.extensions",
      },
    },
  },
);

export function TestPrefixIgnoredMessageNotIgnoredPartialInput$toProto(
  input:
    | TestPrefixIgnoredMessageNotIgnoredPartialInput$Shape
    | null
    | undefined,
): IgnoredMessage_NotIgnored {
  return new IgnoredMessage_NotIgnored({
    body: input?.body ?? undefined,
  });
}

export const TestPrefixInterfaceMessage$Ref = builder.interfaceRef<
  Pick<
    InterfaceMessage,
    "id"
  >
>("TestPrefixInterfaceMessage");
builder.interfaceType(TestPrefixInterfaceMessage$Ref, {
  name: "TestPrefixInterfaceMessage",
  fields: (t) => ({
    id: t.expose("id", {
      type: "Int64",
      nullable: false,
      extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.InterfaceMessage",
      name: "InterfaceMessage",
      package: "testapis.extensions",
      options: { "[graphql.object_type]": { interface: true } },
    },
  },
});

export const TestPrefixPrefixedMessageSquashedMessage$Ref = builder.unionType(
  "TestPrefixPrefixedMessageSquashedMessage",
  {
    types: [
      TestPrefixPrefixedMessageInnerMessage$Ref,
      TestPrefixPrefixedMessageInnerMessage2$Ref,
    ],
    extensions: {
      protobufOneof: {
        fullName: "testapis.extensions.PrefixedMessage.SquashedMessage",
        name: "SquashedMessage",
        package: "testapis.extensions",
        fields: [{
          name: "oneof_field",
          type: "testapis.extensions.PrefixedMessage.InnerMessage",
          options: { "[graphql.object_type]": { squashUnion: true } },
        }, {
          name: "oneof_field_2",
          type: "testapis.extensions.PrefixedMessage.InnerMessage2",
          options: { "[graphql.object_type]": { squashUnion: true } },
        }],
      },
    },
  },
);

export const TestPrefixPrefixedMessagePartialIgnoreOneof$Ref = builder
  .unionType("TestPrefixPrefixedMessagePartialIgnoreOneof", {
    types: [TestPrefixPrefixedMessageInnerMessage$Ref],
    extensions: {
      protobufOneof: {
        fullName: "testapis.extensions.PrefixedMessage.partial_ignore_oneof",
        name: "partial_ignore_oneof",
        messageName: "PrefixedMessage",
        package: "testapis.extensions",
        fields: [{
          name: "oneof_not_ignored_field",
          type: "testapis.extensions.PrefixedMessage.InnerMessage",
        }],
      },
    },
  });

export const TestPrefixPrefixedEnum$Ref: EnumRef<PrefixedEnum, PrefixedEnum> =
  builder.enumType("TestPrefixPrefixedEnum", {
    values: {
      PREFIXED_FOO: {
        value: 1,
        extensions: { protobufEnumValue: { name: "PREFIXED_FOO" } },
      },
      PREFIXED_BAR: {
        value: 2,
        extensions: { protobufEnumValue: { name: "PREFIXED_BAR" } },
      },
    } as const,
    extensions: {
      protobufEnum: {
        name: "PrefixedEnum",
        fullName: "testapis.extensions.PrefixedEnum",
        package: "testapis.extensions",
      },
    },
  });

export const TestPrefixRenamedEnum$Ref: EnumRef<
  EnumWillRename,
  EnumWillRename
> = builder.enumType("TestPrefixRenamedEnum", {
  values: {
    FOO: {
      value: 1,
      extensions: { protobufEnumValue: { name: "ENUM_WILL_RENAME_FOO" } },
    },
    BAR: {
      value: 2,
      extensions: { protobufEnumValue: { name: "ENUM_WILL_RENAME_BAR" } },
    },
  } as const,
  extensions: {
    protobufEnum: {
      name: "EnumWillRename",
      fullName: "testapis.extensions.EnumWillRename",
      package: "testapis.extensions",
      options: { "[graphql.enum_type]": { name: "RenamedEnum" } },
    },
  },
});

export const TestPrefixInterfaceMessageType$Ref: EnumRef<
  InterfaceMessage_Type,
  InterfaceMessage_Type
> = builder.enumType("TestPrefixInterfaceMessageType", {
  values: {
    INNER: { value: 1, extensions: { protobufEnumValue: { name: "INNER" } } },
    INNER2: { value: 2, extensions: { protobufEnumValue: { name: "INNER2" } } },
  } as const,
  extensions: {
    protobufEnum: {
      name: "Type",
      fullName: "testapis.extensions.InterfaceMessage.Type",
      package: "testapis.extensions",
    },
  },
});
",
    "name": "testapis/extensions/extensions.pb.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/extensions/ignored.proto

/* eslint-disable */

export {};
",
    "name": "testapis/extensions/ignored.pb.pothos.ts",
  },
]
`;

exports[`protobuf-es > 'testapis.extensions' > generates files by plugin 'without import prefix' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/extensions/extensions.proto

/* eslint-disable */

import { EnumRef, InputObjectRef } from "@pothos/core";
import { builder } from "../../builder";
import {
  EnumWillRename,
  IgnoredMessage_NotIgnored,
  InterfaceMessage,
  InterfaceMessage_Type,
  MessageOnlyOutput,
  MessageWillRename,
  PrefixedEnum,
  PrefixedMessage,
  PrefixedMessage_InnerMessage,
  PrefixedMessage_InnerMessage2,
  PrefixedMessage_SquashedMessage,
} from "./testapis/extensions/extensions_pb";

export const TestPrefixPrefixedMessage$Ref = builder.objectRef<PrefixedMessage>(
  "TestPrefixPrefixedMessage",
);
builder.objectType(TestPrefixPrefixedMessage$Ref, {
  name: "TestPrefixPrefixedMessage",
  fields: (t) => ({
    id: t.expose("id", {
      type: "Int64",
      nullable: false,
      description: "Output only.",
      extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
    }),
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
    prefixedEnum: t.field({
      type: TestPrefixPrefixedEnum$Ref,
      nullable: true,
      resolve: (source) => {
        if (source.prefixedEnum === PrefixedEnum.PREFIXED_ENUM_UNSPECIFIED) {
          return null;
        }

        if (source.prefixedEnum === PrefixedEnum.PREFIXED_IGNORED) {
          throw new Error("PREFIXED_IGNORED is ignored in GraphQL schema");
        }

        return source.prefixedEnum;
      },
      extensions: {
        protobufField: {
          name: "prefixed_enum",
          typeFullName: "testapis.extensions.PrefixedEnum",
        },
      },
    }),
    notIgnoredMessage: t.expose("notIgnoredMessage", {
      type: TestPrefixIgnoredMessageNotIgnored$Ref,
      nullable: true,
      extensions: {
        protobufField: {
          name: "not_ignored_message",
          typeFullName: "testapis.extensions.IgnoredMessage.NotIgnored",
        },
      },
    }),
    squashedMessage: t.field({
      type: TestPrefixPrefixedMessageSquashedMessage$Ref,
      nullable: true,
      resolve: (source) => {
        return source.squashedMessage?.squashedMessage.value;
      },
      extensions: {
        protobufField: {
          name: "squashed_message",
          typeFullName: "testapis.extensions.PrefixedMessage.SquashedMessage",
        },
      },
    }),
    thisFieldWasRenamed: t.expose("thisFieldWillBeRenamed", {
      type: "String",
      nullable: false,
      extensions: {
        protobufField: {
          name: "this_field_will_be_renamed",
          typeFullName: "string",
          options: { "[graphql.field]": { name: "thisFieldWasRenamed" } },
        },
      },
    }),
    skipResolver: t.expose("skipResolver", {
      type: "String",
      nullable: false,
      extensions: {
        protobufField: {
          name: "skip_resolver",
          typeFullName: "string",
          options: { "[graphql.field]": { skipResolver: true } },
        },
      },
    }),
    squashedMessages: t.field({
      type: [TestPrefixPrefixedMessageSquashedMessage$Ref],
      nullable: { list: true, items: false },
      resolve: (source) => {
        return source.squashedMessages.map((item) => {
          const value = item.squashedMessage.value;
          if (value == null) {
            throw new Error("squashedMessages should not be null");
          }
          return value;
        });
      },
      extensions: {
        protobufField: {
          name: "squashed_messages",
          typeFullName: "testapis.extensions.PrefixedMessage.SquashedMessage",
        },
      },
    }),
    renamedMessage: t.expose("renamedMessage", {
      type: TestPrefixRenamedMessage$Ref,
      nullable: true,
      extensions: {
        protobufField: {
          name: "renamed_message",
          typeFullName: "testapis.extensions.MessageWillRename",
        },
      },
    }),
    renamedEnum: t.field({
      type: TestPrefixRenamedEnum$Ref,
      nullable: true,
      resolve: (source) => {
        if (source.renamedEnum === EnumWillRename.UNSPECIFIED) {
          return null;
        }

        return source.renamedEnum;
      },
      extensions: {
        protobufField: {
          name: "renamed_enum",
          typeFullName: "testapis.extensions.EnumWillRename",
        },
      },
    }),
    partialIgnoreOneof: t.field({
      type: TestPrefixPrefixedMessagePartialIgnoreOneof$Ref,
      nullable: true,
      resolve: (source) => {
        return source.partialIgnoreOneof.value;
      },
      extensions: { protobufField: { name: "partial_ignore_oneof" } },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof PrefixedMessage;
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.PrefixedMessage",
      name: "PrefixedMessage",
      package: "testapis.extensions",
    },
  },
});

export const TestPrefixRenamedMessage$Ref = builder.objectRef<
  MessageWillRename
>("TestPrefixRenamedMessage");
builder.objectType(TestPrefixRenamedMessage$Ref, {
  name: "TestPrefixRenamedMessage",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof MessageWillRename;
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.MessageWillRename",
      name: "MessageWillRename",
      package: "testapis.extensions",
      options: { "[graphql.object_type]": { name: "RenamedMessage" } },
    },
  },
});

export const TestPrefixMessageOnlyOutput$Ref = builder.objectRef<
  MessageOnlyOutput
>("TestPrefixMessageOnlyOutput");
builder.objectType(TestPrefixMessageOnlyOutput$Ref, {
  name: "TestPrefixMessageOnlyOutput",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof MessageOnlyOutput;
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.MessageOnlyOutput",
      name: "MessageOnlyOutput",
      package: "testapis.extensions",
      options: { "[graphql.input_type]": { ignore: true } },
    },
  },
});

export const TestPrefixPrefixedMessageInnerMessage$Ref = builder.objectRef<
  PrefixedMessage_InnerMessage
>("TestPrefixPrefixedMessageInnerMessage");
builder.objectType(TestPrefixPrefixedMessageInnerMessage$Ref, {
  name: "TestPrefixPrefixedMessageInnerMessage",
  fields: (t) => ({
    id: t.expose("id", {
      type: "Int64",
      nullable: false,
      extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
    }),
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof PrefixedMessage_InnerMessage;
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.PrefixedMessage.InnerMessage",
      name: "InnerMessage",
      package: "testapis.extensions",
    },
  },
});

export const TestPrefixPrefixedMessageInnerMessage2$Ref = builder.objectRef<
  PrefixedMessage_InnerMessage2
>("TestPrefixPrefixedMessageInnerMessage2");
builder.objectType(TestPrefixPrefixedMessageInnerMessage2$Ref, {
  name: "TestPrefixPrefixedMessageInnerMessage2",
  fields: (t) => ({
    id: t.expose("id", {
      type: "Int64",
      nullable: false,
      extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
    }),
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof PrefixedMessage_InnerMessage2;
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.PrefixedMessage.InnerMessage2",
      name: "InnerMessage2",
      package: "testapis.extensions",
    },
  },
});

export const TestPrefixIgnoredMessageNotIgnored$Ref = builder.objectRef<
  IgnoredMessage_NotIgnored
>("TestPrefixIgnoredMessageNotIgnored");
builder.objectType(TestPrefixIgnoredMessageNotIgnored$Ref, {
  name: "TestPrefixIgnoredMessageNotIgnored",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof IgnoredMessage_NotIgnored;
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.IgnoredMessage.NotIgnored",
      name: "NotIgnored",
      package: "testapis.extensions",
    },
  },
});

export type TestPrefixPrefixedMessageInput$Shape = {
  body: PrefixedMessage["body"];
  prefixedEnum?: PrefixedMessage["prefixedEnum"] | null;
  notIgnoredMessage?: TestPrefixIgnoredMessageNotIgnoredInput$Shape | null;
  squashedMessage?: TestPrefixPrefixedMessageSquashedMessageInput$Shape | null;
  thisFieldWasRenamed: PrefixedMessage["thisFieldWillBeRenamed"];
  oneofNotIgnoredField?:
    | TestPrefixPrefixedMessageInnerMessageInput$Shape
    | null;
  skipResolver: PrefixedMessage["skipResolver"];
  squashedMessages?:
    | Array<TestPrefixPrefixedMessageSquashedMessageInput$Shape>
    | null;
  renamedMessage?: TestPrefixRenamedMessageInput$Shape | null;
  renamedEnum?: PrefixedMessage["renamedEnum"] | null;
};

export const TestPrefixPrefixedMessageInput$Ref: InputObjectRef<
  TestPrefixPrefixedMessageInput$Shape
> = builder.inputRef<TestPrefixPrefixedMessageInput$Shape>(
  "TestPrefixPrefixedMessageInput",
).implement(
  {
    fields: (t) => ({
      body: t.field({
        type: "String",
        required: true,
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
      prefixedEnum: t.field({
        type: TestPrefixPrefixedEnum$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "prefixed_enum",
            typeFullName: "testapis.extensions.PrefixedEnum",
          },
        },
      }),
      notIgnoredMessage: t.field({
        type: TestPrefixIgnoredMessageNotIgnoredInput$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "not_ignored_message",
            typeFullName: "testapis.extensions.IgnoredMessage.NotIgnored",
          },
        },
      }),
      squashedMessage: t.field({
        type: TestPrefixPrefixedMessageSquashedMessageInput$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "squashed_message",
            typeFullName: "testapis.extensions.PrefixedMessage.SquashedMessage",
          },
        },
      }),
      thisFieldWasRenamed: t.field({
        type: "String",
        required: true,
        extensions: {
          protobufField: {
            name: "this_field_will_be_renamed",
            typeFullName: "string",
            options: { "[graphql.field]": { name: "thisFieldWasRenamed" } },
          },
        },
      }),
      oneofNotIgnoredField: t.field({
        type: TestPrefixPrefixedMessageInnerMessageInput$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "oneof_not_ignored_field",
            typeFullName: "testapis.extensions.PrefixedMessage.InnerMessage",
          },
        },
      }),
      skipResolver: t.field({
        type: "String",
        required: true,
        extensions: {
          protobufField: {
            name: "skip_resolver",
            typeFullName: "string",
            options: { "[graphql.field]": { skipResolver: true } },
          },
        },
      }),
      squashedMessages: t.field({
        type: [TestPrefixPrefixedMessageSquashedMessageInput$Ref],
        required: { list: false, items: true },
        extensions: {
          protobufField: {
            name: "squashed_messages",
            typeFullName: "testapis.extensions.PrefixedMessage.SquashedMessage",
          },
        },
      }),
      renamedMessage: t.field({
        type: TestPrefixRenamedMessageInput$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "renamed_message",
            typeFullName: "testapis.extensions.MessageWillRename",
          },
        },
      }),
      renamedEnum: t.field({
        type: TestPrefixRenamedEnum$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "renamed_enum",
            typeFullName: "testapis.extensions.EnumWillRename",
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.extensions.PrefixedMessage",
        name: "PrefixedMessage",
        package: "testapis.extensions",
      },
    },
  },
);

export function TestPrefixPrefixedMessageInput$toProto(
  input: TestPrefixPrefixedMessageInput$Shape | null | undefined,
): PrefixedMessage {
  return new PrefixedMessage({
    body: input?.body ?? undefined,
    prefixedEnum: input?.prefixedEnum ?? undefined,
    notIgnoredMessage: input?.notIgnoredMessage
      ? TestPrefixIgnoredMessageNotIgnoredInput$toProto(input.notIgnoredMessage)
      : undefined,
    squashedMessage: input?.squashedMessage
      ? TestPrefixPrefixedMessageSquashedMessageInput$toProto(
        input.squashedMessage,
      )
      : undefined,
    thisFieldWillBeRenamed: input?.thisFieldWasRenamed ?? undefined,
    skipResolver: input?.skipResolver ?? undefined,
    squashedMessages: input?.squashedMessages?.map((v) =>
      TestPrefixPrefixedMessageSquashedMessageInput$toProto(v)
    ),
    renamedMessage: input?.renamedMessage
      ? TestPrefixRenamedMessageInput$toProto(input.renamedMessage)
      : undefined,
    renamedEnum: input?.renamedEnum ?? undefined,
    partialIgnoreOneof: input?.oneofNotIgnoredField
      ? {
        case: "oneofNotIgnoredField",
        value: TestPrefixPrefixedMessageInnerMessageInput$toProto(
          input.oneofNotIgnoredField,
        ),
      }
      : undefined,
  });
}

export type TestPrefixRenamedMessageInput$Shape = {
  body: MessageWillRename["body"];
};

export const TestPrefixRenamedMessageInput$Ref: InputObjectRef<
  TestPrefixRenamedMessageInput$Shape
> = builder.inputRef<TestPrefixRenamedMessageInput$Shape>(
  "TestPrefixRenamedMessageInput",
).implement(
  {
    fields: (t) => ({
      body: t.field({
        type: "String",
        required: true,
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.extensions.MessageWillRename",
        name: "MessageWillRename",
        package: "testapis.extensions",
        options: { "[graphql.object_type]": { name: "RenamedMessage" } },
      },
    },
  },
);

export function TestPrefixRenamedMessageInput$toProto(
  input: TestPrefixRenamedMessageInput$Shape | null | undefined,
): MessageWillRename {
  return new MessageWillRename({
    body: input?.body ?? undefined,
  });
}

export type TestPrefixInterfaceMessageInput$Shape = {
  id: InterfaceMessage["id"];
};

export const TestPrefixInterfaceMessageInput$Ref: InputObjectRef<
  TestPrefixInterfaceMessageInput$Shape
> = builder.inputRef<TestPrefixInterfaceMessageInput$Shape>(
  "TestPrefixInterfaceMessageInput",
).implement(
  {
    fields: (t) => ({
      id: t.field({
        type: "Int64",
        required: true,
        extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.extensions.InterfaceMessage",
        name: "InterfaceMessage",
        package: "testapis.extensions",
        options: { "[graphql.object_type]": { interface: true } },
      },
    },
  },
);

export function TestPrefixInterfaceMessageInput$toProto(
  input: TestPrefixInterfaceMessageInput$Shape | null | undefined,
): InterfaceMessage {
  return new InterfaceMessage({
    id: input?.id ?? undefined,
  });
}

export type TestPrefixPrefixedMessageInnerMessageInput$Shape = {
  id: PrefixedMessage_InnerMessage["id"];
  body: PrefixedMessage_InnerMessage["body"];
};

export const TestPrefixPrefixedMessageInnerMessageInput$Ref: InputObjectRef<
  TestPrefixPrefixedMessageInnerMessageInput$Shape
> = builder.inputRef<TestPrefixPrefixedMessageInnerMessageInput$Shape>(
  "TestPrefixPrefixedMessageInnerMessageInput",
).implement(
  {
    fields: (t) => ({
      id: t.field({
        type: "Int64",
        required: true,
        extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
      }),
      body: t.field({
        type: "String",
        required: true,
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.extensions.PrefixedMessage.InnerMessage",
        name: "InnerMessage",
        package: "testapis.extensions",
      },
    },
  },
);

export function TestPrefixPrefixedMessageInnerMessageInput$toProto(
  input: TestPrefixPrefixedMessageInnerMessageInput$Shape | null | undefined,
): PrefixedMessage_InnerMessage {
  return new PrefixedMessage_InnerMessage({
    id: input?.id ?? undefined,
    body: input?.body ?? undefined,
  });
}

export type TestPrefixPrefixedMessageInnerMessage2Input$Shape = {
  id: PrefixedMessage_InnerMessage2["id"];
  body: PrefixedMessage_InnerMessage2["body"];
};

export const TestPrefixPrefixedMessageInnerMessage2Input$Ref: InputObjectRef<
  TestPrefixPrefixedMessageInnerMessage2Input$Shape
> = builder.inputRef<TestPrefixPrefixedMessageInnerMessage2Input$Shape>(
  "TestPrefixPrefixedMessageInnerMessage2Input",
).implement(
  {
    fields: (t) => ({
      id: t.field({
        type: "Int64",
        required: true,
        extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
      }),
      body: t.field({
        type: "String",
        required: true,
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.extensions.PrefixedMessage.InnerMessage2",
        name: "InnerMessage2",
        package: "testapis.extensions",
      },
    },
  },
);

export function TestPrefixPrefixedMessageInnerMessage2Input$toProto(
  input: TestPrefixPrefixedMessageInnerMessage2Input$Shape | null | undefined,
): PrefixedMessage_InnerMessage2 {
  return new PrefixedMessage_InnerMessage2({
    id: input?.id ?? undefined,
    body: input?.body ?? undefined,
  });
}

export type TestPrefixPrefixedMessageSquashedMessageInput$Shape = {
  oneofField?: TestPrefixPrefixedMessageInnerMessageInput$Shape | null;
  oneofField2?: TestPrefixPrefixedMessageInnerMessage2Input$Shape | null;
};

export const TestPrefixPrefixedMessageSquashedMessageInput$Ref: InputObjectRef<
  TestPrefixPrefixedMessageSquashedMessageInput$Shape
> = builder.inputRef<TestPrefixPrefixedMessageSquashedMessageInput$Shape>(
  "TestPrefixPrefixedMessageSquashedMessageInput",
).implement(
  {
    fields: (t) => ({
      oneofField: t.field({
        type: TestPrefixPrefixedMessageInnerMessageInput$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "oneof_field",
            typeFullName: "testapis.extensions.PrefixedMessage.InnerMessage",
          },
        },
      }),
      oneofField2: t.field({
        type: TestPrefixPrefixedMessageInnerMessage2Input$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "oneof_field_2",
            typeFullName: "testapis.extensions.PrefixedMessage.InnerMessage2",
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.extensions.PrefixedMessage.SquashedMessage",
        name: "SquashedMessage",
        package: "testapis.extensions",
        options: { "[graphql.object_type]": { squashUnion: true } },
      },
    },
  },
);

export function TestPrefixPrefixedMessageSquashedMessageInput$toProto(
  input: TestPrefixPrefixedMessageSquashedMessageInput$Shape | null | undefined,
): PrefixedMessage_SquashedMessage {
  return new PrefixedMessage_SquashedMessage({
    squashedMessage: input?.oneofField
      ? {
        case: "oneofField",
        value: TestPrefixPrefixedMessageInnerMessageInput$toProto(
          input.oneofField,
        ),
      }
      : input?.oneofField2
      ? {
        case: "oneofField2",
        value: TestPrefixPrefixedMessageInnerMessage2Input$toProto(
          input.oneofField2,
        ),
      }
      : undefined,
  });
}

export type TestPrefixIgnoredMessageNotIgnoredInput$Shape = {
  body: IgnoredMessage_NotIgnored["body"];
};

export const TestPrefixIgnoredMessageNotIgnoredInput$Ref: InputObjectRef<
  TestPrefixIgnoredMessageNotIgnoredInput$Shape
> = builder.inputRef<TestPrefixIgnoredMessageNotIgnoredInput$Shape>(
  "TestPrefixIgnoredMessageNotIgnoredInput",
).implement(
  {
    fields: (t) => ({
      body: t.field({
        type: "String",
        required: true,
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.extensions.IgnoredMessage.NotIgnored",
        name: "NotIgnored",
        package: "testapis.extensions",
      },
    },
  },
);

export function TestPrefixIgnoredMessageNotIgnoredInput$toProto(
  input: TestPrefixIgnoredMessageNotIgnoredInput$Shape | null | undefined,
): IgnoredMessage_NotIgnored {
  return new IgnoredMessage_NotIgnored({
    body: input?.body ?? undefined,
  });
}

export const TestPrefixInterfaceMessage$Ref = builder.interfaceRef<
  Pick<
    InterfaceMessage,
    "id"
  >
>("TestPrefixInterfaceMessage");
builder.interfaceType(TestPrefixInterfaceMessage$Ref, {
  name: "TestPrefixInterfaceMessage",
  fields: (t) => ({
    id: t.expose("id", {
      type: "Int64",
      nullable: false,
      extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
    }),
  }),
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.InterfaceMessage",
      name: "InterfaceMessage",
      package: "testapis.extensions",
      options: { "[graphql.object_type]": { interface: true } },
    },
  },
});

export const TestPrefixPrefixedMessageSquashedMessage$Ref = builder.unionType(
  "TestPrefixPrefixedMessageSquashedMessage",
  {
    types: [
      TestPrefixPrefixedMessageInnerMessage$Ref,
      TestPrefixPrefixedMessageInnerMessage2$Ref,
    ],
    extensions: {
      protobufOneof: {
        fullName: "testapis.extensions.PrefixedMessage.SquashedMessage",
        name: "SquashedMessage",
        package: "testapis.extensions",
        fields: [{
          name: "oneof_field",
          type: "testapis.extensions.PrefixedMessage.InnerMessage",
          options: { "[graphql.object_type]": { squashUnion: true } },
        }, {
          name: "oneof_field_2",
          type: "testapis.extensions.PrefixedMessage.InnerMessage2",
          options: { "[graphql.object_type]": { squashUnion: true } },
        }],
      },
    },
  },
);

export const TestPrefixPrefixedMessagePartialIgnoreOneof$Ref = builder
  .unionType("TestPrefixPrefixedMessagePartialIgnoreOneof", {
    types: [TestPrefixPrefixedMessageInnerMessage$Ref],
    extensions: {
      protobufOneof: {
        fullName: "testapis.extensions.PrefixedMessage.partial_ignore_oneof",
        name: "partial_ignore_oneof",
        messageName: "PrefixedMessage",
        package: "testapis.extensions",
        fields: [{
          name: "oneof_not_ignored_field",
          type: "testapis.extensions.PrefixedMessage.InnerMessage",
        }],
      },
    },
  });

export const TestPrefixPrefixedEnum$Ref: EnumRef<PrefixedEnum, PrefixedEnum> =
  builder.enumType("TestPrefixPrefixedEnum", {
    values: {
      PREFIXED_FOO: {
        value: 1,
        extensions: { protobufEnumValue: { name: "PREFIXED_FOO" } },
      },
      PREFIXED_BAR: {
        value: 2,
        extensions: { protobufEnumValue: { name: "PREFIXED_BAR" } },
      },
    } as const,
    extensions: {
      protobufEnum: {
        name: "PrefixedEnum",
        fullName: "testapis.extensions.PrefixedEnum",
        package: "testapis.extensions",
      },
    },
  });

export const TestPrefixRenamedEnum$Ref: EnumRef<
  EnumWillRename,
  EnumWillRename
> = builder.enumType("TestPrefixRenamedEnum", {
  values: {
    FOO: {
      value: 1,
      extensions: { protobufEnumValue: { name: "ENUM_WILL_RENAME_FOO" } },
    },
    BAR: {
      value: 2,
      extensions: { protobufEnumValue: { name: "ENUM_WILL_RENAME_BAR" } },
    },
  } as const,
  extensions: {
    protobufEnum: {
      name: "EnumWillRename",
      fullName: "testapis.extensions.EnumWillRename",
      package: "testapis.extensions",
      options: { "[graphql.enum_type]": { name: "RenamedEnum" } },
    },
  },
});

export const TestPrefixInterfaceMessageType$Ref: EnumRef<
  InterfaceMessage_Type,
  InterfaceMessage_Type
> = builder.enumType("TestPrefixInterfaceMessageType", {
  values: {
    INNER: { value: 1, extensions: { protobufEnumValue: { name: "INNER" } } },
    INNER2: { value: 2, extensions: { protobufEnumValue: { name: "INNER2" } } },
  } as const,
  extensions: {
    protobufEnum: {
      name: "Type",
      fullName: "testapis.extensions.InterfaceMessage.Type",
      package: "testapis.extensions",
    },
  },
});
",
    "name": "testapis/extensions/extensions.pb.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/extensions/ignored.proto

/* eslint-disable */

export {};
",
    "name": "testapis/extensions/ignored.pb.pothos.ts",
  },
]
`;

exports[`protobuf-es > 'testapis.extensions.field_nullability' > generates files by plugin 'with import prefix' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/extensions/field_nullability/nullability.proto

/* eslint-disable */

import { EnumRef, InputObjectRef } from "@pothos/core";
import {
  Message,
  Message_Status,
} from "@testapis/protobuf-es/testapis/extensions/field_nullability/nullability_pb";
import { builder } from "../../../builder";

export const Message$Ref = builder.objectRef<Message>("Message");
builder.objectType(Message$Ref, {
  name: "Message",
  fields: (t) => ({
    userId: t.expose("userId", {
      type: "Int64",
      nullable: false,
      description: "Required.",
      extensions: {
        protobufField: {
          name: "user_id",
          typeFullName: "uint64",
          options: {
            "[graphql.field]": {
              outputNullability: "NON_NULL",
              inputNullability: "NULLABLE",
              partialInputNullability: "NON_NULL",
            },
          },
        },
      },
    }),
    body: t.expose("body", {
      type: "String",
      nullable: false,
      description: "Required.",
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
    status: t.field({
      type: MessageStatus$Ref,
      nullable: true,
      description: "Required.",
      resolve: (source) => {
        if (source.status === Message_Status.STATUS_UNSPECIFIED) {
          return null;
        }

        return source.status;
      },
      extensions: {
        protobufField: {
          name: "status",
          typeFullName: "testapis.extensions.field_nullability.Message.Status",
          options: {
            "[graphql.field]": {
              outputNullability: "NULLABLE",
              inputNullability: "NULLABLE",
            },
          },
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof Message;
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.field_nullability.Message",
      name: "Message",
      package: "testapis.extensions.field_nullability",
    },
  },
});

export type MessageInput$Shape = {
  userId?: Message["userId"] | null;
  body: Message["body"];
  status?: Message["status"] | null;
};

export const MessageInput$Ref: InputObjectRef<MessageInput$Shape> = builder
  .inputRef<MessageInput$Shape>("MessageInput").implement(
    {
      fields: (t) => ({
        userId: t.field({
          type: "Int64",
          required: false,
          description: "Required.",
          extensions: {
            protobufField: {
              name: "user_id",
              typeFullName: "uint64",
              options: {
                "[graphql.field]": {
                  outputNullability: "NON_NULL",
                  inputNullability: "NULLABLE",
                  partialInputNullability: "NON_NULL",
                },
              },
            },
          },
        }),
        body: t.field({
          type: "String",
          required: true,
          description: "Required.",
          extensions: {
            protobufField: { name: "body", typeFullName: "string" },
          },
        }),
        status: t.field({
          type: MessageStatus$Ref,
          required: false,
          description: "Required.",
          extensions: {
            protobufField: {
              name: "status",
              typeFullName:
                "testapis.extensions.field_nullability.Message.Status",
              options: {
                "[graphql.field]": {
                  outputNullability: "NULLABLE",
                  inputNullability: "NULLABLE",
                },
              },
            },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.extensions.field_nullability.Message",
          name: "Message",
          package: "testapis.extensions.field_nullability",
        },
      },
    },
  );

export function MessageInput$toProto(
  input: MessageInput$Shape | null | undefined,
): Message {
  return new Message({
    userId: input?.userId ?? undefined,
    body: input?.body ?? undefined,
    status: input?.status ?? undefined,
  });
}

export const MessageStatus$Ref: EnumRef<Message_Status, Message_Status> =
  builder.enumType("MessageStatus", {
    values: {
      DRAFT: { value: 1, extensions: { protobufEnumValue: { name: "DRAFT" } } },
      PUBLISHED: {
        value: 2,
        extensions: { protobufEnumValue: { name: "PUBLISHED" } },
      },
    } as const,
    extensions: {
      protobufEnum: {
        name: "Status",
        fullName: "testapis.extensions.field_nullability.Message.Status",
        package: "testapis.extensions.field_nullability",
      },
    },
  });
",
    "name": "testapis/extensions/field_nullability/nullability.pb.pothos.ts",
  },
]
`;

exports[`protobuf-es > 'testapis.extensions.field_nullability' > generates files by plugin 'with partial inputs' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/extensions/field_nullability/nullability.proto

/* eslint-disable */

import { EnumRef, InputObjectRef } from "@pothos/core";
import {
  Message,
  Message_Status,
} from "@testapis/protobuf-es/testapis/extensions/field_nullability/nullability_pb";
import { builder } from "../../../builder";

export const Message$Ref = builder.objectRef<Message>("Message");
builder.objectType(Message$Ref, {
  name: "Message",
  fields: (t) => ({
    userId: t.expose("userId", {
      type: "Int64",
      nullable: false,
      description: "Required.",
      extensions: {
        protobufField: {
          name: "user_id",
          typeFullName: "uint64",
          options: {
            "[graphql.field]": {
              outputNullability: "NON_NULL",
              inputNullability: "NULLABLE",
              partialInputNullability: "NON_NULL",
            },
          },
        },
      },
    }),
    body: t.expose("body", {
      type: "String",
      nullable: false,
      description: "Required.",
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
    status: t.field({
      type: MessageStatus$Ref,
      nullable: true,
      description: "Required.",
      resolve: (source) => {
        if (source.status === Message_Status.STATUS_UNSPECIFIED) {
          return null;
        }

        return source.status;
      },
      extensions: {
        protobufField: {
          name: "status",
          typeFullName: "testapis.extensions.field_nullability.Message.Status",
          options: {
            "[graphql.field]": {
              outputNullability: "NULLABLE",
              inputNullability: "NULLABLE",
            },
          },
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof Message;
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.field_nullability.Message",
      name: "Message",
      package: "testapis.extensions.field_nullability",
    },
  },
});

export type MessageInput$Shape = {
  userId?: Message["userId"] | null;
  body: Message["body"];
  status?: Message["status"] | null;
};

export const MessageInput$Ref: InputObjectRef<MessageInput$Shape> = builder
  .inputRef<MessageInput$Shape>("MessageInput").implement(
    {
      fields: (t) => ({
        userId: t.field({
          type: "Int64",
          required: false,
          description: "Required.",
          extensions: {
            protobufField: {
              name: "user_id",
              typeFullName: "uint64",
              options: {
                "[graphql.field]": {
                  outputNullability: "NON_NULL",
                  inputNullability: "NULLABLE",
                  partialInputNullability: "NON_NULL",
                },
              },
            },
          },
        }),
        body: t.field({
          type: "String",
          required: true,
          description: "Required.",
          extensions: {
            protobufField: { name: "body", typeFullName: "string" },
          },
        }),
        status: t.field({
          type: MessageStatus$Ref,
          required: false,
          description: "Required.",
          extensions: {
            protobufField: {
              name: "status",
              typeFullName:
                "testapis.extensions.field_nullability.Message.Status",
              options: {
                "[graphql.field]": {
                  outputNullability: "NULLABLE",
                  inputNullability: "NULLABLE",
                },
              },
            },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.extensions.field_nullability.Message",
          name: "Message",
          package: "testapis.extensions.field_nullability",
        },
      },
    },
  );

export function MessageInput$toProto(
  input: MessageInput$Shape | null | undefined,
): Message {
  return new Message({
    userId: input?.userId ?? undefined,
    body: input?.body ?? undefined,
    status: input?.status ?? undefined,
  });
}

export type MessagePartialInput$Shape = {
  userId: Message["userId"];
  body?: Message["body"] | null;
  status?: Message["status"] | null;
};

export const MessagePartialInput$Ref: InputObjectRef<
  MessagePartialInput$Shape
> = builder.inputRef<MessagePartialInput$Shape>("MessagePartialInput")
  .implement(
    {
      fields: (t) => ({
        userId: t.field({
          type: "Int64",
          required: true,
          description: "Required.",
          extensions: {
            protobufField: {
              name: "user_id",
              typeFullName: "uint64",
              options: {
                "[graphql.field]": {
                  outputNullability: "NON_NULL",
                  inputNullability: "NULLABLE",
                  partialInputNullability: "NON_NULL",
                },
              },
            },
          },
        }),
        body: t.field({
          type: "String",
          required: false,
          description: "Required.",
          extensions: {
            protobufField: { name: "body", typeFullName: "string" },
          },
        }),
        status: t.field({
          type: MessageStatus$Ref,
          required: false,
          description: "Required.",
          extensions: {
            protobufField: {
              name: "status",
              typeFullName:
                "testapis.extensions.field_nullability.Message.Status",
              options: {
                "[graphql.field]": {
                  outputNullability: "NULLABLE",
                  inputNullability: "NULLABLE",
                },
              },
            },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.extensions.field_nullability.Message",
          name: "Message",
          package: "testapis.extensions.field_nullability",
        },
      },
    },
  );

export function MessagePartialInput$toProto(
  input: MessagePartialInput$Shape | null | undefined,
): Message {
  return new Message({
    userId: input?.userId ?? undefined,
    body: input?.body ?? undefined,
    status: input?.status ?? undefined,
  });
}

export const MessageStatus$Ref: EnumRef<Message_Status, Message_Status> =
  builder.enumType("MessageStatus", {
    values: {
      DRAFT: { value: 1, extensions: { protobufEnumValue: { name: "DRAFT" } } },
      PUBLISHED: {
        value: 2,
        extensions: { protobufEnumValue: { name: "PUBLISHED" } },
      },
    } as const,
    extensions: {
      protobufEnum: {
        name: "Status",
        fullName: "testapis.extensions.field_nullability.Message.Status",
        package: "testapis.extensions.field_nullability",
      },
    },
  });
",
    "name": "testapis/extensions/field_nullability/nullability.pb.pothos.ts",
  },
]
`;

exports[`protobuf-es > 'testapis.extensions.field_nullability' > generates files by plugin 'without import prefix' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/extensions/field_nullability/nullability.proto

/* eslint-disable */

import { EnumRef, InputObjectRef } from "@pothos/core";
import { builder } from "../../../builder";
import {
  Message,
  Message_Status,
} from "./testapis/extensions/field_nullability/nullability_pb";

export const Message$Ref = builder.objectRef<Message>("Message");
builder.objectType(Message$Ref, {
  name: "Message",
  fields: (t) => ({
    userId: t.expose("userId", {
      type: "Int64",
      nullable: false,
      description: "Required.",
      extensions: {
        protobufField: {
          name: "user_id",
          typeFullName: "uint64",
          options: {
            "[graphql.field]": {
              outputNullability: "NON_NULL",
              inputNullability: "NULLABLE",
              partialInputNullability: "NON_NULL",
            },
          },
        },
      },
    }),
    body: t.expose("body", {
      type: "String",
      nullable: false,
      description: "Required.",
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
    status: t.field({
      type: MessageStatus$Ref,
      nullable: true,
      description: "Required.",
      resolve: (source) => {
        if (source.status === Message_Status.STATUS_UNSPECIFIED) {
          return null;
        }

        return source.status;
      },
      extensions: {
        protobufField: {
          name: "status",
          typeFullName: "testapis.extensions.field_nullability.Message.Status",
          options: {
            "[graphql.field]": {
              outputNullability: "NULLABLE",
              inputNullability: "NULLABLE",
            },
          },
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof Message;
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.field_nullability.Message",
      name: "Message",
      package: "testapis.extensions.field_nullability",
    },
  },
});

export type MessageInput$Shape = {
  userId?: Message["userId"] | null;
  body: Message["body"];
  status?: Message["status"] | null;
};

export const MessageInput$Ref: InputObjectRef<MessageInput$Shape> = builder
  .inputRef<MessageInput$Shape>("MessageInput").implement(
    {
      fields: (t) => ({
        userId: t.field({
          type: "Int64",
          required: false,
          description: "Required.",
          extensions: {
            protobufField: {
              name: "user_id",
              typeFullName: "uint64",
              options: {
                "[graphql.field]": {
                  outputNullability: "NON_NULL",
                  inputNullability: "NULLABLE",
                  partialInputNullability: "NON_NULL",
                },
              },
            },
          },
        }),
        body: t.field({
          type: "String",
          required: true,
          description: "Required.",
          extensions: {
            protobufField: { name: "body", typeFullName: "string" },
          },
        }),
        status: t.field({
          type: MessageStatus$Ref,
          required: false,
          description: "Required.",
          extensions: {
            protobufField: {
              name: "status",
              typeFullName:
                "testapis.extensions.field_nullability.Message.Status",
              options: {
                "[graphql.field]": {
                  outputNullability: "NULLABLE",
                  inputNullability: "NULLABLE",
                },
              },
            },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.extensions.field_nullability.Message",
          name: "Message",
          package: "testapis.extensions.field_nullability",
        },
      },
    },
  );

export function MessageInput$toProto(
  input: MessageInput$Shape | null | undefined,
): Message {
  return new Message({
    userId: input?.userId ?? undefined,
    body: input?.body ?? undefined,
    status: input?.status ?? undefined,
  });
}

export const MessageStatus$Ref: EnumRef<Message_Status, Message_Status> =
  builder.enumType("MessageStatus", {
    values: {
      DRAFT: { value: 1, extensions: { protobufEnumValue: { name: "DRAFT" } } },
      PUBLISHED: {
        value: 2,
        extensions: { protobufEnumValue: { name: "PUBLISHED" } },
      },
    } as const,
    extensions: {
      protobufEnum: {
        name: "Status",
        fullName: "testapis.extensions.field_nullability.Message.Status",
        package: "testapis.extensions.field_nullability",
      },
    },
  });
",
    "name": "testapis/extensions/field_nullability/nullability.pb.pothos.ts",
  },
]
`;

exports[`protobuf-es > 'testapis.extensions.no_partial' > generates files by plugin 'with import prefix' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/extensions/no_partial/no_partial.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import {
  NoPartialInputMessage,
  ParentMessage,
  PartialableInputMessage,
} from "@testapis/protobuf-es/testapis/extensions/no_partial/no_partial_pb";
import { builder } from "../../../builder";

export const ParentMessage$Ref = builder.objectRef<ParentMessage>(
  "ParentMessage",
);
builder.objectType(ParentMessage$Ref, {
  name: "ParentMessage",
  fields: (t) => ({
    partialableInputMessage: t.field({
      type: PartialableInputMessage$Ref,
      nullable: false,
      description: "Required.",
      resolve: (source) => {
        return source.partialableInputMessage!;
      },
      extensions: {
        protobufField: {
          name: "partialable_input_message",
          typeFullName:
            "testapis.extensions.no_partial.PartialableInputMessage",
        },
      },
    }),
    noPartialInputMessage: t.field({
      type: NoPartialInputMessage$Ref,
      nullable: false,
      description: "Required.",
      resolve: (source) => {
        return source.noPartialInputMessage!;
      },
      extensions: {
        protobufField: {
          name: "no_partial_input_message",
          typeFullName: "testapis.extensions.no_partial.NoPartialInputMessage",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof ParentMessage;
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.no_partial.ParentMessage",
      name: "ParentMessage",
      package: "testapis.extensions.no_partial",
    },
  },
});

export const PartialableInputMessage$Ref = builder.objectRef<
  PartialableInputMessage
>("PartialableInputMessage");
builder.objectType(PartialableInputMessage$Ref, {
  name: "PartialableInputMessage",
  fields: (t) => ({
    id: t.expose("id", {
      type: "Int64",
      nullable: false,
      description: "Required.",
      extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
    }),
    body: t.expose("body", {
      type: "String",
      nullable: false,
      description: "Required.",
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof PartialableInputMessage;
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.no_partial.PartialableInputMessage",
      name: "PartialableInputMessage",
      package: "testapis.extensions.no_partial",
    },
  },
});

export const NoPartialInputMessage$Ref = builder.objectRef<
  NoPartialInputMessage
>("NoPartialInputMessage");
builder.objectType(NoPartialInputMessage$Ref, {
  name: "NoPartialInputMessage",
  fields: (t) => ({
    id: t.expose("id", {
      type: "Int64",
      nullable: false,
      description: "Required.",
      extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
    }),
    body: t.expose("body", {
      type: "String",
      nullable: false,
      description: "Required.",
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof NoPartialInputMessage;
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.no_partial.NoPartialInputMessage",
      name: "NoPartialInputMessage",
      package: "testapis.extensions.no_partial",
      options: { "[graphql.input_type]": { noPartial: true } },
    },
  },
});

export type ParentMessageInput$Shape = {
  partialableInputMessage: PartialableInputMessageInput$Shape;
  noPartialInputMessage: NoPartialInputMessageInput$Shape;
};

export const ParentMessageInput$Ref: InputObjectRef<ParentMessageInput$Shape> =
  builder.inputRef<ParentMessageInput$Shape>("ParentMessageInput").implement(
    {
      fields: (t) => ({
        partialableInputMessage: t.field({
          type: PartialableInputMessageInput$Ref,
          required: true,
          description: "Required.",
          extensions: {
            protobufField: {
              name: "partialable_input_message",
              typeFullName:
                "testapis.extensions.no_partial.PartialableInputMessage",
            },
          },
        }),
        noPartialInputMessage: t.field({
          type: NoPartialInputMessageInput$Ref,
          required: true,
          description: "Required.",
          extensions: {
            protobufField: {
              name: "no_partial_input_message",
              typeFullName:
                "testapis.extensions.no_partial.NoPartialInputMessage",
            },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.extensions.no_partial.ParentMessage",
          name: "ParentMessage",
          package: "testapis.extensions.no_partial",
        },
      },
    },
  );

export function ParentMessageInput$toProto(
  input: ParentMessageInput$Shape | null | undefined,
): ParentMessage {
  return new ParentMessage({
    partialableInputMessage: input?.partialableInputMessage
      ? PartialableInputMessageInput$toProto(input.partialableInputMessage)
      : undefined,
    noPartialInputMessage: input?.noPartialInputMessage
      ? NoPartialInputMessageInput$toProto(input.noPartialInputMessage)
      : undefined,
  });
}

export type PartialableInputMessageInput$Shape = {
  id: PartialableInputMessage["id"];
  body: PartialableInputMessage["body"];
};

export const PartialableInputMessageInput$Ref: InputObjectRef<
  PartialableInputMessageInput$Shape
> = builder.inputRef<PartialableInputMessageInput$Shape>(
  "PartialableInputMessageInput",
).implement(
  {
    fields: (t) => ({
      id: t.field({
        type: "Int64",
        required: true,
        description: "Required.",
        extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
      }),
      body: t.field({
        type: "String",
        required: true,
        description: "Required.",
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.extensions.no_partial.PartialableInputMessage",
        name: "PartialableInputMessage",
        package: "testapis.extensions.no_partial",
      },
    },
  },
);

export function PartialableInputMessageInput$toProto(
  input: PartialableInputMessageInput$Shape | null | undefined,
): PartialableInputMessage {
  return new PartialableInputMessage({
    id: input?.id ?? undefined,
    body: input?.body ?? undefined,
  });
}

export type NoPartialInputMessageInput$Shape = {
  id: NoPartialInputMessage["id"];
  body: NoPartialInputMessage["body"];
};

export const NoPartialInputMessageInput$Ref: InputObjectRef<
  NoPartialInputMessageInput$Shape
> = builder.inputRef<NoPartialInputMessageInput$Shape>(
  "NoPartialInputMessageInput",
).implement(
  {
    fields: (t) => ({
      id: t.field({
        type: "Int64",
        required: true,
        description: "Required.",
        extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
      }),
      body: t.field({
        type: "String",
        required: true,
        description: "Required.",
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.extensions.no_partial.NoPartialInputMessage",
        name: "NoPartialInputMessage",
        package: "testapis.extensions.no_partial",
        options: { "[graphql.input_type]": { noPartial: true } },
      },
    },
  },
);

export function NoPartialInputMessageInput$toProto(
  input: NoPartialInputMessageInput$Shape | null | undefined,
): NoPartialInputMessage {
  return new NoPartialInputMessage({
    id: input?.id ?? undefined,
    body: input?.body ?? undefined,
  });
}
",
    "name": "testapis/extensions/no_partial/no_partial.pb.pothos.ts",
  },
]
`;

exports[`protobuf-es > 'testapis.extensions.no_partial' > generates files by plugin 'with partial inputs' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/extensions/no_partial/no_partial.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import {
  NoPartialInputMessage,
  ParentMessage,
  PartialableInputMessage,
} from "@testapis/protobuf-es/testapis/extensions/no_partial/no_partial_pb";
import { builder } from "../../../builder";

export const ParentMessage$Ref = builder.objectRef<ParentMessage>(
  "ParentMessage",
);
builder.objectType(ParentMessage$Ref, {
  name: "ParentMessage",
  fields: (t) => ({
    partialableInputMessage: t.field({
      type: PartialableInputMessage$Ref,
      nullable: false,
      description: "Required.",
      resolve: (source) => {
        return source.partialableInputMessage!;
      },
      extensions: {
        protobufField: {
          name: "partialable_input_message",
          typeFullName:
            "testapis.extensions.no_partial.PartialableInputMessage",
        },
      },
    }),
    noPartialInputMessage: t.field({
      type: NoPartialInputMessage$Ref,
      nullable: false,
      description: "Required.",
      resolve: (source) => {
        return source.noPartialInputMessage!;
      },
      extensions: {
        protobufField: {
          name: "no_partial_input_message",
          typeFullName: "testapis.extensions.no_partial.NoPartialInputMessage",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof ParentMessage;
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.no_partial.ParentMessage",
      name: "ParentMessage",
      package: "testapis.extensions.no_partial",
    },
  },
});

export const PartialableInputMessage$Ref = builder.objectRef<
  PartialableInputMessage
>("PartialableInputMessage");
builder.objectType(PartialableInputMessage$Ref, {
  name: "PartialableInputMessage",
  fields: (t) => ({
    id: t.expose("id", {
      type: "Int64",
      nullable: false,
      description: "Required.",
      extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
    }),
    body: t.expose("body", {
      type: "String",
      nullable: false,
      description: "Required.",
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof PartialableInputMessage;
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.no_partial.PartialableInputMessage",
      name: "PartialableInputMessage",
      package: "testapis.extensions.no_partial",
    },
  },
});

export const NoPartialInputMessage$Ref = builder.objectRef<
  NoPartialInputMessage
>("NoPartialInputMessage");
builder.objectType(NoPartialInputMessage$Ref, {
  name: "NoPartialInputMessage",
  fields: (t) => ({
    id: t.expose("id", {
      type: "Int64",
      nullable: false,
      description: "Required.",
      extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
    }),
    body: t.expose("body", {
      type: "String",
      nullable: false,
      description: "Required.",
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof NoPartialInputMessage;
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.no_partial.NoPartialInputMessage",
      name: "NoPartialInputMessage",
      package: "testapis.extensions.no_partial",
      options: { "[graphql.input_type]": { noPartial: true } },
    },
  },
});

export type ParentMessageInput$Shape = {
  partialableInputMessage: PartialableInputMessageInput$Shape;
  noPartialInputMessage: NoPartialInputMessageInput$Shape;
};

export const ParentMessageInput$Ref: InputObjectRef<ParentMessageInput$Shape> =
  builder.inputRef<ParentMessageInput$Shape>("ParentMessageInput").implement(
    {
      fields: (t) => ({
        partialableInputMessage: t.field({
          type: PartialableInputMessageInput$Ref,
          required: true,
          description: "Required.",
          extensions: {
            protobufField: {
              name: "partialable_input_message",
              typeFullName:
                "testapis.extensions.no_partial.PartialableInputMessage",
            },
          },
        }),
        noPartialInputMessage: t.field({
          type: NoPartialInputMessageInput$Ref,
          required: true,
          description: "Required.",
          extensions: {
            protobufField: {
              name: "no_partial_input_message",
              typeFullName:
                "testapis.extensions.no_partial.NoPartialInputMessage",
            },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.extensions.no_partial.ParentMessage",
          name: "ParentMessage",
          package: "testapis.extensions.no_partial",
        },
      },
    },
  );

export function ParentMessageInput$toProto(
  input: ParentMessageInput$Shape | null | undefined,
): ParentMessage {
  return new ParentMessage({
    partialableInputMessage: input?.partialableInputMessage
      ? PartialableInputMessageInput$toProto(input.partialableInputMessage)
      : undefined,
    noPartialInputMessage: input?.noPartialInputMessage
      ? NoPartialInputMessageInput$toProto(input.noPartialInputMessage)
      : undefined,
  });
}

export type ParentMessagePartialInput$Shape = {
  partialableInputMessage?: PartialableInputMessagePartialInput$Shape | null;
  noPartialInputMessage?: NoPartialInputMessageInput$Shape | null;
};

export const ParentMessagePartialInput$Ref: InputObjectRef<
  ParentMessagePartialInput$Shape
> = builder.inputRef<ParentMessagePartialInput$Shape>(
  "ParentMessagePartialInput",
).implement(
  {
    fields: (t) => ({
      partialableInputMessage: t.field({
        type: PartialableInputMessagePartialInput$Ref,
        required: false,
        description: "Required.",
        extensions: {
          protobufField: {
            name: "partialable_input_message",
            typeFullName:
              "testapis.extensions.no_partial.PartialableInputMessage",
          },
        },
      }),
      noPartialInputMessage: t.field({
        type: NoPartialInputMessageInput$Ref,
        required: false,
        description: "Required.",
        extensions: {
          protobufField: {
            name: "no_partial_input_message",
            typeFullName:
              "testapis.extensions.no_partial.NoPartialInputMessage",
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.extensions.no_partial.ParentMessage",
        name: "ParentMessage",
        package: "testapis.extensions.no_partial",
      },
    },
  },
);

export function ParentMessagePartialInput$toProto(
  input: ParentMessagePartialInput$Shape | null | undefined,
): ParentMessage {
  return new ParentMessage({
    partialableInputMessage: input?.partialableInputMessage
      ? PartialableInputMessagePartialInput$toProto(
        input.partialableInputMessage,
      )
      : undefined,
    noPartialInputMessage: input?.noPartialInputMessage
      ? NoPartialInputMessageInput$toProto(input.noPartialInputMessage)
      : undefined,
  });
}

export type PartialableInputMessageInput$Shape = {
  id: PartialableInputMessage["id"];
  body: PartialableInputMessage["body"];
};

export const PartialableInputMessageInput$Ref: InputObjectRef<
  PartialableInputMessageInput$Shape
> = builder.inputRef<PartialableInputMessageInput$Shape>(
  "PartialableInputMessageInput",
).implement(
  {
    fields: (t) => ({
      id: t.field({
        type: "Int64",
        required: true,
        description: "Required.",
        extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
      }),
      body: t.field({
        type: "String",
        required: true,
        description: "Required.",
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.extensions.no_partial.PartialableInputMessage",
        name: "PartialableInputMessage",
        package: "testapis.extensions.no_partial",
      },
    },
  },
);

export function PartialableInputMessageInput$toProto(
  input: PartialableInputMessageInput$Shape | null | undefined,
): PartialableInputMessage {
  return new PartialableInputMessage({
    id: input?.id ?? undefined,
    body: input?.body ?? undefined,
  });
}

export type PartialableInputMessagePartialInput$Shape = {
  id?: PartialableInputMessage["id"] | null;
  body?: PartialableInputMessage["body"] | null;
};

export const PartialableInputMessagePartialInput$Ref: InputObjectRef<
  PartialableInputMessagePartialInput$Shape
> = builder.inputRef<PartialableInputMessagePartialInput$Shape>(
  "PartialableInputMessagePartialInput",
).implement(
  {
    fields: (t) => ({
      id: t.field({
        type: "Int64",
        required: false,
        description: "Required.",
        extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
      }),
      body: t.field({
        type: "String",
        required: false,
        description: "Required.",
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.extensions.no_partial.PartialableInputMessage",
        name: "PartialableInputMessage",
        package: "testapis.extensions.no_partial",
      },
    },
  },
);

export function PartialableInputMessagePartialInput$toProto(
  input: PartialableInputMessagePartialInput$Shape | null | undefined,
): PartialableInputMessage {
  return new PartialableInputMessage({
    id: input?.id ?? undefined,
    body: input?.body ?? undefined,
  });
}

export type NoPartialInputMessageInput$Shape = {
  id: NoPartialInputMessage["id"];
  body: NoPartialInputMessage["body"];
};

export const NoPartialInputMessageInput$Ref: InputObjectRef<
  NoPartialInputMessageInput$Shape
> = builder.inputRef<NoPartialInputMessageInput$Shape>(
  "NoPartialInputMessageInput",
).implement(
  {
    fields: (t) => ({
      id: t.field({
        type: "Int64",
        required: true,
        description: "Required.",
        extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
      }),
      body: t.field({
        type: "String",
        required: true,
        description: "Required.",
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.extensions.no_partial.NoPartialInputMessage",
        name: "NoPartialInputMessage",
        package: "testapis.extensions.no_partial",
        options: { "[graphql.input_type]": { noPartial: true } },
      },
    },
  },
);

export function NoPartialInputMessageInput$toProto(
  input: NoPartialInputMessageInput$Shape | null | undefined,
): NoPartialInputMessage {
  return new NoPartialInputMessage({
    id: input?.id ?? undefined,
    body: input?.body ?? undefined,
  });
}
",
    "name": "testapis/extensions/no_partial/no_partial.pb.pothos.ts",
  },
]
`;

exports[`protobuf-es > 'testapis.extensions.no_partial' > generates files by plugin 'without import prefix' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/extensions/no_partial/no_partial.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { builder } from "../../../builder";
import {
  NoPartialInputMessage,
  ParentMessage,
  PartialableInputMessage,
} from "./testapis/extensions/no_partial/no_partial_pb";

export const ParentMessage$Ref = builder.objectRef<ParentMessage>(
  "ParentMessage",
);
builder.objectType(ParentMessage$Ref, {
  name: "ParentMessage",
  fields: (t) => ({
    partialableInputMessage: t.field({
      type: PartialableInputMessage$Ref,
      nullable: false,
      description: "Required.",
      resolve: (source) => {
        return source.partialableInputMessage!;
      },
      extensions: {
        protobufField: {
          name: "partialable_input_message",
          typeFullName:
            "testapis.extensions.no_partial.PartialableInputMessage",
        },
      },
    }),
    noPartialInputMessage: t.field({
      type: NoPartialInputMessage$Ref,
      nullable: false,
      description: "Required.",
      resolve: (source) => {
        return source.noPartialInputMessage!;
      },
      extensions: {
        protobufField: {
          name: "no_partial_input_message",
          typeFullName: "testapis.extensions.no_partial.NoPartialInputMessage",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof ParentMessage;
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.no_partial.ParentMessage",
      name: "ParentMessage",
      package: "testapis.extensions.no_partial",
    },
  },
});

export const PartialableInputMessage$Ref = builder.objectRef<
  PartialableInputMessage
>("PartialableInputMessage");
builder.objectType(PartialableInputMessage$Ref, {
  name: "PartialableInputMessage",
  fields: (t) => ({
    id: t.expose("id", {
      type: "Int64",
      nullable: false,
      description: "Required.",
      extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
    }),
    body: t.expose("body", {
      type: "String",
      nullable: false,
      description: "Required.",
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof PartialableInputMessage;
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.no_partial.PartialableInputMessage",
      name: "PartialableInputMessage",
      package: "testapis.extensions.no_partial",
    },
  },
});

export const NoPartialInputMessage$Ref = builder.objectRef<
  NoPartialInputMessage
>("NoPartialInputMessage");
builder.objectType(NoPartialInputMessage$Ref, {
  name: "NoPartialInputMessage",
  fields: (t) => ({
    id: t.expose("id", {
      type: "Int64",
      nullable: false,
      description: "Required.",
      extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
    }),
    body: t.expose("body", {
      type: "String",
      nullable: false,
      description: "Required.",
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof NoPartialInputMessage;
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.extensions.no_partial.NoPartialInputMessage",
      name: "NoPartialInputMessage",
      package: "testapis.extensions.no_partial",
      options: { "[graphql.input_type]": { noPartial: true } },
    },
  },
});

export type ParentMessageInput$Shape = {
  partialableInputMessage: PartialableInputMessageInput$Shape;
  noPartialInputMessage: NoPartialInputMessageInput$Shape;
};

export const ParentMessageInput$Ref: InputObjectRef<ParentMessageInput$Shape> =
  builder.inputRef<ParentMessageInput$Shape>("ParentMessageInput").implement(
    {
      fields: (t) => ({
        partialableInputMessage: t.field({
          type: PartialableInputMessageInput$Ref,
          required: true,
          description: "Required.",
          extensions: {
            protobufField: {
              name: "partialable_input_message",
              typeFullName:
                "testapis.extensions.no_partial.PartialableInputMessage",
            },
          },
        }),
        noPartialInputMessage: t.field({
          type: NoPartialInputMessageInput$Ref,
          required: true,
          description: "Required.",
          extensions: {
            protobufField: {
              name: "no_partial_input_message",
              typeFullName:
                "testapis.extensions.no_partial.NoPartialInputMessage",
            },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.extensions.no_partial.ParentMessage",
          name: "ParentMessage",
          package: "testapis.extensions.no_partial",
        },
      },
    },
  );

export function ParentMessageInput$toProto(
  input: ParentMessageInput$Shape | null | undefined,
): ParentMessage {
  return new ParentMessage({
    partialableInputMessage: input?.partialableInputMessage
      ? PartialableInputMessageInput$toProto(input.partialableInputMessage)
      : undefined,
    noPartialInputMessage: input?.noPartialInputMessage
      ? NoPartialInputMessageInput$toProto(input.noPartialInputMessage)
      : undefined,
  });
}

export type PartialableInputMessageInput$Shape = {
  id: PartialableInputMessage["id"];
  body: PartialableInputMessage["body"];
};

export const PartialableInputMessageInput$Ref: InputObjectRef<
  PartialableInputMessageInput$Shape
> = builder.inputRef<PartialableInputMessageInput$Shape>(
  "PartialableInputMessageInput",
).implement(
  {
    fields: (t) => ({
      id: t.field({
        type: "Int64",
        required: true,
        description: "Required.",
        extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
      }),
      body: t.field({
        type: "String",
        required: true,
        description: "Required.",
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.extensions.no_partial.PartialableInputMessage",
        name: "PartialableInputMessage",
        package: "testapis.extensions.no_partial",
      },
    },
  },
);

export function PartialableInputMessageInput$toProto(
  input: PartialableInputMessageInput$Shape | null | undefined,
): PartialableInputMessage {
  return new PartialableInputMessage({
    id: input?.id ?? undefined,
    body: input?.body ?? undefined,
  });
}

export type NoPartialInputMessageInput$Shape = {
  id: NoPartialInputMessage["id"];
  body: NoPartialInputMessage["body"];
};

export const NoPartialInputMessageInput$Ref: InputObjectRef<
  NoPartialInputMessageInput$Shape
> = builder.inputRef<NoPartialInputMessageInput$Shape>(
  "NoPartialInputMessageInput",
).implement(
  {
    fields: (t) => ({
      id: t.field({
        type: "Int64",
        required: true,
        description: "Required.",
        extensions: { protobufField: { name: "id", typeFullName: "uint64" } },
      }),
      body: t.field({
        type: "String",
        required: true,
        description: "Required.",
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.extensions.no_partial.NoPartialInputMessage",
        name: "NoPartialInputMessage",
        package: "testapis.extensions.no_partial",
        options: { "[graphql.input_type]": { noPartial: true } },
      },
    },
  },
);

export function NoPartialInputMessageInput$toProto(
  input: NoPartialInputMessageInput$Shape | null | undefined,
): NoPartialInputMessage {
  return new NoPartialInputMessage({
    id: input?.id ?? undefined,
    body: input?.body ?? undefined,
  });
}
",
    "name": "testapis/extensions/no_partial/no_partial.pb.pothos.ts",
  },
]
`;

exports[`protobuf-es > 'testapis.field_behavior' > generates files by plugin 'with import prefix' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/field_behavior/comments.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import {
  FieldBehaviorComentsMessage,
  FieldBehaviorComentsMessage_Post,
} from "@testapis/protobuf-es/testapis/field_behavior/comments_pb";
import { builder } from "../../builder";

export const FieldBehaviorComentsMessage$Ref = builder.objectRef<
  FieldBehaviorComentsMessage
>("FieldBehaviorComentsMessage");
builder.objectType(FieldBehaviorComentsMessage$Ref, {
  name: "FieldBehaviorComentsMessage",
  fields: (t) => ({
    requiredField: t.field({
      type: FieldBehaviorComentsMessagePost$Ref,
      nullable: false,
      description: "Required.",
      resolve: (source) => {
        return source.requiredField!;
      },
      extensions: {
        protobufField: {
          name: "required_field",
          typeFullName:
            "testapis.field_behavior.FieldBehaviorComentsMessage.Post",
        },
      },
    }),
    requiredOutputOnlyField: t.field({
      type: FieldBehaviorComentsMessagePost$Ref,
      nullable: false,
      description: "Required. Output only.",
      resolve: (source) => {
        return source.requiredOutputOnlyField!;
      },
      extensions: {
        protobufField: {
          name: "required_output_only_field",
          typeFullName:
            "testapis.field_behavior.FieldBehaviorComentsMessage.Post",
        },
      },
    }),
    outputOnlyRequiredField: t.field({
      type: FieldBehaviorComentsMessagePost$Ref,
      nullable: false,
      description: "Output only. Required.",
      resolve: (source) => {
        return source.outputOnlyRequiredField!;
      },
      extensions: {
        protobufField: {
          name: "output_only_required_field",
          typeFullName:
            "testapis.field_behavior.FieldBehaviorComentsMessage.Post",
        },
      },
    }),
    outputOnlyField: t.expose("outputOnlyField", {
      type: FieldBehaviorComentsMessagePost$Ref,
      nullable: true,
      description: "Output only.",
      extensions: {
        protobufField: {
          name: "output_only_field",
          typeFullName:
            "testapis.field_behavior.FieldBehaviorComentsMessage.Post",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof FieldBehaviorComentsMessage;
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.field_behavior.FieldBehaviorComentsMessage",
      name: "FieldBehaviorComentsMessage",
      package: "testapis.field_behavior",
    },
  },
});

export const FieldBehaviorComentsMessagePost$Ref = builder.objectRef<
  FieldBehaviorComentsMessage_Post
>("FieldBehaviorComentsMessagePost");
builder.objectType(FieldBehaviorComentsMessagePost$Ref, {
  name: "FieldBehaviorComentsMessagePost",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof FieldBehaviorComentsMessage_Post;
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.field_behavior.FieldBehaviorComentsMessage.Post",
      name: "Post",
      package: "testapis.field_behavior",
    },
  },
});

export type FieldBehaviorComentsMessageInput$Shape = {
  requiredField: FieldBehaviorComentsMessagePostInput$Shape;
  requiredInputOnlyField: FieldBehaviorComentsMessagePostInput$Shape;
  inputOnlyRequiredField: FieldBehaviorComentsMessagePostInput$Shape;
  inputOnlyField?: FieldBehaviorComentsMessagePostInput$Shape | null;
};

export const FieldBehaviorComentsMessageInput$Ref: InputObjectRef<
  FieldBehaviorComentsMessageInput$Shape
> = builder.inputRef<FieldBehaviorComentsMessageInput$Shape>(
  "FieldBehaviorComentsMessageInput",
).implement(
  {
    fields: (t) => ({
      requiredField: t.field({
        type: FieldBehaviorComentsMessagePostInput$Ref,
        required: true,
        description: "Required.",
        extensions: {
          protobufField: {
            name: "required_field",
            typeFullName:
              "testapis.field_behavior.FieldBehaviorComentsMessage.Post",
          },
        },
      }),
      requiredInputOnlyField: t.field({
        type: FieldBehaviorComentsMessagePostInput$Ref,
        required: true,
        description: "Required. Input only.",
        extensions: {
          protobufField: {
            name: "required_input_only_field",
            typeFullName:
              "testapis.field_behavior.FieldBehaviorComentsMessage.Post",
          },
        },
      }),
      inputOnlyRequiredField: t.field({
        type: FieldBehaviorComentsMessagePostInput$Ref,
        required: true,
        description: "Input only. Required.",
        extensions: {
          protobufField: {
            name: "input_only_required_field",
            typeFullName:
              "testapis.field_behavior.FieldBehaviorComentsMessage.Post",
          },
        },
      }),
      inputOnlyField: t.field({
        type: FieldBehaviorComentsMessagePostInput$Ref,
        required: false,
        description: "Input only.",
        extensions: {
          protobufField: {
            name: "input_only_field",
            typeFullName:
              "testapis.field_behavior.FieldBehaviorComentsMessage.Post",
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.field_behavior.FieldBehaviorComentsMessage",
        name: "FieldBehaviorComentsMessage",
        package: "testapis.field_behavior",
      },
    },
  },
);

export function FieldBehaviorComentsMessageInput$toProto(
  input: FieldBehaviorComentsMessageInput$Shape | null | undefined,
): FieldBehaviorComentsMessage {
  return new FieldBehaviorComentsMessage({
    requiredField: input?.requiredField
      ? FieldBehaviorComentsMessagePostInput$toProto(input.requiredField)
      : undefined,
    requiredInputOnlyField: input?.requiredInputOnlyField
      ? FieldBehaviorComentsMessagePostInput$toProto(
        input.requiredInputOnlyField,
      )
      : undefined,
    inputOnlyRequiredField: input?.inputOnlyRequiredField
      ? FieldBehaviorComentsMessagePostInput$toProto(
        input.inputOnlyRequiredField,
      )
      : undefined,
    inputOnlyField: input?.inputOnlyField
      ? FieldBehaviorComentsMessagePostInput$toProto(input.inputOnlyField)
      : undefined,
  });
}

export type FieldBehaviorComentsMessagePostInput$Shape = {
  body: FieldBehaviorComentsMessage_Post["body"];
};

export const FieldBehaviorComentsMessagePostInput$Ref: InputObjectRef<
  FieldBehaviorComentsMessagePostInput$Shape
> = builder.inputRef<FieldBehaviorComentsMessagePostInput$Shape>(
  "FieldBehaviorComentsMessagePostInput",
).implement(
  {
    fields: (t) => ({
      body: t.field({
        type: "String",
        required: true,
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.field_behavior.FieldBehaviorComentsMessage.Post",
        name: "Post",
        package: "testapis.field_behavior",
      },
    },
  },
);

export function FieldBehaviorComentsMessagePostInput$toProto(
  input: FieldBehaviorComentsMessagePostInput$Shape | null | undefined,
): FieldBehaviorComentsMessage_Post {
  return new FieldBehaviorComentsMessage_Post({
    body: input?.body ?? undefined,
  });
}
",
    "name": "testapis/field_behavior/comments.pb.pothos.ts",
  },
]
`;

exports[`protobuf-es > 'testapis.field_behavior' > generates files by plugin 'with partial inputs' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/field_behavior/comments.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import {
  FieldBehaviorComentsMessage,
  FieldBehaviorComentsMessage_Post,
} from "@testapis/protobuf-es/testapis/field_behavior/comments_pb";
import { builder } from "../../builder";

export const FieldBehaviorComentsMessage$Ref = builder.objectRef<
  FieldBehaviorComentsMessage
>("FieldBehaviorComentsMessage");
builder.objectType(FieldBehaviorComentsMessage$Ref, {
  name: "FieldBehaviorComentsMessage",
  fields: (t) => ({
    requiredField: t.field({
      type: FieldBehaviorComentsMessagePost$Ref,
      nullable: false,
      description: "Required.",
      resolve: (source) => {
        return source.requiredField!;
      },
      extensions: {
        protobufField: {
          name: "required_field",
          typeFullName:
            "testapis.field_behavior.FieldBehaviorComentsMessage.Post",
        },
      },
    }),
    requiredOutputOnlyField: t.field({
      type: FieldBehaviorComentsMessagePost$Ref,
      nullable: false,
      description: "Required. Output only.",
      resolve: (source) => {
        return source.requiredOutputOnlyField!;
      },
      extensions: {
        protobufField: {
          name: "required_output_only_field",
          typeFullName:
            "testapis.field_behavior.FieldBehaviorComentsMessage.Post",
        },
      },
    }),
    outputOnlyRequiredField: t.field({
      type: FieldBehaviorComentsMessagePost$Ref,
      nullable: false,
      description: "Output only. Required.",
      resolve: (source) => {
        return source.outputOnlyRequiredField!;
      },
      extensions: {
        protobufField: {
          name: "output_only_required_field",
          typeFullName:
            "testapis.field_behavior.FieldBehaviorComentsMessage.Post",
        },
      },
    }),
    outputOnlyField: t.expose("outputOnlyField", {
      type: FieldBehaviorComentsMessagePost$Ref,
      nullable: true,
      description: "Output only.",
      extensions: {
        protobufField: {
          name: "output_only_field",
          typeFullName:
            "testapis.field_behavior.FieldBehaviorComentsMessage.Post",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof FieldBehaviorComentsMessage;
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.field_behavior.FieldBehaviorComentsMessage",
      name: "FieldBehaviorComentsMessage",
      package: "testapis.field_behavior",
    },
  },
});

export const FieldBehaviorComentsMessagePost$Ref = builder.objectRef<
  FieldBehaviorComentsMessage_Post
>("FieldBehaviorComentsMessagePost");
builder.objectType(FieldBehaviorComentsMessagePost$Ref, {
  name: "FieldBehaviorComentsMessagePost",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof FieldBehaviorComentsMessage_Post;
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.field_behavior.FieldBehaviorComentsMessage.Post",
      name: "Post",
      package: "testapis.field_behavior",
    },
  },
});

export type FieldBehaviorComentsMessageInput$Shape = {
  requiredField: FieldBehaviorComentsMessagePostInput$Shape;
  requiredInputOnlyField: FieldBehaviorComentsMessagePostInput$Shape;
  inputOnlyRequiredField: FieldBehaviorComentsMessagePostInput$Shape;
  inputOnlyField?: FieldBehaviorComentsMessagePostInput$Shape | null;
};

export const FieldBehaviorComentsMessageInput$Ref: InputObjectRef<
  FieldBehaviorComentsMessageInput$Shape
> = builder.inputRef<FieldBehaviorComentsMessageInput$Shape>(
  "FieldBehaviorComentsMessageInput",
).implement(
  {
    fields: (t) => ({
      requiredField: t.field({
        type: FieldBehaviorComentsMessagePostInput$Ref,
        required: true,
        description: "Required.",
        extensions: {
          protobufField: {
            name: "required_field",
            typeFullName:
              "testapis.field_behavior.FieldBehaviorComentsMessage.Post",
          },
        },
      }),
      requiredInputOnlyField: t.field({
        type: FieldBehaviorComentsMessagePostInput$Ref,
        required: true,
        description: "Required. Input only.",
        extensions: {
          protobufField: {
            name: "required_input_only_field",
            typeFullName:
              "testapis.field_behavior.FieldBehaviorComentsMessage.Post",
          },
        },
      }),
      inputOnlyRequiredField: t.field({
        type: FieldBehaviorComentsMessagePostInput$Ref,
        required: true,
        description: "Input only. Required.",
        extensions: {
          protobufField: {
            name: "input_only_required_field",
            typeFullName:
              "testapis.field_behavior.FieldBehaviorComentsMessage.Post",
          },
        },
      }),
      inputOnlyField: t.field({
        type: FieldBehaviorComentsMessagePostInput$Ref,
        required: false,
        description: "Input only.",
        extensions: {
          protobufField: {
            name: "input_only_field",
            typeFullName:
              "testapis.field_behavior.FieldBehaviorComentsMessage.Post",
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.field_behavior.FieldBehaviorComentsMessage",
        name: "FieldBehaviorComentsMessage",
        package: "testapis.field_behavior",
      },
    },
  },
);

export function FieldBehaviorComentsMessageInput$toProto(
  input: FieldBehaviorComentsMessageInput$Shape | null | undefined,
): FieldBehaviorComentsMessage {
  return new FieldBehaviorComentsMessage({
    requiredField: input?.requiredField
      ? FieldBehaviorComentsMessagePostInput$toProto(input.requiredField)
      : undefined,
    requiredInputOnlyField: input?.requiredInputOnlyField
      ? FieldBehaviorComentsMessagePostInput$toProto(
        input.requiredInputOnlyField,
      )
      : undefined,
    inputOnlyRequiredField: input?.inputOnlyRequiredField
      ? FieldBehaviorComentsMessagePostInput$toProto(
        input.inputOnlyRequiredField,
      )
      : undefined,
    inputOnlyField: input?.inputOnlyField
      ? FieldBehaviorComentsMessagePostInput$toProto(input.inputOnlyField)
      : undefined,
  });
}

export type FieldBehaviorComentsMessagePartialInput$Shape = {
  requiredField?: FieldBehaviorComentsMessagePostPartialInput$Shape | null;
  requiredInputOnlyField?:
    | FieldBehaviorComentsMessagePostPartialInput$Shape
    | null;
  inputOnlyRequiredField?:
    | FieldBehaviorComentsMessagePostPartialInput$Shape
    | null;
  inputOnlyField?: FieldBehaviorComentsMessagePostPartialInput$Shape | null;
};

export const FieldBehaviorComentsMessagePartialInput$Ref: InputObjectRef<
  FieldBehaviorComentsMessagePartialInput$Shape
> = builder.inputRef<FieldBehaviorComentsMessagePartialInput$Shape>(
  "FieldBehaviorComentsMessagePartialInput",
).implement(
  {
    fields: (t) => ({
      requiredField: t.field({
        type: FieldBehaviorComentsMessagePostPartialInput$Ref,
        required: false,
        description: "Required.",
        extensions: {
          protobufField: {
            name: "required_field",
            typeFullName:
              "testapis.field_behavior.FieldBehaviorComentsMessage.Post",
          },
        },
      }),
      requiredInputOnlyField: t.field({
        type: FieldBehaviorComentsMessagePostPartialInput$Ref,
        required: false,
        description: "Required. Input only.",
        extensions: {
          protobufField: {
            name: "required_input_only_field",
            typeFullName:
              "testapis.field_behavior.FieldBehaviorComentsMessage.Post",
          },
        },
      }),
      inputOnlyRequiredField: t.field({
        type: FieldBehaviorComentsMessagePostPartialInput$Ref,
        required: false,
        description: "Input only. Required.",
        extensions: {
          protobufField: {
            name: "input_only_required_field",
            typeFullName:
              "testapis.field_behavior.FieldBehaviorComentsMessage.Post",
          },
        },
      }),
      inputOnlyField: t.field({
        type: FieldBehaviorComentsMessagePostPartialInput$Ref,
        required: false,
        description: "Input only.",
        extensions: {
          protobufField: {
            name: "input_only_field",
            typeFullName:
              "testapis.field_behavior.FieldBehaviorComentsMessage.Post",
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.field_behavior.FieldBehaviorComentsMessage",
        name: "FieldBehaviorComentsMessage",
        package: "testapis.field_behavior",
      },
    },
  },
);

export function FieldBehaviorComentsMessagePartialInput$toProto(
  input: FieldBehaviorComentsMessagePartialInput$Shape | null | undefined,
): FieldBehaviorComentsMessage {
  return new FieldBehaviorComentsMessage({
    requiredField: input?.requiredField
      ? FieldBehaviorComentsMessagePostPartialInput$toProto(input.requiredField)
      : undefined,
    requiredInputOnlyField: input?.requiredInputOnlyField
      ? FieldBehaviorComentsMessagePostPartialInput$toProto(
        input.requiredInputOnlyField,
      )
      : undefined,
    inputOnlyRequiredField: input?.inputOnlyRequiredField
      ? FieldBehaviorComentsMessagePostPartialInput$toProto(
        input.inputOnlyRequiredField,
      )
      : undefined,
    inputOnlyField: input?.inputOnlyField
      ? FieldBehaviorComentsMessagePostPartialInput$toProto(
        input.inputOnlyField,
      )
      : undefined,
  });
}

export type FieldBehaviorComentsMessagePostInput$Shape = {
  body: FieldBehaviorComentsMessage_Post["body"];
};

export const FieldBehaviorComentsMessagePostInput$Ref: InputObjectRef<
  FieldBehaviorComentsMessagePostInput$Shape
> = builder.inputRef<FieldBehaviorComentsMessagePostInput$Shape>(
  "FieldBehaviorComentsMessagePostInput",
).implement(
  {
    fields: (t) => ({
      body: t.field({
        type: "String",
        required: true,
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.field_behavior.FieldBehaviorComentsMessage.Post",
        name: "Post",
        package: "testapis.field_behavior",
      },
    },
  },
);

export function FieldBehaviorComentsMessagePostInput$toProto(
  input: FieldBehaviorComentsMessagePostInput$Shape | null | undefined,
): FieldBehaviorComentsMessage_Post {
  return new FieldBehaviorComentsMessage_Post({
    body: input?.body ?? undefined,
  });
}

export type FieldBehaviorComentsMessagePostPartialInput$Shape = {
  body?: FieldBehaviorComentsMessage_Post["body"] | null;
};

export const FieldBehaviorComentsMessagePostPartialInput$Ref: InputObjectRef<
  FieldBehaviorComentsMessagePostPartialInput$Shape
> = builder.inputRef<FieldBehaviorComentsMessagePostPartialInput$Shape>(
  "FieldBehaviorComentsMessagePostPartialInput",
).implement(
  {
    fields: (t) => ({
      body: t.field({
        type: "String",
        required: false,
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.field_behavior.FieldBehaviorComentsMessage.Post",
        name: "Post",
        package: "testapis.field_behavior",
      },
    },
  },
);

export function FieldBehaviorComentsMessagePostPartialInput$toProto(
  input: FieldBehaviorComentsMessagePostPartialInput$Shape | null | undefined,
): FieldBehaviorComentsMessage_Post {
  return new FieldBehaviorComentsMessage_Post({
    body: input?.body ?? undefined,
  });
}
",
    "name": "testapis/field_behavior/comments.pb.pothos.ts",
  },
]
`;

exports[`protobuf-es > 'testapis.field_behavior' > generates files by plugin 'without import prefix' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/field_behavior/comments.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { builder } from "../../builder";
import {
  FieldBehaviorComentsMessage,
  FieldBehaviorComentsMessage_Post,
} from "./testapis/field_behavior/comments_pb";

export const FieldBehaviorComentsMessage$Ref = builder.objectRef<
  FieldBehaviorComentsMessage
>("FieldBehaviorComentsMessage");
builder.objectType(FieldBehaviorComentsMessage$Ref, {
  name: "FieldBehaviorComentsMessage",
  fields: (t) => ({
    requiredField: t.field({
      type: FieldBehaviorComentsMessagePost$Ref,
      nullable: false,
      description: "Required.",
      resolve: (source) => {
        return source.requiredField!;
      },
      extensions: {
        protobufField: {
          name: "required_field",
          typeFullName:
            "testapis.field_behavior.FieldBehaviorComentsMessage.Post",
        },
      },
    }),
    requiredOutputOnlyField: t.field({
      type: FieldBehaviorComentsMessagePost$Ref,
      nullable: false,
      description: "Required. Output only.",
      resolve: (source) => {
        return source.requiredOutputOnlyField!;
      },
      extensions: {
        protobufField: {
          name: "required_output_only_field",
          typeFullName:
            "testapis.field_behavior.FieldBehaviorComentsMessage.Post",
        },
      },
    }),
    outputOnlyRequiredField: t.field({
      type: FieldBehaviorComentsMessagePost$Ref,
      nullable: false,
      description: "Output only. Required.",
      resolve: (source) => {
        return source.outputOnlyRequiredField!;
      },
      extensions: {
        protobufField: {
          name: "output_only_required_field",
          typeFullName:
            "testapis.field_behavior.FieldBehaviorComentsMessage.Post",
        },
      },
    }),
    outputOnlyField: t.expose("outputOnlyField", {
      type: FieldBehaviorComentsMessagePost$Ref,
      nullable: true,
      description: "Output only.",
      extensions: {
        protobufField: {
          name: "output_only_field",
          typeFullName:
            "testapis.field_behavior.FieldBehaviorComentsMessage.Post",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof FieldBehaviorComentsMessage;
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.field_behavior.FieldBehaviorComentsMessage",
      name: "FieldBehaviorComentsMessage",
      package: "testapis.field_behavior",
    },
  },
});

export const FieldBehaviorComentsMessagePost$Ref = builder.objectRef<
  FieldBehaviorComentsMessage_Post
>("FieldBehaviorComentsMessagePost");
builder.objectType(FieldBehaviorComentsMessagePost$Ref, {
  name: "FieldBehaviorComentsMessagePost",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof FieldBehaviorComentsMessage_Post;
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.field_behavior.FieldBehaviorComentsMessage.Post",
      name: "Post",
      package: "testapis.field_behavior",
    },
  },
});

export type FieldBehaviorComentsMessageInput$Shape = {
  requiredField: FieldBehaviorComentsMessagePostInput$Shape;
  requiredInputOnlyField: FieldBehaviorComentsMessagePostInput$Shape;
  inputOnlyRequiredField: FieldBehaviorComentsMessagePostInput$Shape;
  inputOnlyField?: FieldBehaviorComentsMessagePostInput$Shape | null;
};

export const FieldBehaviorComentsMessageInput$Ref: InputObjectRef<
  FieldBehaviorComentsMessageInput$Shape
> = builder.inputRef<FieldBehaviorComentsMessageInput$Shape>(
  "FieldBehaviorComentsMessageInput",
).implement(
  {
    fields: (t) => ({
      requiredField: t.field({
        type: FieldBehaviorComentsMessagePostInput$Ref,
        required: true,
        description: "Required.",
        extensions: {
          protobufField: {
            name: "required_field",
            typeFullName:
              "testapis.field_behavior.FieldBehaviorComentsMessage.Post",
          },
        },
      }),
      requiredInputOnlyField: t.field({
        type: FieldBehaviorComentsMessagePostInput$Ref,
        required: true,
        description: "Required. Input only.",
        extensions: {
          protobufField: {
            name: "required_input_only_field",
            typeFullName:
              "testapis.field_behavior.FieldBehaviorComentsMessage.Post",
          },
        },
      }),
      inputOnlyRequiredField: t.field({
        type: FieldBehaviorComentsMessagePostInput$Ref,
        required: true,
        description: "Input only. Required.",
        extensions: {
          protobufField: {
            name: "input_only_required_field",
            typeFullName:
              "testapis.field_behavior.FieldBehaviorComentsMessage.Post",
          },
        },
      }),
      inputOnlyField: t.field({
        type: FieldBehaviorComentsMessagePostInput$Ref,
        required: false,
        description: "Input only.",
        extensions: {
          protobufField: {
            name: "input_only_field",
            typeFullName:
              "testapis.field_behavior.FieldBehaviorComentsMessage.Post",
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.field_behavior.FieldBehaviorComentsMessage",
        name: "FieldBehaviorComentsMessage",
        package: "testapis.field_behavior",
      },
    },
  },
);

export function FieldBehaviorComentsMessageInput$toProto(
  input: FieldBehaviorComentsMessageInput$Shape | null | undefined,
): FieldBehaviorComentsMessage {
  return new FieldBehaviorComentsMessage({
    requiredField: input?.requiredField
      ? FieldBehaviorComentsMessagePostInput$toProto(input.requiredField)
      : undefined,
    requiredInputOnlyField: input?.requiredInputOnlyField
      ? FieldBehaviorComentsMessagePostInput$toProto(
        input.requiredInputOnlyField,
      )
      : undefined,
    inputOnlyRequiredField: input?.inputOnlyRequiredField
      ? FieldBehaviorComentsMessagePostInput$toProto(
        input.inputOnlyRequiredField,
      )
      : undefined,
    inputOnlyField: input?.inputOnlyField
      ? FieldBehaviorComentsMessagePostInput$toProto(input.inputOnlyField)
      : undefined,
  });
}

export type FieldBehaviorComentsMessagePostInput$Shape = {
  body: FieldBehaviorComentsMessage_Post["body"];
};

export const FieldBehaviorComentsMessagePostInput$Ref: InputObjectRef<
  FieldBehaviorComentsMessagePostInput$Shape
> = builder.inputRef<FieldBehaviorComentsMessagePostInput$Shape>(
  "FieldBehaviorComentsMessagePostInput",
).implement(
  {
    fields: (t) => ({
      body: t.field({
        type: "String",
        required: true,
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.field_behavior.FieldBehaviorComentsMessage.Post",
        name: "Post",
        package: "testapis.field_behavior",
      },
    },
  },
);

export function FieldBehaviorComentsMessagePostInput$toProto(
  input: FieldBehaviorComentsMessagePostInput$Shape | null | undefined,
): FieldBehaviorComentsMessage_Post {
  return new FieldBehaviorComentsMessage_Post({
    body: input?.body ?? undefined,
  });
}
",
    "name": "testapis/field_behavior/comments.pb.pothos.ts",
  },
]
`;

exports[`protobuf-es > 'testapis.multipkgs' > generates files by plugin 'with import prefix' 1`] = `[]`;

exports[`protobuf-es > 'testapis.multipkgs' > generates files by plugin 'with partial inputs' 1`] = `[]`;

exports[`protobuf-es > 'testapis.multipkgs' > generates files by plugin 'without import prefix' 1`] = `[]`;

exports[`protobuf-es > 'testapis.multipkgs.subpkg1' > generates files by plugin 'with import prefix' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/multipkgs/subpkg1/types.proto

/* eslint-disable */

import { EnumRef, InputObjectRef } from "@pothos/core";
import {
  SubpkgEnum,
  SubpkgMessage,
} from "@testapis/protobuf-es/testapis/multipkgs/subpkg1/types_pb";
import { builder } from "../../../builder";

export const SubpkgMessage$Ref = builder.objectRef<SubpkgMessage>(
  "SubpkgMessage",
);
builder.objectType(SubpkgMessage$Ref, {
  name: "SubpkgMessage",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof SubpkgMessage;
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.multipkgs.subpkg1.SubpkgMessage",
      name: "SubpkgMessage",
      package: "testapis.multipkgs.subpkg1",
    },
  },
});

export type SubpkgMessageInput$Shape = {
  body: SubpkgMessage["body"];
};

export const SubpkgMessageInput$Ref: InputObjectRef<SubpkgMessageInput$Shape> =
  builder.inputRef<SubpkgMessageInput$Shape>("SubpkgMessageInput").implement(
    {
      fields: (t) => ({
        body: t.field({
          type: "String",
          required: true,
          extensions: {
            protobufField: { name: "body", typeFullName: "string" },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.multipkgs.subpkg1.SubpkgMessage",
          name: "SubpkgMessage",
          package: "testapis.multipkgs.subpkg1",
        },
      },
    },
  );

export function SubpkgMessageInput$toProto(
  input: SubpkgMessageInput$Shape | null | undefined,
): SubpkgMessage {
  return new SubpkgMessage({
    body: input?.body ?? undefined,
  });
}

export const SubpkgEnum$Ref: EnumRef<SubpkgEnum, SubpkgEnum> = builder.enumType(
  "SubpkgEnum",
  {
    values: {
      FOO: { value: 1, extensions: { protobufEnumValue: { name: "FOO" } } },
      BAR: { value: 2, extensions: { protobufEnumValue: { name: "BAR" } } },
    } as const,
    extensions: {
      protobufEnum: {
        name: "SubpkgEnum",
        fullName: "testapis.multipkgs.subpkg1.SubpkgEnum",
        package: "testapis.multipkgs.subpkg1",
      },
    },
  },
);
",
    "name": "testapis/multipkgs/subpkg1/types.pb.pothos.ts",
  },
]
`;

exports[`protobuf-es > 'testapis.multipkgs.subpkg1' > generates files by plugin 'with partial inputs' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/multipkgs/subpkg1/types.proto

/* eslint-disable */

import { EnumRef, InputObjectRef } from "@pothos/core";
import {
  SubpkgEnum,
  SubpkgMessage,
} from "@testapis/protobuf-es/testapis/multipkgs/subpkg1/types_pb";
import { builder } from "../../../builder";

export const SubpkgMessage$Ref = builder.objectRef<SubpkgMessage>(
  "SubpkgMessage",
);
builder.objectType(SubpkgMessage$Ref, {
  name: "SubpkgMessage",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof SubpkgMessage;
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.multipkgs.subpkg1.SubpkgMessage",
      name: "SubpkgMessage",
      package: "testapis.multipkgs.subpkg1",
    },
  },
});

export type SubpkgMessageInput$Shape = {
  body: SubpkgMessage["body"];
};

export const SubpkgMessageInput$Ref: InputObjectRef<SubpkgMessageInput$Shape> =
  builder.inputRef<SubpkgMessageInput$Shape>("SubpkgMessageInput").implement(
    {
      fields: (t) => ({
        body: t.field({
          type: "String",
          required: true,
          extensions: {
            protobufField: { name: "body", typeFullName: "string" },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.multipkgs.subpkg1.SubpkgMessage",
          name: "SubpkgMessage",
          package: "testapis.multipkgs.subpkg1",
        },
      },
    },
  );

export function SubpkgMessageInput$toProto(
  input: SubpkgMessageInput$Shape | null | undefined,
): SubpkgMessage {
  return new SubpkgMessage({
    body: input?.body ?? undefined,
  });
}

export type SubpkgMessagePartialInput$Shape = {
  body?: SubpkgMessage["body"] | null;
};

export const SubpkgMessagePartialInput$Ref: InputObjectRef<
  SubpkgMessagePartialInput$Shape
> = builder.inputRef<SubpkgMessagePartialInput$Shape>(
  "SubpkgMessagePartialInput",
).implement(
  {
    fields: (t) => ({
      body: t.field({
        type: "String",
        required: false,
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.multipkgs.subpkg1.SubpkgMessage",
        name: "SubpkgMessage",
        package: "testapis.multipkgs.subpkg1",
      },
    },
  },
);

export function SubpkgMessagePartialInput$toProto(
  input: SubpkgMessagePartialInput$Shape | null | undefined,
): SubpkgMessage {
  return new SubpkgMessage({
    body: input?.body ?? undefined,
  });
}

export const SubpkgEnum$Ref: EnumRef<SubpkgEnum, SubpkgEnum> = builder.enumType(
  "SubpkgEnum",
  {
    values: {
      FOO: { value: 1, extensions: { protobufEnumValue: { name: "FOO" } } },
      BAR: { value: 2, extensions: { protobufEnumValue: { name: "BAR" } } },
    } as const,
    extensions: {
      protobufEnum: {
        name: "SubpkgEnum",
        fullName: "testapis.multipkgs.subpkg1.SubpkgEnum",
        package: "testapis.multipkgs.subpkg1",
      },
    },
  },
);
",
    "name": "testapis/multipkgs/subpkg1/types.pb.pothos.ts",
  },
]
`;

exports[`protobuf-es > 'testapis.multipkgs.subpkg1' > generates files by plugin 'without import prefix' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/multipkgs/subpkg1/types.proto

/* eslint-disable */

import { EnumRef, InputObjectRef } from "@pothos/core";
import { builder } from "../../../builder";
import {
  SubpkgEnum,
  SubpkgMessage,
} from "./testapis/multipkgs/subpkg1/types_pb";

export const SubpkgMessage$Ref = builder.objectRef<SubpkgMessage>(
  "SubpkgMessage",
);
builder.objectType(SubpkgMessage$Ref, {
  name: "SubpkgMessage",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof SubpkgMessage;
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.multipkgs.subpkg1.SubpkgMessage",
      name: "SubpkgMessage",
      package: "testapis.multipkgs.subpkg1",
    },
  },
});

export type SubpkgMessageInput$Shape = {
  body: SubpkgMessage["body"];
};

export const SubpkgMessageInput$Ref: InputObjectRef<SubpkgMessageInput$Shape> =
  builder.inputRef<SubpkgMessageInput$Shape>("SubpkgMessageInput").implement(
    {
      fields: (t) => ({
        body: t.field({
          type: "String",
          required: true,
          extensions: {
            protobufField: { name: "body", typeFullName: "string" },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.multipkgs.subpkg1.SubpkgMessage",
          name: "SubpkgMessage",
          package: "testapis.multipkgs.subpkg1",
        },
      },
    },
  );

export function SubpkgMessageInput$toProto(
  input: SubpkgMessageInput$Shape | null | undefined,
): SubpkgMessage {
  return new SubpkgMessage({
    body: input?.body ?? undefined,
  });
}

export const SubpkgEnum$Ref: EnumRef<SubpkgEnum, SubpkgEnum> = builder.enumType(
  "SubpkgEnum",
  {
    values: {
      FOO: { value: 1, extensions: { protobufEnumValue: { name: "FOO" } } },
      BAR: { value: 2, extensions: { protobufEnumValue: { name: "BAR" } } },
    } as const,
    extensions: {
      protobufEnum: {
        name: "SubpkgEnum",
        fullName: "testapis.multipkgs.subpkg1.SubpkgEnum",
        package: "testapis.multipkgs.subpkg1",
      },
    },
  },
);
",
    "name": "testapis/multipkgs/subpkg1/types.pb.pothos.ts",
  },
]
`;

exports[`protobuf-es > 'testapis.multipkgs.subpkg2' > generates files by plugin 'with import prefix' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/multipkgs/subpkg2/types.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { SubpkgEnum } from "@testapis/protobuf-es/testapis/multipkgs/subpkg1/types_pb";
import { MessageWithSubpkg } from "@testapis/protobuf-es/testapis/multipkgs/subpkg2/types_pb";
import { builder } from "../../../builder";
import {
  SubpkgEnum$Ref,
  SubpkgMessage$Ref,
  SubpkgMessageInput$Ref,
  SubpkgMessageInput$Shape,
  SubpkgMessageInput$toProto,
} from "../subpkg1/types.pb.pothos";

export const MessageWithSubpkg$Ref = builder.objectRef<MessageWithSubpkg>(
  "MessageWithSubpkg",
);
builder.objectType(MessageWithSubpkg$Ref, {
  name: "MessageWithSubpkg",
  fields: (t) => ({
    message: t.expose("message", {
      type: SubpkgMessage$Ref,
      nullable: true,
      extensions: {
        protobufField: {
          name: "message",
          typeFullName: "testapis.multipkgs.subpkg1.SubpkgMessage",
        },
      },
    }),
    enum: t.field({
      type: SubpkgEnum$Ref,
      nullable: true,
      resolve: (source) => {
        if (source.enum === SubpkgEnum.SUBPKG_ENUM_UNSPECIFIED) {
          return null;
        }

        return source.enum;
      },
      extensions: {
        protobufField: {
          name: "enum",
          typeFullName: "testapis.multipkgs.subpkg1.SubpkgEnum",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof MessageWithSubpkg;
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.multipkgs.subpkg1.MessageWithSubpkg",
      name: "MessageWithSubpkg",
      package: "testapis.multipkgs.subpkg1",
    },
  },
});

export type MessageWithSubpkgInput$Shape = {
  message?: SubpkgMessageInput$Shape | null;
  enum?: MessageWithSubpkg["enum"] | null;
};

export const MessageWithSubpkgInput$Ref: InputObjectRef<
  MessageWithSubpkgInput$Shape
> = builder.inputRef<MessageWithSubpkgInput$Shape>("MessageWithSubpkgInput")
  .implement(
    {
      fields: (t) => ({
        message: t.field({
          type: SubpkgMessageInput$Ref,
          required: false,
          extensions: {
            protobufField: {
              name: "message",
              typeFullName: "testapis.multipkgs.subpkg1.SubpkgMessage",
            },
          },
        }),
        enum: t.field({
          type: SubpkgEnum$Ref,
          required: false,
          extensions: {
            protobufField: {
              name: "enum",
              typeFullName: "testapis.multipkgs.subpkg1.SubpkgEnum",
            },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.multipkgs.subpkg1.MessageWithSubpkg",
          name: "MessageWithSubpkg",
          package: "testapis.multipkgs.subpkg1",
        },
      },
    },
  );

export function MessageWithSubpkgInput$toProto(
  input: MessageWithSubpkgInput$Shape | null | undefined,
): MessageWithSubpkg {
  return new MessageWithSubpkg({
    message: input?.message
      ? SubpkgMessageInput$toProto(input.message)
      : undefined,
    enum: input?.enum ?? undefined,
  });
}
",
    "name": "testapis/multipkgs/subpkg2/types.pb.pothos.ts",
  },
]
`;

exports[`protobuf-es > 'testapis.multipkgs.subpkg2' > generates files by plugin 'with partial inputs' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/multipkgs/subpkg2/types.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { SubpkgEnum } from "@testapis/protobuf-es/testapis/multipkgs/subpkg1/types_pb";
import { MessageWithSubpkg } from "@testapis/protobuf-es/testapis/multipkgs/subpkg2/types_pb";
import { builder } from "../../../builder";
import {
  SubpkgEnum$Ref,
  SubpkgMessage$Ref,
  SubpkgMessageInput$Ref,
  SubpkgMessageInput$Shape,
  SubpkgMessageInput$toProto,
  SubpkgMessagePartialInput$Ref,
  SubpkgMessagePartialInput$Shape,
  SubpkgMessagePartialInput$toProto,
} from "../subpkg1/types.pb.pothos";

export const MessageWithSubpkg$Ref = builder.objectRef<MessageWithSubpkg>(
  "MessageWithSubpkg",
);
builder.objectType(MessageWithSubpkg$Ref, {
  name: "MessageWithSubpkg",
  fields: (t) => ({
    message: t.expose("message", {
      type: SubpkgMessage$Ref,
      nullable: true,
      extensions: {
        protobufField: {
          name: "message",
          typeFullName: "testapis.multipkgs.subpkg1.SubpkgMessage",
        },
      },
    }),
    enum: t.field({
      type: SubpkgEnum$Ref,
      nullable: true,
      resolve: (source) => {
        if (source.enum === SubpkgEnum.SUBPKG_ENUM_UNSPECIFIED) {
          return null;
        }

        return source.enum;
      },
      extensions: {
        protobufField: {
          name: "enum",
          typeFullName: "testapis.multipkgs.subpkg1.SubpkgEnum",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof MessageWithSubpkg;
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.multipkgs.subpkg1.MessageWithSubpkg",
      name: "MessageWithSubpkg",
      package: "testapis.multipkgs.subpkg1",
    },
  },
});

export type MessageWithSubpkgInput$Shape = {
  message?: SubpkgMessageInput$Shape | null;
  enum?: MessageWithSubpkg["enum"] | null;
};

export const MessageWithSubpkgInput$Ref: InputObjectRef<
  MessageWithSubpkgInput$Shape
> = builder.inputRef<MessageWithSubpkgInput$Shape>("MessageWithSubpkgInput")
  .implement(
    {
      fields: (t) => ({
        message: t.field({
          type: SubpkgMessageInput$Ref,
          required: false,
          extensions: {
            protobufField: {
              name: "message",
              typeFullName: "testapis.multipkgs.subpkg1.SubpkgMessage",
            },
          },
        }),
        enum: t.field({
          type: SubpkgEnum$Ref,
          required: false,
          extensions: {
            protobufField: {
              name: "enum",
              typeFullName: "testapis.multipkgs.subpkg1.SubpkgEnum",
            },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.multipkgs.subpkg1.MessageWithSubpkg",
          name: "MessageWithSubpkg",
          package: "testapis.multipkgs.subpkg1",
        },
      },
    },
  );

export function MessageWithSubpkgInput$toProto(
  input: MessageWithSubpkgInput$Shape | null | undefined,
): MessageWithSubpkg {
  return new MessageWithSubpkg({
    message: input?.message
      ? SubpkgMessageInput$toProto(input.message)
      : undefined,
    enum: input?.enum ?? undefined,
  });
}

export type MessageWithSubpkgPartialInput$Shape = {
  message?: SubpkgMessagePartialInput$Shape | null;
  enum?: MessageWithSubpkg["enum"] | null;
};

export const MessageWithSubpkgPartialInput$Ref: InputObjectRef<
  MessageWithSubpkgPartialInput$Shape
> = builder.inputRef<MessageWithSubpkgPartialInput$Shape>(
  "MessageWithSubpkgPartialInput",
).implement(
  {
    fields: (t) => ({
      message: t.field({
        type: SubpkgMessagePartialInput$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "message",
            typeFullName: "testapis.multipkgs.subpkg1.SubpkgMessage",
          },
        },
      }),
      enum: t.field({
        type: SubpkgEnum$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "enum",
            typeFullName: "testapis.multipkgs.subpkg1.SubpkgEnum",
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.multipkgs.subpkg1.MessageWithSubpkg",
        name: "MessageWithSubpkg",
        package: "testapis.multipkgs.subpkg1",
      },
    },
  },
);

export function MessageWithSubpkgPartialInput$toProto(
  input: MessageWithSubpkgPartialInput$Shape | null | undefined,
): MessageWithSubpkg {
  return new MessageWithSubpkg({
    message: input?.message
      ? SubpkgMessagePartialInput$toProto(input.message)
      : undefined,
    enum: input?.enum ?? undefined,
  });
}
",
    "name": "testapis/multipkgs/subpkg2/types.pb.pothos.ts",
  },
]
`;

exports[`protobuf-es > 'testapis.multipkgs.subpkg2' > generates files by plugin 'without import prefix' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/multipkgs/subpkg2/types.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { builder } from "../../../builder";
import {
  SubpkgEnum$Ref,
  SubpkgMessage$Ref,
  SubpkgMessageInput$Ref,
  SubpkgMessageInput$Shape,
  SubpkgMessageInput$toProto,
} from "../subpkg1/types.pb.pothos";
import { SubpkgEnum } from "./testapis/multipkgs/subpkg1/types_pb";
import { MessageWithSubpkg } from "./testapis/multipkgs/subpkg2/types_pb";

export const MessageWithSubpkg$Ref = builder.objectRef<MessageWithSubpkg>(
  "MessageWithSubpkg",
);
builder.objectType(MessageWithSubpkg$Ref, {
  name: "MessageWithSubpkg",
  fields: (t) => ({
    message: t.expose("message", {
      type: SubpkgMessage$Ref,
      nullable: true,
      extensions: {
        protobufField: {
          name: "message",
          typeFullName: "testapis.multipkgs.subpkg1.SubpkgMessage",
        },
      },
    }),
    enum: t.field({
      type: SubpkgEnum$Ref,
      nullable: true,
      resolve: (source) => {
        if (source.enum === SubpkgEnum.SUBPKG_ENUM_UNSPECIFIED) {
          return null;
        }

        return source.enum;
      },
      extensions: {
        protobufField: {
          name: "enum",
          typeFullName: "testapis.multipkgs.subpkg1.SubpkgEnum",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof MessageWithSubpkg;
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.multipkgs.subpkg1.MessageWithSubpkg",
      name: "MessageWithSubpkg",
      package: "testapis.multipkgs.subpkg1",
    },
  },
});

export type MessageWithSubpkgInput$Shape = {
  message?: SubpkgMessageInput$Shape | null;
  enum?: MessageWithSubpkg["enum"] | null;
};

export const MessageWithSubpkgInput$Ref: InputObjectRef<
  MessageWithSubpkgInput$Shape
> = builder.inputRef<MessageWithSubpkgInput$Shape>("MessageWithSubpkgInput")
  .implement(
    {
      fields: (t) => ({
        message: t.field({
          type: SubpkgMessageInput$Ref,
          required: false,
          extensions: {
            protobufField: {
              name: "message",
              typeFullName: "testapis.multipkgs.subpkg1.SubpkgMessage",
            },
          },
        }),
        enum: t.field({
          type: SubpkgEnum$Ref,
          required: false,
          extensions: {
            protobufField: {
              name: "enum",
              typeFullName: "testapis.multipkgs.subpkg1.SubpkgEnum",
            },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.multipkgs.subpkg1.MessageWithSubpkg",
          name: "MessageWithSubpkg",
          package: "testapis.multipkgs.subpkg1",
        },
      },
    },
  );

export function MessageWithSubpkgInput$toProto(
  input: MessageWithSubpkgInput$Shape | null | undefined,
): MessageWithSubpkg {
  return new MessageWithSubpkg({
    message: input?.message
      ? SubpkgMessageInput$toProto(input.message)
      : undefined,
    enum: input?.enum ?? undefined,
  });
}
",
    "name": "testapis/multipkgs/subpkg2/types.pb.pothos.ts",
  },
]
`;

exports[`protobuf-es > 'testapis.nested' > generates files by plugin 'with import prefix' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/nested/nested.proto

/* eslint-disable */

import { EnumRef, InputObjectRef } from "@pothos/core";
import {
  ParentMessage,
  ParentMessage_NestedEnum,
  ParentMessage_NestedMessage,
} from "@testapis/protobuf-es/testapis/nested/nested_pb";
import { builder } from "../../builder";

export const ParentMessage$Ref = builder.objectRef<ParentMessage>(
  "ParentMessage",
);
builder.objectType(ParentMessage$Ref, {
  name: "ParentMessage",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
    nested: t.expose("nested", {
      type: ParentMessageNestedMessage$Ref,
      nullable: true,
      extensions: {
        protobufField: {
          name: "nested",
          typeFullName: "testapis.nested.ParentMessage.NestedMessage",
        },
      },
    }),
    nestedEnum: t.field({
      type: ParentMessageNestedEnum$Ref,
      nullable: true,
      resolve: (source) => {
        if (
          source.nestedEnum === ParentMessage_NestedEnum.NESTED_ENUM_UNSPECIFIED
        ) {
          return null;
        }

        return source.nestedEnum;
      },
      extensions: {
        protobufField: {
          name: "nested_enum",
          typeFullName: "testapis.nested.ParentMessage.NestedEnum",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof ParentMessage;
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.nested.ParentMessage",
      name: "ParentMessage",
      package: "testapis.nested",
    },
  },
});

export const ParentMessageNestedMessage$Ref = builder.objectRef<
  ParentMessage_NestedMessage
>("ParentMessageNestedMessage");
builder.objectType(ParentMessageNestedMessage$Ref, {
  name: "ParentMessageNestedMessage",
  fields: (t) => ({
    nestedBody: t.expose("nestedBody", {
      type: "String",
      nullable: false,
      extensions: {
        protobufField: { name: "nested_body", typeFullName: "string" },
      },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof ParentMessage_NestedMessage;
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.nested.ParentMessage.NestedMessage",
      name: "NestedMessage",
      package: "testapis.nested",
    },
  },
});

export type ParentMessageInput$Shape = {
  body: ParentMessage["body"];
  nested?: ParentMessageNestedMessageInput$Shape | null;
  nestedEnum?: ParentMessage["nestedEnum"] | null;
};

export const ParentMessageInput$Ref: InputObjectRef<ParentMessageInput$Shape> =
  builder.inputRef<ParentMessageInput$Shape>("ParentMessageInput").implement(
    {
      fields: (t) => ({
        body: t.field({
          type: "String",
          required: true,
          extensions: {
            protobufField: { name: "body", typeFullName: "string" },
          },
        }),
        nested: t.field({
          type: ParentMessageNestedMessageInput$Ref,
          required: false,
          extensions: {
            protobufField: {
              name: "nested",
              typeFullName: "testapis.nested.ParentMessage.NestedMessage",
            },
          },
        }),
        nestedEnum: t.field({
          type: ParentMessageNestedEnum$Ref,
          required: false,
          extensions: {
            protobufField: {
              name: "nested_enum",
              typeFullName: "testapis.nested.ParentMessage.NestedEnum",
            },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.nested.ParentMessage",
          name: "ParentMessage",
          package: "testapis.nested",
        },
      },
    },
  );

export function ParentMessageInput$toProto(
  input: ParentMessageInput$Shape | null | undefined,
): ParentMessage {
  return new ParentMessage({
    body: input?.body ?? undefined,
    nested: input?.nested
      ? ParentMessageNestedMessageInput$toProto(input.nested)
      : undefined,
    nestedEnum: input?.nestedEnum ?? undefined,
  });
}

export type ParentMessageNestedMessageInput$Shape = {
  nestedBody: ParentMessage_NestedMessage["nestedBody"];
};

export const ParentMessageNestedMessageInput$Ref: InputObjectRef<
  ParentMessageNestedMessageInput$Shape
> = builder.inputRef<ParentMessageNestedMessageInput$Shape>(
  "ParentMessageNestedMessageInput",
).implement(
  {
    fields: (t) => ({
      nestedBody: t.field({
        type: "String",
        required: true,
        extensions: {
          protobufField: { name: "nested_body", typeFullName: "string" },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.nested.ParentMessage.NestedMessage",
        name: "NestedMessage",
        package: "testapis.nested",
      },
    },
  },
);

export function ParentMessageNestedMessageInput$toProto(
  input: ParentMessageNestedMessageInput$Shape | null | undefined,
): ParentMessage_NestedMessage {
  return new ParentMessage_NestedMessage({
    nestedBody: input?.nestedBody ?? undefined,
  });
}

export const ParentMessageNestedEnum$Ref: EnumRef<
  ParentMessage_NestedEnum,
  ParentMessage_NestedEnum
> = builder.enumType("ParentMessageNestedEnum", {
  values: {
    FOO: { value: 1, extensions: { protobufEnumValue: { name: "FOO" } } },
    BAR: { value: 2, extensions: { protobufEnumValue: { name: "BAR" } } },
  } as const,
  extensions: {
    protobufEnum: {
      name: "NestedEnum",
      fullName: "testapis.nested.ParentMessage.NestedEnum",
      package: "testapis.nested",
    },
  },
});
",
    "name": "testapis/nested/nested.pb.pothos.ts",
  },
]
`;

exports[`protobuf-es > 'testapis.nested' > generates files by plugin 'with partial inputs' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/nested/nested.proto

/* eslint-disable */

import { EnumRef, InputObjectRef } from "@pothos/core";
import {
  ParentMessage,
  ParentMessage_NestedEnum,
  ParentMessage_NestedMessage,
} from "@testapis/protobuf-es/testapis/nested/nested_pb";
import { builder } from "../../builder";

export const ParentMessage$Ref = builder.objectRef<ParentMessage>(
  "ParentMessage",
);
builder.objectType(ParentMessage$Ref, {
  name: "ParentMessage",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
    nested: t.expose("nested", {
      type: ParentMessageNestedMessage$Ref,
      nullable: true,
      extensions: {
        protobufField: {
          name: "nested",
          typeFullName: "testapis.nested.ParentMessage.NestedMessage",
        },
      },
    }),
    nestedEnum: t.field({
      type: ParentMessageNestedEnum$Ref,
      nullable: true,
      resolve: (source) => {
        if (
          source.nestedEnum === ParentMessage_NestedEnum.NESTED_ENUM_UNSPECIFIED
        ) {
          return null;
        }

        return source.nestedEnum;
      },
      extensions: {
        protobufField: {
          name: "nested_enum",
          typeFullName: "testapis.nested.ParentMessage.NestedEnum",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof ParentMessage;
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.nested.ParentMessage",
      name: "ParentMessage",
      package: "testapis.nested",
    },
  },
});

export const ParentMessageNestedMessage$Ref = builder.objectRef<
  ParentMessage_NestedMessage
>("ParentMessageNestedMessage");
builder.objectType(ParentMessageNestedMessage$Ref, {
  name: "ParentMessageNestedMessage",
  fields: (t) => ({
    nestedBody: t.expose("nestedBody", {
      type: "String",
      nullable: false,
      extensions: {
        protobufField: { name: "nested_body", typeFullName: "string" },
      },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof ParentMessage_NestedMessage;
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.nested.ParentMessage.NestedMessage",
      name: "NestedMessage",
      package: "testapis.nested",
    },
  },
});

export type ParentMessageInput$Shape = {
  body: ParentMessage["body"];
  nested?: ParentMessageNestedMessageInput$Shape | null;
  nestedEnum?: ParentMessage["nestedEnum"] | null;
};

export const ParentMessageInput$Ref: InputObjectRef<ParentMessageInput$Shape> =
  builder.inputRef<ParentMessageInput$Shape>("ParentMessageInput").implement(
    {
      fields: (t) => ({
        body: t.field({
          type: "String",
          required: true,
          extensions: {
            protobufField: { name: "body", typeFullName: "string" },
          },
        }),
        nested: t.field({
          type: ParentMessageNestedMessageInput$Ref,
          required: false,
          extensions: {
            protobufField: {
              name: "nested",
              typeFullName: "testapis.nested.ParentMessage.NestedMessage",
            },
          },
        }),
        nestedEnum: t.field({
          type: ParentMessageNestedEnum$Ref,
          required: false,
          extensions: {
            protobufField: {
              name: "nested_enum",
              typeFullName: "testapis.nested.ParentMessage.NestedEnum",
            },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.nested.ParentMessage",
          name: "ParentMessage",
          package: "testapis.nested",
        },
      },
    },
  );

export function ParentMessageInput$toProto(
  input: ParentMessageInput$Shape | null | undefined,
): ParentMessage {
  return new ParentMessage({
    body: input?.body ?? undefined,
    nested: input?.nested
      ? ParentMessageNestedMessageInput$toProto(input.nested)
      : undefined,
    nestedEnum: input?.nestedEnum ?? undefined,
  });
}

export type ParentMessagePartialInput$Shape = {
  body?: ParentMessage["body"] | null;
  nested?: ParentMessageNestedMessagePartialInput$Shape | null;
  nestedEnum?: ParentMessage["nestedEnum"] | null;
};

export const ParentMessagePartialInput$Ref: InputObjectRef<
  ParentMessagePartialInput$Shape
> = builder.inputRef<ParentMessagePartialInput$Shape>(
  "ParentMessagePartialInput",
).implement(
  {
    fields: (t) => ({
      body: t.field({
        type: "String",
        required: false,
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
      nested: t.field({
        type: ParentMessageNestedMessagePartialInput$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "nested",
            typeFullName: "testapis.nested.ParentMessage.NestedMessage",
          },
        },
      }),
      nestedEnum: t.field({
        type: ParentMessageNestedEnum$Ref,
        required: false,
        extensions: {
          protobufField: {
            name: "nested_enum",
            typeFullName: "testapis.nested.ParentMessage.NestedEnum",
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.nested.ParentMessage",
        name: "ParentMessage",
        package: "testapis.nested",
      },
    },
  },
);

export function ParentMessagePartialInput$toProto(
  input: ParentMessagePartialInput$Shape | null | undefined,
): ParentMessage {
  return new ParentMessage({
    body: input?.body ?? undefined,
    nested: input?.nested
      ? ParentMessageNestedMessagePartialInput$toProto(input.nested)
      : undefined,
    nestedEnum: input?.nestedEnum ?? undefined,
  });
}

export type ParentMessageNestedMessageInput$Shape = {
  nestedBody: ParentMessage_NestedMessage["nestedBody"];
};

export const ParentMessageNestedMessageInput$Ref: InputObjectRef<
  ParentMessageNestedMessageInput$Shape
> = builder.inputRef<ParentMessageNestedMessageInput$Shape>(
  "ParentMessageNestedMessageInput",
).implement(
  {
    fields: (t) => ({
      nestedBody: t.field({
        type: "String",
        required: true,
        extensions: {
          protobufField: { name: "nested_body", typeFullName: "string" },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.nested.ParentMessage.NestedMessage",
        name: "NestedMessage",
        package: "testapis.nested",
      },
    },
  },
);

export function ParentMessageNestedMessageInput$toProto(
  input: ParentMessageNestedMessageInput$Shape | null | undefined,
): ParentMessage_NestedMessage {
  return new ParentMessage_NestedMessage({
    nestedBody: input?.nestedBody ?? undefined,
  });
}

export type ParentMessageNestedMessagePartialInput$Shape = {
  nestedBody?: ParentMessage_NestedMessage["nestedBody"] | null;
};

export const ParentMessageNestedMessagePartialInput$Ref: InputObjectRef<
  ParentMessageNestedMessagePartialInput$Shape
> = builder.inputRef<ParentMessageNestedMessagePartialInput$Shape>(
  "ParentMessageNestedMessagePartialInput",
).implement(
  {
    fields: (t) => ({
      nestedBody: t.field({
        type: "String",
        required: false,
        extensions: {
          protobufField: { name: "nested_body", typeFullName: "string" },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.nested.ParentMessage.NestedMessage",
        name: "NestedMessage",
        package: "testapis.nested",
      },
    },
  },
);

export function ParentMessageNestedMessagePartialInput$toProto(
  input: ParentMessageNestedMessagePartialInput$Shape | null | undefined,
): ParentMessage_NestedMessage {
  return new ParentMessage_NestedMessage({
    nestedBody: input?.nestedBody ?? undefined,
  });
}

export const ParentMessageNestedEnum$Ref: EnumRef<
  ParentMessage_NestedEnum,
  ParentMessage_NestedEnum
> = builder.enumType("ParentMessageNestedEnum", {
  values: {
    FOO: { value: 1, extensions: { protobufEnumValue: { name: "FOO" } } },
    BAR: { value: 2, extensions: { protobufEnumValue: { name: "BAR" } } },
  } as const,
  extensions: {
    protobufEnum: {
      name: "NestedEnum",
      fullName: "testapis.nested.ParentMessage.NestedEnum",
      package: "testapis.nested",
    },
  },
});
",
    "name": "testapis/nested/nested.pb.pothos.ts",
  },
]
`;

exports[`protobuf-es > 'testapis.nested' > generates files by plugin 'without import prefix' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/nested/nested.proto

/* eslint-disable */

import { EnumRef, InputObjectRef } from "@pothos/core";
import { builder } from "../../builder";
import {
  ParentMessage,
  ParentMessage_NestedEnum,
  ParentMessage_NestedMessage,
} from "./testapis/nested/nested_pb";

export const ParentMessage$Ref = builder.objectRef<ParentMessage>(
  "ParentMessage",
);
builder.objectType(ParentMessage$Ref, {
  name: "ParentMessage",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
    nested: t.expose("nested", {
      type: ParentMessageNestedMessage$Ref,
      nullable: true,
      extensions: {
        protobufField: {
          name: "nested",
          typeFullName: "testapis.nested.ParentMessage.NestedMessage",
        },
      },
    }),
    nestedEnum: t.field({
      type: ParentMessageNestedEnum$Ref,
      nullable: true,
      resolve: (source) => {
        if (
          source.nestedEnum === ParentMessage_NestedEnum.NESTED_ENUM_UNSPECIFIED
        ) {
          return null;
        }

        return source.nestedEnum;
      },
      extensions: {
        protobufField: {
          name: "nested_enum",
          typeFullName: "testapis.nested.ParentMessage.NestedEnum",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof ParentMessage;
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.nested.ParentMessage",
      name: "ParentMessage",
      package: "testapis.nested",
    },
  },
});

export const ParentMessageNestedMessage$Ref = builder.objectRef<
  ParentMessage_NestedMessage
>("ParentMessageNestedMessage");
builder.objectType(ParentMessageNestedMessage$Ref, {
  name: "ParentMessageNestedMessage",
  fields: (t) => ({
    nestedBody: t.expose("nestedBody", {
      type: "String",
      nullable: false,
      extensions: {
        protobufField: { name: "nested_body", typeFullName: "string" },
      },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof ParentMessage_NestedMessage;
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.nested.ParentMessage.NestedMessage",
      name: "NestedMessage",
      package: "testapis.nested",
    },
  },
});

export type ParentMessageInput$Shape = {
  body: ParentMessage["body"];
  nested?: ParentMessageNestedMessageInput$Shape | null;
  nestedEnum?: ParentMessage["nestedEnum"] | null;
};

export const ParentMessageInput$Ref: InputObjectRef<ParentMessageInput$Shape> =
  builder.inputRef<ParentMessageInput$Shape>("ParentMessageInput").implement(
    {
      fields: (t) => ({
        body: t.field({
          type: "String",
          required: true,
          extensions: {
            protobufField: { name: "body", typeFullName: "string" },
          },
        }),
        nested: t.field({
          type: ParentMessageNestedMessageInput$Ref,
          required: false,
          extensions: {
            protobufField: {
              name: "nested",
              typeFullName: "testapis.nested.ParentMessage.NestedMessage",
            },
          },
        }),
        nestedEnum: t.field({
          type: ParentMessageNestedEnum$Ref,
          required: false,
          extensions: {
            protobufField: {
              name: "nested_enum",
              typeFullName: "testapis.nested.ParentMessage.NestedEnum",
            },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.nested.ParentMessage",
          name: "ParentMessage",
          package: "testapis.nested",
        },
      },
    },
  );

export function ParentMessageInput$toProto(
  input: ParentMessageInput$Shape | null | undefined,
): ParentMessage {
  return new ParentMessage({
    body: input?.body ?? undefined,
    nested: input?.nested
      ? ParentMessageNestedMessageInput$toProto(input.nested)
      : undefined,
    nestedEnum: input?.nestedEnum ?? undefined,
  });
}

export type ParentMessageNestedMessageInput$Shape = {
  nestedBody: ParentMessage_NestedMessage["nestedBody"];
};

export const ParentMessageNestedMessageInput$Ref: InputObjectRef<
  ParentMessageNestedMessageInput$Shape
> = builder.inputRef<ParentMessageNestedMessageInput$Shape>(
  "ParentMessageNestedMessageInput",
).implement(
  {
    fields: (t) => ({
      nestedBody: t.field({
        type: "String",
        required: true,
        extensions: {
          protobufField: { name: "nested_body", typeFullName: "string" },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.nested.ParentMessage.NestedMessage",
        name: "NestedMessage",
        package: "testapis.nested",
      },
    },
  },
);

export function ParentMessageNestedMessageInput$toProto(
  input: ParentMessageNestedMessageInput$Shape | null | undefined,
): ParentMessage_NestedMessage {
  return new ParentMessage_NestedMessage({
    nestedBody: input?.nestedBody ?? undefined,
  });
}

export const ParentMessageNestedEnum$Ref: EnumRef<
  ParentMessage_NestedEnum,
  ParentMessage_NestedEnum
> = builder.enumType("ParentMessageNestedEnum", {
  values: {
    FOO: { value: 1, extensions: { protobufEnumValue: { name: "FOO" } } },
    BAR: { value: 2, extensions: { protobufEnumValue: { name: "BAR" } } },
  } as const,
  extensions: {
    protobufEnum: {
      name: "NestedEnum",
      fullName: "testapis.nested.ParentMessage.NestedEnum",
      package: "testapis.nested",
    },
  },
});
",
    "name": "testapis/nested/nested.pb.pothos.ts",
  },
]
`;

exports[`protobuf-es > 'testapis.oneof' > generates files by plugin 'with import prefix' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/oneof/oneof.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import {
  OneofMemberMessage1,
  OneofMemberMessage2,
  OneofParent,
} from "@testapis/protobuf-es/testapis/oneof/oneof_pb";
import { builder } from "../../builder";

export const OneofParent$Ref = builder.objectRef<OneofParent>("OneofParent");
builder.objectType(OneofParent$Ref, {
  name: "OneofParent",
  fields: (t) => ({
    normalField: t.expose("normalField", {
      type: "String",
      nullable: false,
      extensions: {
        protobufField: { name: "normal_field", typeFullName: "string" },
      },
    }),
    requiredOneofMembers: t.field({
      type: OneofParentRequiredOneofMembers$Ref,
      nullable: false,
      description: "Required. disallow not_set.",
      resolve: (source) => {
        const value = source.requiredOneofMembers.value;
        if (value == null) {
          throw new Error("requiredOneofMembers should not be null");
        }
        return value;
      },
      extensions: { protobufField: { name: "required_oneof_members" } },
    }),
    optionalOneofMembers: t.field({
      type: OneofParentOptionalOneofMembers$Ref,
      nullable: true,
      resolve: (source) => {
        return source.optionalOneofMembers.value;
      },
      extensions: { protobufField: { name: "optional_oneof_members" } },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof OneofParent;
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.oneof.OneofParent",
      name: "OneofParent",
      package: "testapis.oneof",
    },
  },
});

export const OneofMemberMessage1$Ref = builder.objectRef<OneofMemberMessage1>(
  "OneofMemberMessage1",
);
builder.objectType(OneofMemberMessage1$Ref, {
  name: "OneofMemberMessage1",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof OneofMemberMessage1;
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.oneof.OneofMemberMessage1",
      name: "OneofMemberMessage1",
      package: "testapis.oneof",
    },
  },
});

export const OneofMemberMessage2$Ref = builder.objectRef<OneofMemberMessage2>(
  "OneofMemberMessage2",
);
builder.objectType(OneofMemberMessage2$Ref, {
  name: "OneofMemberMessage2",
  fields: (t) => ({
    imageUrl: t.expose("imageUrl", {
      type: "String",
      nullable: false,
      extensions: {
        protobufField: { name: "image_url", typeFullName: "string" },
      },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof OneofMemberMessage2;
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.oneof.OneofMemberMessage2",
      name: "OneofMemberMessage2",
      package: "testapis.oneof",
    },
  },
});

export type OneofParentInput$Shape = {
  normalField: OneofParent["normalField"];
  requiredMessage1?: OneofMemberMessage1Input$Shape | null;
  requiredMessage2?: OneofMemberMessage2Input$Shape | null;
  optoinalMessage1?: OneofMemberMessage1Input$Shape | null;
  optoinalMessage2?: OneofMemberMessage2Input$Shape | null;
};

export const OneofParentInput$Ref: InputObjectRef<OneofParentInput$Shape> =
  builder.inputRef<OneofParentInput$Shape>("OneofParentInput").implement(
    {
      fields: (t) => ({
        normalField: t.field({
          type: "String",
          required: true,
          extensions: {
            protobufField: { name: "normal_field", typeFullName: "string" },
          },
        }),
        requiredMessage1: t.field({
          type: OneofMemberMessage1Input$Ref,
          required: false,
          extensions: {
            protobufField: {
              name: "required_message1",
              typeFullName: "testapis.oneof.OneofMemberMessage1",
            },
          },
        }),
        requiredMessage2: t.field({
          type: OneofMemberMessage2Input$Ref,
          required: false,
          extensions: {
            protobufField: {
              name: "required_message2",
              typeFullName: "testapis.oneof.OneofMemberMessage2",
            },
          },
        }),
        optoinalMessage1: t.field({
          type: OneofMemberMessage1Input$Ref,
          required: false,
          extensions: {
            protobufField: {
              name: "optoinal_message1",
              typeFullName: "testapis.oneof.OneofMemberMessage1",
            },
          },
        }),
        optoinalMessage2: t.field({
          type: OneofMemberMessage2Input$Ref,
          required: false,
          extensions: {
            protobufField: {
              name: "optoinal_message2",
              typeFullName: "testapis.oneof.OneofMemberMessage2",
            },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.oneof.OneofParent",
          name: "OneofParent",
          package: "testapis.oneof",
        },
      },
    },
  );

export function OneofParentInput$toProto(
  input: OneofParentInput$Shape | null | undefined,
): OneofParent {
  return new OneofParent({
    normalField: input?.normalField ?? undefined,
    requiredOneofMembers: input?.requiredMessage1
      ? {
        case: "requiredMessage1",
        value: OneofMemberMessage1Input$toProto(input.requiredMessage1),
      }
      : input?.requiredMessage2
      ? {
        case: "requiredMessage2",
        value: OneofMemberMessage2Input$toProto(input.requiredMessage2),
      }
      : undefined,
    optionalOneofMembers: input?.optoinalMessage1
      ? {
        case: "optoinalMessage1",
        value: OneofMemberMessage1Input$toProto(input.optoinalMessage1),
      }
      : input?.optoinalMessage2
      ? {
        case: "optoinalMessage2",
        value: OneofMemberMessage2Input$toProto(input.optoinalMessage2),
      }
      : undefined,
  });
}

export type OneofMemberMessage1Input$Shape = {
  body: OneofMemberMessage1["body"];
};

export const OneofMemberMessage1Input$Ref: InputObjectRef<
  OneofMemberMessage1Input$Shape
> = builder.inputRef<OneofMemberMessage1Input$Shape>("OneofMemberMessage1Input")
  .implement(
    {
      fields: (t) => ({
        body: t.field({
          type: "String",
          required: true,
          extensions: {
            protobufField: { name: "body", typeFullName: "string" },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.oneof.OneofMemberMessage1",
          name: "OneofMemberMessage1",
          package: "testapis.oneof",
        },
      },
    },
  );

export function OneofMemberMessage1Input$toProto(
  input: OneofMemberMessage1Input$Shape | null | undefined,
): OneofMemberMessage1 {
  return new OneofMemberMessage1({
    body: input?.body ?? undefined,
  });
}

export type OneofMemberMessage2Input$Shape = {
  imageUrl: OneofMemberMessage2["imageUrl"];
};

export const OneofMemberMessage2Input$Ref: InputObjectRef<
  OneofMemberMessage2Input$Shape
> = builder.inputRef<OneofMemberMessage2Input$Shape>("OneofMemberMessage2Input")
  .implement(
    {
      fields: (t) => ({
        imageUrl: t.field({
          type: "String",
          required: true,
          extensions: {
            protobufField: { name: "image_url", typeFullName: "string" },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.oneof.OneofMemberMessage2",
          name: "OneofMemberMessage2",
          package: "testapis.oneof",
        },
      },
    },
  );

export function OneofMemberMessage2Input$toProto(
  input: OneofMemberMessage2Input$Shape | null | undefined,
): OneofMemberMessage2 {
  return new OneofMemberMessage2({
    imageUrl: input?.imageUrl ?? undefined,
  });
}

export const OneofParentRequiredOneofMembers$Ref = builder.unionType(
  "OneofParentRequiredOneofMembers",
  {
    types: [OneofMemberMessage1$Ref, OneofMemberMessage2$Ref],
    description: "Required. disallow not_set.",
    extensions: {
      protobufOneof: {
        fullName: "testapis.oneof.OneofParent.required_oneof_members",
        name: "required_oneof_members",
        messageName: "OneofParent",
        package: "testapis.oneof",
        fields: [{
          name: "required_message1",
          type: "testapis.oneof.OneofMemberMessage1",
        }, {
          name: "required_message2",
          type: "testapis.oneof.OneofMemberMessage2",
        }],
      },
    },
  },
);

export const OneofParentOptionalOneofMembers$Ref = builder.unionType(
  "OneofParentOptionalOneofMembers",
  {
    types: [OneofMemberMessage1$Ref, OneofMemberMessage2$Ref],
    extensions: {
      protobufOneof: {
        fullName: "testapis.oneof.OneofParent.optional_oneof_members",
        name: "optional_oneof_members",
        messageName: "OneofParent",
        package: "testapis.oneof",
        fields: [{
          name: "optoinal_message1",
          type: "testapis.oneof.OneofMemberMessage1",
        }, {
          name: "optoinal_message2",
          type: "testapis.oneof.OneofMemberMessage2",
        }],
      },
    },
  },
);
",
    "name": "testapis/oneof/oneof.pb.pothos.ts",
  },
]
`;

exports[`protobuf-es > 'testapis.oneof' > generates files by plugin 'with partial inputs' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/oneof/oneof.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import {
  OneofMemberMessage1,
  OneofMemberMessage2,
  OneofParent,
} from "@testapis/protobuf-es/testapis/oneof/oneof_pb";
import { builder } from "../../builder";

export const OneofParent$Ref = builder.objectRef<OneofParent>("OneofParent");
builder.objectType(OneofParent$Ref, {
  name: "OneofParent",
  fields: (t) => ({
    normalField: t.expose("normalField", {
      type: "String",
      nullable: false,
      extensions: {
        protobufField: { name: "normal_field", typeFullName: "string" },
      },
    }),
    requiredOneofMembers: t.field({
      type: OneofParentRequiredOneofMembers$Ref,
      nullable: false,
      description: "Required. disallow not_set.",
      resolve: (source) => {
        const value = source.requiredOneofMembers.value;
        if (value == null) {
          throw new Error("requiredOneofMembers should not be null");
        }
        return value;
      },
      extensions: { protobufField: { name: "required_oneof_members" } },
    }),
    optionalOneofMembers: t.field({
      type: OneofParentOptionalOneofMembers$Ref,
      nullable: true,
      resolve: (source) => {
        return source.optionalOneofMembers.value;
      },
      extensions: { protobufField: { name: "optional_oneof_members" } },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof OneofParent;
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.oneof.OneofParent",
      name: "OneofParent",
      package: "testapis.oneof",
    },
  },
});

export const OneofMemberMessage1$Ref = builder.objectRef<OneofMemberMessage1>(
  "OneofMemberMessage1",
);
builder.objectType(OneofMemberMessage1$Ref, {
  name: "OneofMemberMessage1",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof OneofMemberMessage1;
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.oneof.OneofMemberMessage1",
      name: "OneofMemberMessage1",
      package: "testapis.oneof",
    },
  },
});

export const OneofMemberMessage2$Ref = builder.objectRef<OneofMemberMessage2>(
  "OneofMemberMessage2",
);
builder.objectType(OneofMemberMessage2$Ref, {
  name: "OneofMemberMessage2",
  fields: (t) => ({
    imageUrl: t.expose("imageUrl", {
      type: "String",
      nullable: false,
      extensions: {
        protobufField: { name: "image_url", typeFullName: "string" },
      },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof OneofMemberMessage2;
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.oneof.OneofMemberMessage2",
      name: "OneofMemberMessage2",
      package: "testapis.oneof",
    },
  },
});

export type OneofParentInput$Shape = {
  normalField: OneofParent["normalField"];
  requiredMessage1?: OneofMemberMessage1Input$Shape | null;
  requiredMessage2?: OneofMemberMessage2Input$Shape | null;
  optoinalMessage1?: OneofMemberMessage1Input$Shape | null;
  optoinalMessage2?: OneofMemberMessage2Input$Shape | null;
};

export const OneofParentInput$Ref: InputObjectRef<OneofParentInput$Shape> =
  builder.inputRef<OneofParentInput$Shape>("OneofParentInput").implement(
    {
      fields: (t) => ({
        normalField: t.field({
          type: "String",
          required: true,
          extensions: {
            protobufField: { name: "normal_field", typeFullName: "string" },
          },
        }),
        requiredMessage1: t.field({
          type: OneofMemberMessage1Input$Ref,
          required: false,
          extensions: {
            protobufField: {
              name: "required_message1",
              typeFullName: "testapis.oneof.OneofMemberMessage1",
            },
          },
        }),
        requiredMessage2: t.field({
          type: OneofMemberMessage2Input$Ref,
          required: false,
          extensions: {
            protobufField: {
              name: "required_message2",
              typeFullName: "testapis.oneof.OneofMemberMessage2",
            },
          },
        }),
        optoinalMessage1: t.field({
          type: OneofMemberMessage1Input$Ref,
          required: false,
          extensions: {
            protobufField: {
              name: "optoinal_message1",
              typeFullName: "testapis.oneof.OneofMemberMessage1",
            },
          },
        }),
        optoinalMessage2: t.field({
          type: OneofMemberMessage2Input$Ref,
          required: false,
          extensions: {
            protobufField: {
              name: "optoinal_message2",
              typeFullName: "testapis.oneof.OneofMemberMessage2",
            },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.oneof.OneofParent",
          name: "OneofParent",
          package: "testapis.oneof",
        },
      },
    },
  );

export function OneofParentInput$toProto(
  input: OneofParentInput$Shape | null | undefined,
): OneofParent {
  return new OneofParent({
    normalField: input?.normalField ?? undefined,
    requiredOneofMembers: input?.requiredMessage1
      ? {
        case: "requiredMessage1",
        value: OneofMemberMessage1Input$toProto(input.requiredMessage1),
      }
      : input?.requiredMessage2
      ? {
        case: "requiredMessage2",
        value: OneofMemberMessage2Input$toProto(input.requiredMessage2),
      }
      : undefined,
    optionalOneofMembers: input?.optoinalMessage1
      ? {
        case: "optoinalMessage1",
        value: OneofMemberMessage1Input$toProto(input.optoinalMessage1),
      }
      : input?.optoinalMessage2
      ? {
        case: "optoinalMessage2",
        value: OneofMemberMessage2Input$toProto(input.optoinalMessage2),
      }
      : undefined,
  });
}

export type OneofParentPartialInput$Shape = {
  normalField?: OneofParent["normalField"] | null;
  requiredMessage1?: OneofMemberMessage1PartialInput$Shape | null;
  requiredMessage2?: OneofMemberMessage2PartialInput$Shape | null;
  optoinalMessage1?: OneofMemberMessage1PartialInput$Shape | null;
  optoinalMessage2?: OneofMemberMessage2PartialInput$Shape | null;
};

export const OneofParentPartialInput$Ref: InputObjectRef<
  OneofParentPartialInput$Shape
> = builder.inputRef<OneofParentPartialInput$Shape>("OneofParentPartialInput")
  .implement(
    {
      fields: (t) => ({
        normalField: t.field({
          type: "String",
          required: false,
          extensions: {
            protobufField: { name: "normal_field", typeFullName: "string" },
          },
        }),
        requiredMessage1: t.field({
          type: OneofMemberMessage1PartialInput$Ref,
          required: false,
          extensions: {
            protobufField: {
              name: "required_message1",
              typeFullName: "testapis.oneof.OneofMemberMessage1",
            },
          },
        }),
        requiredMessage2: t.field({
          type: OneofMemberMessage2PartialInput$Ref,
          required: false,
          extensions: {
            protobufField: {
              name: "required_message2",
              typeFullName: "testapis.oneof.OneofMemberMessage2",
            },
          },
        }),
        optoinalMessage1: t.field({
          type: OneofMemberMessage1PartialInput$Ref,
          required: false,
          extensions: {
            protobufField: {
              name: "optoinal_message1",
              typeFullName: "testapis.oneof.OneofMemberMessage1",
            },
          },
        }),
        optoinalMessage2: t.field({
          type: OneofMemberMessage2PartialInput$Ref,
          required: false,
          extensions: {
            protobufField: {
              name: "optoinal_message2",
              typeFullName: "testapis.oneof.OneofMemberMessage2",
            },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.oneof.OneofParent",
          name: "OneofParent",
          package: "testapis.oneof",
        },
      },
    },
  );

export function OneofParentPartialInput$toProto(
  input: OneofParentPartialInput$Shape | null | undefined,
): OneofParent {
  return new OneofParent({
    normalField: input?.normalField ?? undefined,
    requiredOneofMembers: input?.requiredMessage1
      ? {
        case: "requiredMessage1",
        value: OneofMemberMessage1PartialInput$toProto(input.requiredMessage1),
      }
      : input?.requiredMessage2
      ? {
        case: "requiredMessage2",
        value: OneofMemberMessage2PartialInput$toProto(input.requiredMessage2),
      }
      : undefined,
    optionalOneofMembers: input?.optoinalMessage1
      ? {
        case: "optoinalMessage1",
        value: OneofMemberMessage1PartialInput$toProto(input.optoinalMessage1),
      }
      : input?.optoinalMessage2
      ? {
        case: "optoinalMessage2",
        value: OneofMemberMessage2PartialInput$toProto(input.optoinalMessage2),
      }
      : undefined,
  });
}

export type OneofMemberMessage1Input$Shape = {
  body: OneofMemberMessage1["body"];
};

export const OneofMemberMessage1Input$Ref: InputObjectRef<
  OneofMemberMessage1Input$Shape
> = builder.inputRef<OneofMemberMessage1Input$Shape>("OneofMemberMessage1Input")
  .implement(
    {
      fields: (t) => ({
        body: t.field({
          type: "String",
          required: true,
          extensions: {
            protobufField: { name: "body", typeFullName: "string" },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.oneof.OneofMemberMessage1",
          name: "OneofMemberMessage1",
          package: "testapis.oneof",
        },
      },
    },
  );

export function OneofMemberMessage1Input$toProto(
  input: OneofMemberMessage1Input$Shape | null | undefined,
): OneofMemberMessage1 {
  return new OneofMemberMessage1({
    body: input?.body ?? undefined,
  });
}

export type OneofMemberMessage1PartialInput$Shape = {
  body?: OneofMemberMessage1["body"] | null;
};

export const OneofMemberMessage1PartialInput$Ref: InputObjectRef<
  OneofMemberMessage1PartialInput$Shape
> = builder.inputRef<OneofMemberMessage1PartialInput$Shape>(
  "OneofMemberMessage1PartialInput",
).implement(
  {
    fields: (t) => ({
      body: t.field({
        type: "String",
        required: false,
        extensions: { protobufField: { name: "body", typeFullName: "string" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.oneof.OneofMemberMessage1",
        name: "OneofMemberMessage1",
        package: "testapis.oneof",
      },
    },
  },
);

export function OneofMemberMessage1PartialInput$toProto(
  input: OneofMemberMessage1PartialInput$Shape | null | undefined,
): OneofMemberMessage1 {
  return new OneofMemberMessage1({
    body: input?.body ?? undefined,
  });
}

export type OneofMemberMessage2Input$Shape = {
  imageUrl: OneofMemberMessage2["imageUrl"];
};

export const OneofMemberMessage2Input$Ref: InputObjectRef<
  OneofMemberMessage2Input$Shape
> = builder.inputRef<OneofMemberMessage2Input$Shape>("OneofMemberMessage2Input")
  .implement(
    {
      fields: (t) => ({
        imageUrl: t.field({
          type: "String",
          required: true,
          extensions: {
            protobufField: { name: "image_url", typeFullName: "string" },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.oneof.OneofMemberMessage2",
          name: "OneofMemberMessage2",
          package: "testapis.oneof",
        },
      },
    },
  );

export function OneofMemberMessage2Input$toProto(
  input: OneofMemberMessage2Input$Shape | null | undefined,
): OneofMemberMessage2 {
  return new OneofMemberMessage2({
    imageUrl: input?.imageUrl ?? undefined,
  });
}

export type OneofMemberMessage2PartialInput$Shape = {
  imageUrl?: OneofMemberMessage2["imageUrl"] | null;
};

export const OneofMemberMessage2PartialInput$Ref: InputObjectRef<
  OneofMemberMessage2PartialInput$Shape
> = builder.inputRef<OneofMemberMessage2PartialInput$Shape>(
  "OneofMemberMessage2PartialInput",
).implement(
  {
    fields: (t) => ({
      imageUrl: t.field({
        type: "String",
        required: false,
        extensions: {
          protobufField: { name: "image_url", typeFullName: "string" },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.oneof.OneofMemberMessage2",
        name: "OneofMemberMessage2",
        package: "testapis.oneof",
      },
    },
  },
);

export function OneofMemberMessage2PartialInput$toProto(
  input: OneofMemberMessage2PartialInput$Shape | null | undefined,
): OneofMemberMessage2 {
  return new OneofMemberMessage2({
    imageUrl: input?.imageUrl ?? undefined,
  });
}

export const OneofParentRequiredOneofMembers$Ref = builder.unionType(
  "OneofParentRequiredOneofMembers",
  {
    types: [OneofMemberMessage1$Ref, OneofMemberMessage2$Ref],
    description: "Required. disallow not_set.",
    extensions: {
      protobufOneof: {
        fullName: "testapis.oneof.OneofParent.required_oneof_members",
        name: "required_oneof_members",
        messageName: "OneofParent",
        package: "testapis.oneof",
        fields: [{
          name: "required_message1",
          type: "testapis.oneof.OneofMemberMessage1",
        }, {
          name: "required_message2",
          type: "testapis.oneof.OneofMemberMessage2",
        }],
      },
    },
  },
);

export const OneofParentOptionalOneofMembers$Ref = builder.unionType(
  "OneofParentOptionalOneofMembers",
  {
    types: [OneofMemberMessage1$Ref, OneofMemberMessage2$Ref],
    extensions: {
      protobufOneof: {
        fullName: "testapis.oneof.OneofParent.optional_oneof_members",
        name: "optional_oneof_members",
        messageName: "OneofParent",
        package: "testapis.oneof",
        fields: [{
          name: "optoinal_message1",
          type: "testapis.oneof.OneofMemberMessage1",
        }, {
          name: "optoinal_message2",
          type: "testapis.oneof.OneofMemberMessage2",
        }],
      },
    },
  },
);
",
    "name": "testapis/oneof/oneof.pb.pothos.ts",
  },
]
`;

exports[`protobuf-es > 'testapis.oneof' > generates files by plugin 'without import prefix' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/oneof/oneof.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { builder } from "../../builder";
import {
  OneofMemberMessage1,
  OneofMemberMessage2,
  OneofParent,
} from "./testapis/oneof/oneof_pb";

export const OneofParent$Ref = builder.objectRef<OneofParent>("OneofParent");
builder.objectType(OneofParent$Ref, {
  name: "OneofParent",
  fields: (t) => ({
    normalField: t.expose("normalField", {
      type: "String",
      nullable: false,
      extensions: {
        protobufField: { name: "normal_field", typeFullName: "string" },
      },
    }),
    requiredOneofMembers: t.field({
      type: OneofParentRequiredOneofMembers$Ref,
      nullable: false,
      description: "Required. disallow not_set.",
      resolve: (source) => {
        const value = source.requiredOneofMembers.value;
        if (value == null) {
          throw new Error("requiredOneofMembers should not be null");
        }
        return value;
      },
      extensions: { protobufField: { name: "required_oneof_members" } },
    }),
    optionalOneofMembers: t.field({
      type: OneofParentOptionalOneofMembers$Ref,
      nullable: true,
      resolve: (source) => {
        return source.optionalOneofMembers.value;
      },
      extensions: { protobufField: { name: "optional_oneof_members" } },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof OneofParent;
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.oneof.OneofParent",
      name: "OneofParent",
      package: "testapis.oneof",
    },
  },
});

export const OneofMemberMessage1$Ref = builder.objectRef<OneofMemberMessage1>(
  "OneofMemberMessage1",
);
builder.objectType(OneofMemberMessage1$Ref, {
  name: "OneofMemberMessage1",
  fields: (t) => ({
    body: t.expose("body", {
      type: "String",
      nullable: false,
      extensions: { protobufField: { name: "body", typeFullName: "string" } },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof OneofMemberMessage1;
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.oneof.OneofMemberMessage1",
      name: "OneofMemberMessage1",
      package: "testapis.oneof",
    },
  },
});

export const OneofMemberMessage2$Ref = builder.objectRef<OneofMemberMessage2>(
  "OneofMemberMessage2",
);
builder.objectType(OneofMemberMessage2$Ref, {
  name: "OneofMemberMessage2",
  fields: (t) => ({
    imageUrl: t.expose("imageUrl", {
      type: "String",
      nullable: false,
      extensions: {
        protobufField: { name: "image_url", typeFullName: "string" },
      },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof OneofMemberMessage2;
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.oneof.OneofMemberMessage2",
      name: "OneofMemberMessage2",
      package: "testapis.oneof",
    },
  },
});

export type OneofParentInput$Shape = {
  normalField: OneofParent["normalField"];
  requiredMessage1?: OneofMemberMessage1Input$Shape | null;
  requiredMessage2?: OneofMemberMessage2Input$Shape | null;
  optoinalMessage1?: OneofMemberMessage1Input$Shape | null;
  optoinalMessage2?: OneofMemberMessage2Input$Shape | null;
};

export const OneofParentInput$Ref: InputObjectRef<OneofParentInput$Shape> =
  builder.inputRef<OneofParentInput$Shape>("OneofParentInput").implement(
    {
      fields: (t) => ({
        normalField: t.field({
          type: "String",
          required: true,
          extensions: {
            protobufField: { name: "normal_field", typeFullName: "string" },
          },
        }),
        requiredMessage1: t.field({
          type: OneofMemberMessage1Input$Ref,
          required: false,
          extensions: {
            protobufField: {
              name: "required_message1",
              typeFullName: "testapis.oneof.OneofMemberMessage1",
            },
          },
        }),
        requiredMessage2: t.field({
          type: OneofMemberMessage2Input$Ref,
          required: false,
          extensions: {
            protobufField: {
              name: "required_message2",
              typeFullName: "testapis.oneof.OneofMemberMessage2",
            },
          },
        }),
        optoinalMessage1: t.field({
          type: OneofMemberMessage1Input$Ref,
          required: false,
          extensions: {
            protobufField: {
              name: "optoinal_message1",
              typeFullName: "testapis.oneof.OneofMemberMessage1",
            },
          },
        }),
        optoinalMessage2: t.field({
          type: OneofMemberMessage2Input$Ref,
          required: false,
          extensions: {
            protobufField: {
              name: "optoinal_message2",
              typeFullName: "testapis.oneof.OneofMemberMessage2",
            },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.oneof.OneofParent",
          name: "OneofParent",
          package: "testapis.oneof",
        },
      },
    },
  );

export function OneofParentInput$toProto(
  input: OneofParentInput$Shape | null | undefined,
): OneofParent {
  return new OneofParent({
    normalField: input?.normalField ?? undefined,
    requiredOneofMembers: input?.requiredMessage1
      ? {
        case: "requiredMessage1",
        value: OneofMemberMessage1Input$toProto(input.requiredMessage1),
      }
      : input?.requiredMessage2
      ? {
        case: "requiredMessage2",
        value: OneofMemberMessage2Input$toProto(input.requiredMessage2),
      }
      : undefined,
    optionalOneofMembers: input?.optoinalMessage1
      ? {
        case: "optoinalMessage1",
        value: OneofMemberMessage1Input$toProto(input.optoinalMessage1),
      }
      : input?.optoinalMessage2
      ? {
        case: "optoinalMessage2",
        value: OneofMemberMessage2Input$toProto(input.optoinalMessage2),
      }
      : undefined,
  });
}

export type OneofMemberMessage1Input$Shape = {
  body: OneofMemberMessage1["body"];
};

export const OneofMemberMessage1Input$Ref: InputObjectRef<
  OneofMemberMessage1Input$Shape
> = builder.inputRef<OneofMemberMessage1Input$Shape>("OneofMemberMessage1Input")
  .implement(
    {
      fields: (t) => ({
        body: t.field({
          type: "String",
          required: true,
          extensions: {
            protobufField: { name: "body", typeFullName: "string" },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.oneof.OneofMemberMessage1",
          name: "OneofMemberMessage1",
          package: "testapis.oneof",
        },
      },
    },
  );

export function OneofMemberMessage1Input$toProto(
  input: OneofMemberMessage1Input$Shape | null | undefined,
): OneofMemberMessage1 {
  return new OneofMemberMessage1({
    body: input?.body ?? undefined,
  });
}

export type OneofMemberMessage2Input$Shape = {
  imageUrl: OneofMemberMessage2["imageUrl"];
};

export const OneofMemberMessage2Input$Ref: InputObjectRef<
  OneofMemberMessage2Input$Shape
> = builder.inputRef<OneofMemberMessage2Input$Shape>("OneofMemberMessage2Input")
  .implement(
    {
      fields: (t) => ({
        imageUrl: t.field({
          type: "String",
          required: true,
          extensions: {
            protobufField: { name: "image_url", typeFullName: "string" },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.oneof.OneofMemberMessage2",
          name: "OneofMemberMessage2",
          package: "testapis.oneof",
        },
      },
    },
  );

export function OneofMemberMessage2Input$toProto(
  input: OneofMemberMessage2Input$Shape | null | undefined,
): OneofMemberMessage2 {
  return new OneofMemberMessage2({
    imageUrl: input?.imageUrl ?? undefined,
  });
}

export const OneofParentRequiredOneofMembers$Ref = builder.unionType(
  "OneofParentRequiredOneofMembers",
  {
    types: [OneofMemberMessage1$Ref, OneofMemberMessage2$Ref],
    description: "Required. disallow not_set.",
    extensions: {
      protobufOneof: {
        fullName: "testapis.oneof.OneofParent.required_oneof_members",
        name: "required_oneof_members",
        messageName: "OneofParent",
        package: "testapis.oneof",
        fields: [{
          name: "required_message1",
          type: "testapis.oneof.OneofMemberMessage1",
        }, {
          name: "required_message2",
          type: "testapis.oneof.OneofMemberMessage2",
        }],
      },
    },
  },
);

export const OneofParentOptionalOneofMembers$Ref = builder.unionType(
  "OneofParentOptionalOneofMembers",
  {
    types: [OneofMemberMessage1$Ref, OneofMemberMessage2$Ref],
    extensions: {
      protobufOneof: {
        fullName: "testapis.oneof.OneofParent.optional_oneof_members",
        name: "optional_oneof_members",
        messageName: "OneofParent",
        package: "testapis.oneof",
        fields: [{
          name: "optoinal_message1",
          type: "testapis.oneof.OneofMemberMessage1",
        }, {
          name: "optoinal_message2",
          type: "testapis.oneof.OneofMemberMessage2",
        }],
      },
    },
  },
);
",
    "name": "testapis/oneof/oneof.pb.pothos.ts",
  },
]
`;

exports[`protobuf-es > 'testapis.primitives' > generates files by plugin 'with import prefix' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/primitives/primitives.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import {
  Message,
  Primitives,
} from "@testapis/protobuf-es/testapis/primitives/primitives_pb";
import { builder } from "../../builder";

export const Message$Ref = builder.objectRef<Message>("Message");
builder.objectType(Message$Ref, {
  name: "Message",
  fields: (t) => ({
    requiredPrimitives: t.field({
      type: Primitives$Ref,
      nullable: false,
      description: "Required.",
      resolve: (source) => {
        return source.requiredPrimitives!;
      },
      extensions: {
        protobufField: {
          name: "required_primitives",
          typeFullName: "testapis.primitives.Primitives",
        },
      },
    }),
    optionalPrimitives: t.expose("optionalPrimitives", {
      type: Primitives$Ref,
      nullable: true,
      description: "Optional.",
      extensions: {
        protobufField: {
          name: "optional_primitives",
          typeFullName: "testapis.primitives.Primitives",
        },
      },
    }),
    requiredPrimitivesList: t.field({
      type: [Primitives$Ref],
      nullable: { list: false, items: false },
      description: "Required.",
      resolve: (source) => {
        return source.requiredPrimitivesList!;
      },
      extensions: {
        protobufField: {
          name: "required_primitives_list",
          typeFullName: "testapis.primitives.Primitives",
        },
      },
    }),
    optionalPrimitivesList: t.expose("optionalPrimitivesList", {
      type: [Primitives$Ref],
      nullable: { list: true, items: false },
      description: "Optional.",
      extensions: {
        protobufField: {
          name: "optional_primitives_list",
          typeFullName: "testapis.primitives.Primitives",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof Message;
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.primitives.Message",
      name: "Message",
      package: "testapis.primitives",
    },
  },
});

export const Primitives$Ref = builder.objectRef<Primitives>("Primitives");
builder.objectType(Primitives$Ref, {
  name: "Primitives",
  fields: (t) => ({
    requiredDoubleValue: t.expose("requiredDoubleValue", {
      type: "Float",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_double_value",
          typeFullName: "double",
        },
      },
    }),
    requiredFloatValue: t.expose("requiredFloatValue", {
      type: "Float",
      nullable: false,
      extensions: {
        protobufField: { name: "required_float_value", typeFullName: "float" },
      },
    }),
    requiredInt32Value: t.expose("requiredInt32Value", {
      type: "Int",
      nullable: false,
      extensions: {
        protobufField: { name: "required_int32_value", typeFullName: "int32" },
      },
    }),
    requiredInt64Value: t.expose("requiredInt64Value", {
      type: "Int64",
      nullable: false,
      extensions: {
        protobufField: { name: "required_int64_value", typeFullName: "int64" },
      },
    }),
    requiredUint32Value: t.expose("requiredUint32Value", {
      type: "Int",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_uint32_value",
          typeFullName: "uint32",
        },
      },
    }),
    requiredUint64Value: t.expose("requiredUint64Value", {
      type: "Int64",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_uint64_value",
          typeFullName: "uint64",
        },
      },
    }),
    requiredSint32Value: t.expose("requiredSint32Value", {
      type: "Int",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_sint32_value",
          typeFullName: "sint32",
        },
      },
    }),
    requiredSint64Value: t.expose("requiredSint64Value", {
      type: "Int64",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_sint64_value",
          typeFullName: "sint64",
        },
      },
    }),
    requiredFixed32Value: t.expose("requiredFixed32Value", {
      type: "Int",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_fixed32_value",
          typeFullName: "fixed32",
        },
      },
    }),
    requiredFixed64Value: t.expose("requiredFixed64Value", {
      type: "Int64",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_fixed64_value",
          typeFullName: "fixed64",
        },
      },
    }),
    requiredSfixed32Value: t.expose("requiredSfixed32Value", {
      type: "Int",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_sfixed32_value",
          typeFullName: "sfixed32",
        },
      },
    }),
    requiredSfixed64Value: t.expose("requiredSfixed64Value", {
      type: "Int64",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_sfixed64_value",
          typeFullName: "sfixed64",
        },
      },
    }),
    requiredBoolValue: t.expose("requiredBoolValue", {
      type: "Boolean",
      nullable: false,
      extensions: {
        protobufField: { name: "required_bool_value", typeFullName: "bool" },
      },
    }),
    requiredStringValue: t.expose("requiredStringValue", {
      type: "String",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_string_value",
          typeFullName: "string",
        },
      },
    }),
    requiredBytesValue: t.field({
      type: "Byte",
      nullable: false,
      resolve: (source) => {
        return Buffer.from(source.requiredBytesValue);
      },
      extensions: {
        protobufField: { name: "required_bytes_value", typeFullName: "bytes" },
      },
    }),
    requiredDoubleValues: t.expose("requiredDoubleValues", {
      type: ["Float"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: {
          name: "required_double_values",
          typeFullName: "double",
        },
      },
    }),
    requiredFloatValues: t.expose("requiredFloatValues", {
      type: ["Float"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: { name: "required_float_values", typeFullName: "float" },
      },
    }),
    requiredInt32Values: t.expose("requiredInt32Values", {
      type: ["Int"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: { name: "required_int32_values", typeFullName: "int32" },
      },
    }),
    requiredInt64Values: t.expose("requiredInt64Values", {
      type: ["Int64"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: { name: "required_int64_values", typeFullName: "int64" },
      },
    }),
    requiredUint32Values: t.expose("requiredUint32Values", {
      type: ["Int"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: {
          name: "required_uint32_values",
          typeFullName: "uint32",
        },
      },
    }),
    requiredUint64Values: t.expose("requiredUint64Values", {
      type: ["Int64"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: {
          name: "required_uint64_values",
          typeFullName: "uint64",
        },
      },
    }),
    requiredSint32Values: t.expose("requiredSint32Values", {
      type: ["Int"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: {
          name: "required_sint32_values",
          typeFullName: "sint32",
        },
      },
    }),
    requiredSint64Values: t.expose("requiredSint64Values", {
      type: ["Int64"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: {
          name: "required_sint64_values",
          typeFullName: "sint64",
        },
      },
    }),
    requiredFixed32Values: t.expose("requiredFixed32Values", {
      type: ["Int"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: {
          name: "required_fixed32_values",
          typeFullName: "fixed32",
        },
      },
    }),
    requiredFixed64Values: t.expose("requiredFixed64Values", {
      type: ["Int64"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: {
          name: "required_fixed64_values",
          typeFullName: "fixed64",
        },
      },
    }),
    requiredSfixed32Values: t.expose("requiredSfixed32Values", {
      type: ["Int"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: {
          name: "required_sfixed32_values",
          typeFullName: "sfixed32",
        },
      },
    }),
    requiredSfixed64Values: t.expose("requiredSfixed64Values", {
      type: ["Int64"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: {
          name: "required_sfixed64_values",
          typeFullName: "sfixed64",
        },
      },
    }),
    requiredBoolValues: t.expose("requiredBoolValues", {
      type: ["Boolean"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: { name: "required_bool_values", typeFullName: "bool" },
      },
    }),
    requiredStringValues: t.expose("requiredStringValues", {
      type: ["String"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: {
          name: "required_string_values",
          typeFullName: "string",
        },
      },
    }),
    requiredBytesValues: t.field({
      type: ["Byte"],
      nullable: { list: false, items: false },
      resolve: (source) => {
        return source.requiredBytesValues.map((v) => Buffer.from(v));
      },
      extensions: {
        protobufField: { name: "required_bytes_values", typeFullName: "bytes" },
      },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof Primitives;
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.primitives.Primitives",
      name: "Primitives",
      package: "testapis.primitives",
    },
  },
});

export type MessageInput$Shape = {
  requiredPrimitives: PrimitivesInput$Shape;
  optionalPrimitives?: PrimitivesInput$Shape | null;
  requiredPrimitivesList: Array<PrimitivesInput$Shape>;
  optionalPrimitivesList?: Array<PrimitivesInput$Shape> | null;
};

export const MessageInput$Ref: InputObjectRef<MessageInput$Shape> = builder
  .inputRef<MessageInput$Shape>("MessageInput").implement(
    {
      fields: (t) => ({
        requiredPrimitives: t.field({
          type: PrimitivesInput$Ref,
          required: true,
          description: "Required.",
          extensions: {
            protobufField: {
              name: "required_primitives",
              typeFullName: "testapis.primitives.Primitives",
            },
          },
        }),
        optionalPrimitives: t.field({
          type: PrimitivesInput$Ref,
          required: false,
          description: "Optional.",
          extensions: {
            protobufField: {
              name: "optional_primitives",
              typeFullName: "testapis.primitives.Primitives",
            },
          },
        }),
        requiredPrimitivesList: t.field({
          type: [PrimitivesInput$Ref],
          required: { list: true, items: true },
          description: "Required.",
          extensions: {
            protobufField: {
              name: "required_primitives_list",
              typeFullName: "testapis.primitives.Primitives",
            },
          },
        }),
        optionalPrimitivesList: t.field({
          type: [PrimitivesInput$Ref],
          required: { list: false, items: true },
          description: "Optional.",
          extensions: {
            protobufField: {
              name: "optional_primitives_list",
              typeFullName: "testapis.primitives.Primitives",
            },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.primitives.Message",
          name: "Message",
          package: "testapis.primitives",
        },
      },
    },
  );

export function MessageInput$toProto(
  input: MessageInput$Shape | null | undefined,
): Message {
  return new Message({
    requiredPrimitives: input?.requiredPrimitives
      ? PrimitivesInput$toProto(input.requiredPrimitives)
      : undefined,
    optionalPrimitives: input?.optionalPrimitives
      ? PrimitivesInput$toProto(input.optionalPrimitives)
      : undefined,
    requiredPrimitivesList: input?.requiredPrimitivesList?.map((v) =>
      PrimitivesInput$toProto(v)
    ),
    optionalPrimitivesList: input?.optionalPrimitivesList?.map((v) =>
      PrimitivesInput$toProto(v)
    ),
  });
}

export type PrimitivesInput$Shape = {
  requiredDoubleValue: Primitives["requiredDoubleValue"];
  requiredFloatValue: Primitives["requiredFloatValue"];
  requiredInt32Value: Primitives["requiredInt32Value"];
  requiredInt64Value: Primitives["requiredInt64Value"];
  requiredUint32Value: Primitives["requiredUint32Value"];
  requiredUint64Value: Primitives["requiredUint64Value"];
  requiredSint32Value: Primitives["requiredSint32Value"];
  requiredSint64Value: Primitives["requiredSint64Value"];
  requiredFixed32Value: Primitives["requiredFixed32Value"];
  requiredFixed64Value: Primitives["requiredFixed64Value"];
  requiredSfixed32Value: Primitives["requiredSfixed32Value"];
  requiredSfixed64Value: Primitives["requiredSfixed64Value"];
  requiredBoolValue: Primitives["requiredBoolValue"];
  requiredStringValue: Primitives["requiredStringValue"];
  requiredBytesValue: Primitives["requiredBytesValue"];
  requiredDoubleValues: Primitives["requiredDoubleValues"];
  requiredFloatValues: Primitives["requiredFloatValues"];
  requiredInt32Values: Primitives["requiredInt32Values"];
  requiredInt64Values: Primitives["requiredInt64Values"];
  requiredUint32Values: Primitives["requiredUint32Values"];
  requiredUint64Values: Primitives["requiredUint64Values"];
  requiredSint32Values: Primitives["requiredSint32Values"];
  requiredSint64Values: Primitives["requiredSint64Values"];
  requiredFixed32Values: Primitives["requiredFixed32Values"];
  requiredFixed64Values: Primitives["requiredFixed64Values"];
  requiredSfixed32Values: Primitives["requiredSfixed32Values"];
  requiredSfixed64Values: Primitives["requiredSfixed64Values"];
  requiredBoolValues: Primitives["requiredBoolValues"];
  requiredStringValues: Primitives["requiredStringValues"];
  requiredBytesValues: Primitives["requiredBytesValues"];
};

export const PrimitivesInput$Ref: InputObjectRef<PrimitivesInput$Shape> =
  builder.inputRef<PrimitivesInput$Shape>("PrimitivesInput").implement(
    {
      fields: (t) => ({
        requiredDoubleValue: t.field({
          type: "Float",
          required: true,
          extensions: {
            protobufField: {
              name: "required_double_value",
              typeFullName: "double",
            },
          },
        }),
        requiredFloatValue: t.field({
          type: "Float",
          required: true,
          extensions: {
            protobufField: {
              name: "required_float_value",
              typeFullName: "float",
            },
          },
        }),
        requiredInt32Value: t.field({
          type: "Int",
          required: true,
          extensions: {
            protobufField: {
              name: "required_int32_value",
              typeFullName: "int32",
            },
          },
        }),
        requiredInt64Value: t.field({
          type: "Int64",
          required: true,
          extensions: {
            protobufField: {
              name: "required_int64_value",
              typeFullName: "int64",
            },
          },
        }),
        requiredUint32Value: t.field({
          type: "Int",
          required: true,
          extensions: {
            protobufField: {
              name: "required_uint32_value",
              typeFullName: "uint32",
            },
          },
        }),
        requiredUint64Value: t.field({
          type: "Int64",
          required: true,
          extensions: {
            protobufField: {
              name: "required_uint64_value",
              typeFullName: "uint64",
            },
          },
        }),
        requiredSint32Value: t.field({
          type: "Int",
          required: true,
          extensions: {
            protobufField: {
              name: "required_sint32_value",
              typeFullName: "sint32",
            },
          },
        }),
        requiredSint64Value: t.field({
          type: "Int64",
          required: true,
          extensions: {
            protobufField: {
              name: "required_sint64_value",
              typeFullName: "sint64",
            },
          },
        }),
        requiredFixed32Value: t.field({
          type: "Int",
          required: true,
          extensions: {
            protobufField: {
              name: "required_fixed32_value",
              typeFullName: "fixed32",
            },
          },
        }),
        requiredFixed64Value: t.field({
          type: "Int64",
          required: true,
          extensions: {
            protobufField: {
              name: "required_fixed64_value",
              typeFullName: "fixed64",
            },
          },
        }),
        requiredSfixed32Value: t.field({
          type: "Int",
          required: true,
          extensions: {
            protobufField: {
              name: "required_sfixed32_value",
              typeFullName: "sfixed32",
            },
          },
        }),
        requiredSfixed64Value: t.field({
          type: "Int64",
          required: true,
          extensions: {
            protobufField: {
              name: "required_sfixed64_value",
              typeFullName: "sfixed64",
            },
          },
        }),
        requiredBoolValue: t.field({
          type: "Boolean",
          required: true,
          extensions: {
            protobufField: {
              name: "required_bool_value",
              typeFullName: "bool",
            },
          },
        }),
        requiredStringValue: t.field({
          type: "String",
          required: true,
          extensions: {
            protobufField: {
              name: "required_string_value",
              typeFullName: "string",
            },
          },
        }),
        requiredBytesValue: t.field({
          type: "Byte",
          required: true,
          extensions: {
            protobufField: {
              name: "required_bytes_value",
              typeFullName: "bytes",
            },
          },
        }),
        requiredDoubleValues: t.field({
          type: ["Float"],
          required: { list: true, items: true },
          extensions: {
            protobufField: {
              name: "required_double_values",
              typeFullName: "double",
            },
          },
        }),
        requiredFloatValues: t.field({
          type: ["Float"],
          required: { list: true, items: true },
          extensions: {
            protobufField: {
              name: "required_float_values",
              typeFullName: "float",
            },
          },
        }),
        requiredInt32Values: t.field({
          type: ["Int"],
          required: { list: true, items: true },
          extensions: {
            protobufField: {
              name: "required_int32_values",
              typeFullName: "int32",
            },
          },
        }),
        requiredInt64Values: t.field({
          type: ["Int64"],
          required: { list: true, items: true },
          extensions: {
            protobufField: {
              name: "required_int64_values",
              typeFullName: "int64",
            },
          },
        }),
        requiredUint32Values: t.field({
          type: ["Int"],
          required: { list: true, items: true },
          extensions: {
            protobufField: {
              name: "required_uint32_values",
              typeFullName: "uint32",
            },
          },
        }),
        requiredUint64Values: t.field({
          type: ["Int64"],
          required: { list: true, items: true },
          extensions: {
            protobufField: {
              name: "required_uint64_values",
              typeFullName: "uint64",
            },
          },
        }),
        requiredSint32Values: t.field({
          type: ["Int"],
          required: { list: true, items: true },
          extensions: {
            protobufField: {
              name: "required_sint32_values",
              typeFullName: "sint32",
            },
          },
        }),
        requiredSint64Values: t.field({
          type: ["Int64"],
          required: { list: true, items: true },
          extensions: {
            protobufField: {
              name: "required_sint64_values",
              typeFullName: "sint64",
            },
          },
        }),
        requiredFixed32Values: t.field({
          type: ["Int"],
          required: { list: true, items: true },
          extensions: {
            protobufField: {
              name: "required_fixed32_values",
              typeFullName: "fixed32",
            },
          },
        }),
        requiredFixed64Values: t.field({
          type: ["Int64"],
          required: { list: true, items: true },
          extensions: {
            protobufField: {
              name: "required_fixed64_values",
              typeFullName: "fixed64",
            },
          },
        }),
        requiredSfixed32Values: t.field({
          type: ["Int"],
          required: { list: true, items: true },
          extensions: {
            protobufField: {
              name: "required_sfixed32_values",
              typeFullName: "sfixed32",
            },
          },
        }),
        requiredSfixed64Values: t.field({
          type: ["Int64"],
          required: { list: true, items: true },
          extensions: {
            protobufField: {
              name: "required_sfixed64_values",
              typeFullName: "sfixed64",
            },
          },
        }),
        requiredBoolValues: t.field({
          type: ["Boolean"],
          required: { list: true, items: true },
          extensions: {
            protobufField: {
              name: "required_bool_values",
              typeFullName: "bool",
            },
          },
        }),
        requiredStringValues: t.field({
          type: ["String"],
          required: { list: true, items: true },
          extensions: {
            protobufField: {
              name: "required_string_values",
              typeFullName: "string",
            },
          },
        }),
        requiredBytesValues: t.field({
          type: ["Byte"],
          required: { list: true, items: true },
          extensions: {
            protobufField: {
              name: "required_bytes_values",
              typeFullName: "bytes",
            },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.primitives.Primitives",
          name: "Primitives",
          package: "testapis.primitives",
        },
      },
    },
  );

export function PrimitivesInput$toProto(
  input: PrimitivesInput$Shape | null | undefined,
): Primitives {
  return new Primitives({
    requiredDoubleValue: input?.requiredDoubleValue ?? undefined,
    requiredFloatValue: input?.requiredFloatValue ?? undefined,
    requiredInt32Value: input?.requiredInt32Value ?? undefined,
    requiredInt64Value: input?.requiredInt64Value ?? undefined,
    requiredUint32Value: input?.requiredUint32Value ?? undefined,
    requiredUint64Value: input?.requiredUint64Value ?? undefined,
    requiredSint32Value: input?.requiredSint32Value ?? undefined,
    requiredSint64Value: input?.requiredSint64Value ?? undefined,
    requiredFixed32Value: input?.requiredFixed32Value ?? undefined,
    requiredFixed64Value: input?.requiredFixed64Value ?? undefined,
    requiredSfixed32Value: input?.requiredSfixed32Value ?? undefined,
    requiredSfixed64Value: input?.requiredSfixed64Value ?? undefined,
    requiredBoolValue: input?.requiredBoolValue ?? undefined,
    requiredStringValue: input?.requiredStringValue ?? undefined,
    requiredBytesValue: input?.requiredBytesValue ?? undefined,
    requiredDoubleValues: input?.requiredDoubleValues ?? undefined,
    requiredFloatValues: input?.requiredFloatValues ?? undefined,
    requiredInt32Values: input?.requiredInt32Values ?? undefined,
    requiredInt64Values: input?.requiredInt64Values ?? undefined,
    requiredUint32Values: input?.requiredUint32Values ?? undefined,
    requiredUint64Values: input?.requiredUint64Values ?? undefined,
    requiredSint32Values: input?.requiredSint32Values ?? undefined,
    requiredSint64Values: input?.requiredSint64Values ?? undefined,
    requiredFixed32Values: input?.requiredFixed32Values ?? undefined,
    requiredFixed64Values: input?.requiredFixed64Values ?? undefined,
    requiredSfixed32Values: input?.requiredSfixed32Values ?? undefined,
    requiredSfixed64Values: input?.requiredSfixed64Values ?? undefined,
    requiredBoolValues: input?.requiredBoolValues ?? undefined,
    requiredStringValues: input?.requiredStringValues ?? undefined,
    requiredBytesValues: input?.requiredBytesValues ?? undefined,
  });
}
",
    "name": "testapis/primitives/primitives.pb.pothos.ts",
  },
]
`;

exports[`protobuf-es > 'testapis.primitives' > generates files by plugin 'with partial inputs' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/primitives/primitives.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import {
  Message,
  Primitives,
} from "@testapis/protobuf-es/testapis/primitives/primitives_pb";
import { builder } from "../../builder";

export const Message$Ref = builder.objectRef<Message>("Message");
builder.objectType(Message$Ref, {
  name: "Message",
  fields: (t) => ({
    requiredPrimitives: t.field({
      type: Primitives$Ref,
      nullable: false,
      description: "Required.",
      resolve: (source) => {
        return source.requiredPrimitives!;
      },
      extensions: {
        protobufField: {
          name: "required_primitives",
          typeFullName: "testapis.primitives.Primitives",
        },
      },
    }),
    optionalPrimitives: t.expose("optionalPrimitives", {
      type: Primitives$Ref,
      nullable: true,
      description: "Optional.",
      extensions: {
        protobufField: {
          name: "optional_primitives",
          typeFullName: "testapis.primitives.Primitives",
        },
      },
    }),
    requiredPrimitivesList: t.field({
      type: [Primitives$Ref],
      nullable: { list: false, items: false },
      description: "Required.",
      resolve: (source) => {
        return source.requiredPrimitivesList!;
      },
      extensions: {
        protobufField: {
          name: "required_primitives_list",
          typeFullName: "testapis.primitives.Primitives",
        },
      },
    }),
    optionalPrimitivesList: t.expose("optionalPrimitivesList", {
      type: [Primitives$Ref],
      nullable: { list: true, items: false },
      description: "Optional.",
      extensions: {
        protobufField: {
          name: "optional_primitives_list",
          typeFullName: "testapis.primitives.Primitives",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof Message;
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.primitives.Message",
      name: "Message",
      package: "testapis.primitives",
    },
  },
});

export const Primitives$Ref = builder.objectRef<Primitives>("Primitives");
builder.objectType(Primitives$Ref, {
  name: "Primitives",
  fields: (t) => ({
    requiredDoubleValue: t.expose("requiredDoubleValue", {
      type: "Float",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_double_value",
          typeFullName: "double",
        },
      },
    }),
    requiredFloatValue: t.expose("requiredFloatValue", {
      type: "Float",
      nullable: false,
      extensions: {
        protobufField: { name: "required_float_value", typeFullName: "float" },
      },
    }),
    requiredInt32Value: t.expose("requiredInt32Value", {
      type: "Int",
      nullable: false,
      extensions: {
        protobufField: { name: "required_int32_value", typeFullName: "int32" },
      },
    }),
    requiredInt64Value: t.expose("requiredInt64Value", {
      type: "Int64",
      nullable: false,
      extensions: {
        protobufField: { name: "required_int64_value", typeFullName: "int64" },
      },
    }),
    requiredUint32Value: t.expose("requiredUint32Value", {
      type: "Int",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_uint32_value",
          typeFullName: "uint32",
        },
      },
    }),
    requiredUint64Value: t.expose("requiredUint64Value", {
      type: "Int64",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_uint64_value",
          typeFullName: "uint64",
        },
      },
    }),
    requiredSint32Value: t.expose("requiredSint32Value", {
      type: "Int",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_sint32_value",
          typeFullName: "sint32",
        },
      },
    }),
    requiredSint64Value: t.expose("requiredSint64Value", {
      type: "Int64",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_sint64_value",
          typeFullName: "sint64",
        },
      },
    }),
    requiredFixed32Value: t.expose("requiredFixed32Value", {
      type: "Int",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_fixed32_value",
          typeFullName: "fixed32",
        },
      },
    }),
    requiredFixed64Value: t.expose("requiredFixed64Value", {
      type: "Int64",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_fixed64_value",
          typeFullName: "fixed64",
        },
      },
    }),
    requiredSfixed32Value: t.expose("requiredSfixed32Value", {
      type: "Int",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_sfixed32_value",
          typeFullName: "sfixed32",
        },
      },
    }),
    requiredSfixed64Value: t.expose("requiredSfixed64Value", {
      type: "Int64",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_sfixed64_value",
          typeFullName: "sfixed64",
        },
      },
    }),
    requiredBoolValue: t.expose("requiredBoolValue", {
      type: "Boolean",
      nullable: false,
      extensions: {
        protobufField: { name: "required_bool_value", typeFullName: "bool" },
      },
    }),
    requiredStringValue: t.expose("requiredStringValue", {
      type: "String",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_string_value",
          typeFullName: "string",
        },
      },
    }),
    requiredBytesValue: t.field({
      type: "Byte",
      nullable: false,
      resolve: (source) => {
        return Buffer.from(source.requiredBytesValue);
      },
      extensions: {
        protobufField: { name: "required_bytes_value", typeFullName: "bytes" },
      },
    }),
    requiredDoubleValues: t.expose("requiredDoubleValues", {
      type: ["Float"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: {
          name: "required_double_values",
          typeFullName: "double",
        },
      },
    }),
    requiredFloatValues: t.expose("requiredFloatValues", {
      type: ["Float"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: { name: "required_float_values", typeFullName: "float" },
      },
    }),
    requiredInt32Values: t.expose("requiredInt32Values", {
      type: ["Int"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: { name: "required_int32_values", typeFullName: "int32" },
      },
    }),
    requiredInt64Values: t.expose("requiredInt64Values", {
      type: ["Int64"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: { name: "required_int64_values", typeFullName: "int64" },
      },
    }),
    requiredUint32Values: t.expose("requiredUint32Values", {
      type: ["Int"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: {
          name: "required_uint32_values",
          typeFullName: "uint32",
        },
      },
    }),
    requiredUint64Values: t.expose("requiredUint64Values", {
      type: ["Int64"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: {
          name: "required_uint64_values",
          typeFullName: "uint64",
        },
      },
    }),
    requiredSint32Values: t.expose("requiredSint32Values", {
      type: ["Int"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: {
          name: "required_sint32_values",
          typeFullName: "sint32",
        },
      },
    }),
    requiredSint64Values: t.expose("requiredSint64Values", {
      type: ["Int64"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: {
          name: "required_sint64_values",
          typeFullName: "sint64",
        },
      },
    }),
    requiredFixed32Values: t.expose("requiredFixed32Values", {
      type: ["Int"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: {
          name: "required_fixed32_values",
          typeFullName: "fixed32",
        },
      },
    }),
    requiredFixed64Values: t.expose("requiredFixed64Values", {
      type: ["Int64"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: {
          name: "required_fixed64_values",
          typeFullName: "fixed64",
        },
      },
    }),
    requiredSfixed32Values: t.expose("requiredSfixed32Values", {
      type: ["Int"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: {
          name: "required_sfixed32_values",
          typeFullName: "sfixed32",
        },
      },
    }),
    requiredSfixed64Values: t.expose("requiredSfixed64Values", {
      type: ["Int64"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: {
          name: "required_sfixed64_values",
          typeFullName: "sfixed64",
        },
      },
    }),
    requiredBoolValues: t.expose("requiredBoolValues", {
      type: ["Boolean"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: { name: "required_bool_values", typeFullName: "bool" },
      },
    }),
    requiredStringValues: t.expose("requiredStringValues", {
      type: ["String"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: {
          name: "required_string_values",
          typeFullName: "string",
        },
      },
    }),
    requiredBytesValues: t.field({
      type: ["Byte"],
      nullable: { list: false, items: false },
      resolve: (source) => {
        return source.requiredBytesValues.map((v) => Buffer.from(v));
      },
      extensions: {
        protobufField: { name: "required_bytes_values", typeFullName: "bytes" },
      },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof Primitives;
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.primitives.Primitives",
      name: "Primitives",
      package: "testapis.primitives",
    },
  },
});

export type MessageInput$Shape = {
  requiredPrimitives: PrimitivesInput$Shape;
  optionalPrimitives?: PrimitivesInput$Shape | null;
  requiredPrimitivesList: Array<PrimitivesInput$Shape>;
  optionalPrimitivesList?: Array<PrimitivesInput$Shape> | null;
};

export const MessageInput$Ref: InputObjectRef<MessageInput$Shape> = builder
  .inputRef<MessageInput$Shape>("MessageInput").implement(
    {
      fields: (t) => ({
        requiredPrimitives: t.field({
          type: PrimitivesInput$Ref,
          required: true,
          description: "Required.",
          extensions: {
            protobufField: {
              name: "required_primitives",
              typeFullName: "testapis.primitives.Primitives",
            },
          },
        }),
        optionalPrimitives: t.field({
          type: PrimitivesInput$Ref,
          required: false,
          description: "Optional.",
          extensions: {
            protobufField: {
              name: "optional_primitives",
              typeFullName: "testapis.primitives.Primitives",
            },
          },
        }),
        requiredPrimitivesList: t.field({
          type: [PrimitivesInput$Ref],
          required: { list: true, items: true },
          description: "Required.",
          extensions: {
            protobufField: {
              name: "required_primitives_list",
              typeFullName: "testapis.primitives.Primitives",
            },
          },
        }),
        optionalPrimitivesList: t.field({
          type: [PrimitivesInput$Ref],
          required: { list: false, items: true },
          description: "Optional.",
          extensions: {
            protobufField: {
              name: "optional_primitives_list",
              typeFullName: "testapis.primitives.Primitives",
            },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.primitives.Message",
          name: "Message",
          package: "testapis.primitives",
        },
      },
    },
  );

export function MessageInput$toProto(
  input: MessageInput$Shape | null | undefined,
): Message {
  return new Message({
    requiredPrimitives: input?.requiredPrimitives
      ? PrimitivesInput$toProto(input.requiredPrimitives)
      : undefined,
    optionalPrimitives: input?.optionalPrimitives
      ? PrimitivesInput$toProto(input.optionalPrimitives)
      : undefined,
    requiredPrimitivesList: input?.requiredPrimitivesList?.map((v) =>
      PrimitivesInput$toProto(v)
    ),
    optionalPrimitivesList: input?.optionalPrimitivesList?.map((v) =>
      PrimitivesInput$toProto(v)
    ),
  });
}

export type MessagePartialInput$Shape = {
  requiredPrimitives?: PrimitivesPartialInput$Shape | null;
  optionalPrimitives?: PrimitivesPartialInput$Shape | null;
  requiredPrimitivesList?: Array<PrimitivesPartialInput$Shape> | null;
  optionalPrimitivesList?: Array<PrimitivesPartialInput$Shape> | null;
};

export const MessagePartialInput$Ref: InputObjectRef<
  MessagePartialInput$Shape
> = builder.inputRef<MessagePartialInput$Shape>("MessagePartialInput")
  .implement(
    {
      fields: (t) => ({
        requiredPrimitives: t.field({
          type: PrimitivesPartialInput$Ref,
          required: false,
          description: "Required.",
          extensions: {
            protobufField: {
              name: "required_primitives",
              typeFullName: "testapis.primitives.Primitives",
            },
          },
        }),
        optionalPrimitives: t.field({
          type: PrimitivesPartialInput$Ref,
          required: false,
          description: "Optional.",
          extensions: {
            protobufField: {
              name: "optional_primitives",
              typeFullName: "testapis.primitives.Primitives",
            },
          },
        }),
        requiredPrimitivesList: t.field({
          type: [PrimitivesPartialInput$Ref],
          required: { list: false, items: true },
          description: "Required.",
          extensions: {
            protobufField: {
              name: "required_primitives_list",
              typeFullName: "testapis.primitives.Primitives",
            },
          },
        }),
        optionalPrimitivesList: t.field({
          type: [PrimitivesPartialInput$Ref],
          required: { list: false, items: true },
          description: "Optional.",
          extensions: {
            protobufField: {
              name: "optional_primitives_list",
              typeFullName: "testapis.primitives.Primitives",
            },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.primitives.Message",
          name: "Message",
          package: "testapis.primitives",
        },
      },
    },
  );

export function MessagePartialInput$toProto(
  input: MessagePartialInput$Shape | null | undefined,
): Message {
  return new Message({
    requiredPrimitives: input?.requiredPrimitives
      ? PrimitivesPartialInput$toProto(input.requiredPrimitives)
      : undefined,
    optionalPrimitives: input?.optionalPrimitives
      ? PrimitivesPartialInput$toProto(input.optionalPrimitives)
      : undefined,
    requiredPrimitivesList: input?.requiredPrimitivesList?.map((v) =>
      PrimitivesPartialInput$toProto(v)
    ),
    optionalPrimitivesList: input?.optionalPrimitivesList?.map((v) =>
      PrimitivesPartialInput$toProto(v)
    ),
  });
}

export type PrimitivesInput$Shape = {
  requiredDoubleValue: Primitives["requiredDoubleValue"];
  requiredFloatValue: Primitives["requiredFloatValue"];
  requiredInt32Value: Primitives["requiredInt32Value"];
  requiredInt64Value: Primitives["requiredInt64Value"];
  requiredUint32Value: Primitives["requiredUint32Value"];
  requiredUint64Value: Primitives["requiredUint64Value"];
  requiredSint32Value: Primitives["requiredSint32Value"];
  requiredSint64Value: Primitives["requiredSint64Value"];
  requiredFixed32Value: Primitives["requiredFixed32Value"];
  requiredFixed64Value: Primitives["requiredFixed64Value"];
  requiredSfixed32Value: Primitives["requiredSfixed32Value"];
  requiredSfixed64Value: Primitives["requiredSfixed64Value"];
  requiredBoolValue: Primitives["requiredBoolValue"];
  requiredStringValue: Primitives["requiredStringValue"];
  requiredBytesValue: Primitives["requiredBytesValue"];
  requiredDoubleValues: Primitives["requiredDoubleValues"];
  requiredFloatValues: Primitives["requiredFloatValues"];
  requiredInt32Values: Primitives["requiredInt32Values"];
  requiredInt64Values: Primitives["requiredInt64Values"];
  requiredUint32Values: Primitives["requiredUint32Values"];
  requiredUint64Values: Primitives["requiredUint64Values"];
  requiredSint32Values: Primitives["requiredSint32Values"];
  requiredSint64Values: Primitives["requiredSint64Values"];
  requiredFixed32Values: Primitives["requiredFixed32Values"];
  requiredFixed64Values: Primitives["requiredFixed64Values"];
  requiredSfixed32Values: Primitives["requiredSfixed32Values"];
  requiredSfixed64Values: Primitives["requiredSfixed64Values"];
  requiredBoolValues: Primitives["requiredBoolValues"];
  requiredStringValues: Primitives["requiredStringValues"];
  requiredBytesValues: Primitives["requiredBytesValues"];
};

export const PrimitivesInput$Ref: InputObjectRef<PrimitivesInput$Shape> =
  builder.inputRef<PrimitivesInput$Shape>("PrimitivesInput").implement(
    {
      fields: (t) => ({
        requiredDoubleValue: t.field({
          type: "Float",
          required: true,
          extensions: {
            protobufField: {
              name: "required_double_value",
              typeFullName: "double",
            },
          },
        }),
        requiredFloatValue: t.field({
          type: "Float",
          required: true,
          extensions: {
            protobufField: {
              name: "required_float_value",
              typeFullName: "float",
            },
          },
        }),
        requiredInt32Value: t.field({
          type: "Int",
          required: true,
          extensions: {
            protobufField: {
              name: "required_int32_value",
              typeFullName: "int32",
            },
          },
        }),
        requiredInt64Value: t.field({
          type: "Int64",
          required: true,
          extensions: {
            protobufField: {
              name: "required_int64_value",
              typeFullName: "int64",
            },
          },
        }),
        requiredUint32Value: t.field({
          type: "Int",
          required: true,
          extensions: {
            protobufField: {
              name: "required_uint32_value",
              typeFullName: "uint32",
            },
          },
        }),
        requiredUint64Value: t.field({
          type: "Int64",
          required: true,
          extensions: {
            protobufField: {
              name: "required_uint64_value",
              typeFullName: "uint64",
            },
          },
        }),
        requiredSint32Value: t.field({
          type: "Int",
          required: true,
          extensions: {
            protobufField: {
              name: "required_sint32_value",
              typeFullName: "sint32",
            },
          },
        }),
        requiredSint64Value: t.field({
          type: "Int64",
          required: true,
          extensions: {
            protobufField: {
              name: "required_sint64_value",
              typeFullName: "sint64",
            },
          },
        }),
        requiredFixed32Value: t.field({
          type: "Int",
          required: true,
          extensions: {
            protobufField: {
              name: "required_fixed32_value",
              typeFullName: "fixed32",
            },
          },
        }),
        requiredFixed64Value: t.field({
          type: "Int64",
          required: true,
          extensions: {
            protobufField: {
              name: "required_fixed64_value",
              typeFullName: "fixed64",
            },
          },
        }),
        requiredSfixed32Value: t.field({
          type: "Int",
          required: true,
          extensions: {
            protobufField: {
              name: "required_sfixed32_value",
              typeFullName: "sfixed32",
            },
          },
        }),
        requiredSfixed64Value: t.field({
          type: "Int64",
          required: true,
          extensions: {
            protobufField: {
              name: "required_sfixed64_value",
              typeFullName: "sfixed64",
            },
          },
        }),
        requiredBoolValue: t.field({
          type: "Boolean",
          required: true,
          extensions: {
            protobufField: {
              name: "required_bool_value",
              typeFullName: "bool",
            },
          },
        }),
        requiredStringValue: t.field({
          type: "String",
          required: true,
          extensions: {
            protobufField: {
              name: "required_string_value",
              typeFullName: "string",
            },
          },
        }),
        requiredBytesValue: t.field({
          type: "Byte",
          required: true,
          extensions: {
            protobufField: {
              name: "required_bytes_value",
              typeFullName: "bytes",
            },
          },
        }),
        requiredDoubleValues: t.field({
          type: ["Float"],
          required: { list: true, items: true },
          extensions: {
            protobufField: {
              name: "required_double_values",
              typeFullName: "double",
            },
          },
        }),
        requiredFloatValues: t.field({
          type: ["Float"],
          required: { list: true, items: true },
          extensions: {
            protobufField: {
              name: "required_float_values",
              typeFullName: "float",
            },
          },
        }),
        requiredInt32Values: t.field({
          type: ["Int"],
          required: { list: true, items: true },
          extensions: {
            protobufField: {
              name: "required_int32_values",
              typeFullName: "int32",
            },
          },
        }),
        requiredInt64Values: t.field({
          type: ["Int64"],
          required: { list: true, items: true },
          extensions: {
            protobufField: {
              name: "required_int64_values",
              typeFullName: "int64",
            },
          },
        }),
        requiredUint32Values: t.field({
          type: ["Int"],
          required: { list: true, items: true },
          extensions: {
            protobufField: {
              name: "required_uint32_values",
              typeFullName: "uint32",
            },
          },
        }),
        requiredUint64Values: t.field({
          type: ["Int64"],
          required: { list: true, items: true },
          extensions: {
            protobufField: {
              name: "required_uint64_values",
              typeFullName: "uint64",
            },
          },
        }),
        requiredSint32Values: t.field({
          type: ["Int"],
          required: { list: true, items: true },
          extensions: {
            protobufField: {
              name: "required_sint32_values",
              typeFullName: "sint32",
            },
          },
        }),
        requiredSint64Values: t.field({
          type: ["Int64"],
          required: { list: true, items: true },
          extensions: {
            protobufField: {
              name: "required_sint64_values",
              typeFullName: "sint64",
            },
          },
        }),
        requiredFixed32Values: t.field({
          type: ["Int"],
          required: { list: true, items: true },
          extensions: {
            protobufField: {
              name: "required_fixed32_values",
              typeFullName: "fixed32",
            },
          },
        }),
        requiredFixed64Values: t.field({
          type: ["Int64"],
          required: { list: true, items: true },
          extensions: {
            protobufField: {
              name: "required_fixed64_values",
              typeFullName: "fixed64",
            },
          },
        }),
        requiredSfixed32Values: t.field({
          type: ["Int"],
          required: { list: true, items: true },
          extensions: {
            protobufField: {
              name: "required_sfixed32_values",
              typeFullName: "sfixed32",
            },
          },
        }),
        requiredSfixed64Values: t.field({
          type: ["Int64"],
          required: { list: true, items: true },
          extensions: {
            protobufField: {
              name: "required_sfixed64_values",
              typeFullName: "sfixed64",
            },
          },
        }),
        requiredBoolValues: t.field({
          type: ["Boolean"],
          required: { list: true, items: true },
          extensions: {
            protobufField: {
              name: "required_bool_values",
              typeFullName: "bool",
            },
          },
        }),
        requiredStringValues: t.field({
          type: ["String"],
          required: { list: true, items: true },
          extensions: {
            protobufField: {
              name: "required_string_values",
              typeFullName: "string",
            },
          },
        }),
        requiredBytesValues: t.field({
          type: ["Byte"],
          required: { list: true, items: true },
          extensions: {
            protobufField: {
              name: "required_bytes_values",
              typeFullName: "bytes",
            },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.primitives.Primitives",
          name: "Primitives",
          package: "testapis.primitives",
        },
      },
    },
  );

export function PrimitivesInput$toProto(
  input: PrimitivesInput$Shape | null | undefined,
): Primitives {
  return new Primitives({
    requiredDoubleValue: input?.requiredDoubleValue ?? undefined,
    requiredFloatValue: input?.requiredFloatValue ?? undefined,
    requiredInt32Value: input?.requiredInt32Value ?? undefined,
    requiredInt64Value: input?.requiredInt64Value ?? undefined,
    requiredUint32Value: input?.requiredUint32Value ?? undefined,
    requiredUint64Value: input?.requiredUint64Value ?? undefined,
    requiredSint32Value: input?.requiredSint32Value ?? undefined,
    requiredSint64Value: input?.requiredSint64Value ?? undefined,
    requiredFixed32Value: input?.requiredFixed32Value ?? undefined,
    requiredFixed64Value: input?.requiredFixed64Value ?? undefined,
    requiredSfixed32Value: input?.requiredSfixed32Value ?? undefined,
    requiredSfixed64Value: input?.requiredSfixed64Value ?? undefined,
    requiredBoolValue: input?.requiredBoolValue ?? undefined,
    requiredStringValue: input?.requiredStringValue ?? undefined,
    requiredBytesValue: input?.requiredBytesValue ?? undefined,
    requiredDoubleValues: input?.requiredDoubleValues ?? undefined,
    requiredFloatValues: input?.requiredFloatValues ?? undefined,
    requiredInt32Values: input?.requiredInt32Values ?? undefined,
    requiredInt64Values: input?.requiredInt64Values ?? undefined,
    requiredUint32Values: input?.requiredUint32Values ?? undefined,
    requiredUint64Values: input?.requiredUint64Values ?? undefined,
    requiredSint32Values: input?.requiredSint32Values ?? undefined,
    requiredSint64Values: input?.requiredSint64Values ?? undefined,
    requiredFixed32Values: input?.requiredFixed32Values ?? undefined,
    requiredFixed64Values: input?.requiredFixed64Values ?? undefined,
    requiredSfixed32Values: input?.requiredSfixed32Values ?? undefined,
    requiredSfixed64Values: input?.requiredSfixed64Values ?? undefined,
    requiredBoolValues: input?.requiredBoolValues ?? undefined,
    requiredStringValues: input?.requiredStringValues ?? undefined,
    requiredBytesValues: input?.requiredBytesValues ?? undefined,
  });
}

export type PrimitivesPartialInput$Shape = {
  requiredDoubleValue?: Primitives["requiredDoubleValue"] | null;
  requiredFloatValue?: Primitives["requiredFloatValue"] | null;
  requiredInt32Value?: Primitives["requiredInt32Value"] | null;
  requiredInt64Value?: Primitives["requiredInt64Value"] | null;
  requiredUint32Value?: Primitives["requiredUint32Value"] | null;
  requiredUint64Value?: Primitives["requiredUint64Value"] | null;
  requiredSint32Value?: Primitives["requiredSint32Value"] | null;
  requiredSint64Value?: Primitives["requiredSint64Value"] | null;
  requiredFixed32Value?: Primitives["requiredFixed32Value"] | null;
  requiredFixed64Value?: Primitives["requiredFixed64Value"] | null;
  requiredSfixed32Value?: Primitives["requiredSfixed32Value"] | null;
  requiredSfixed64Value?: Primitives["requiredSfixed64Value"] | null;
  requiredBoolValue?: Primitives["requiredBoolValue"] | null;
  requiredStringValue?: Primitives["requiredStringValue"] | null;
  requiredBytesValue?: Primitives["requiredBytesValue"] | null;
  requiredDoubleValues?: Primitives["requiredDoubleValues"] | null;
  requiredFloatValues?: Primitives["requiredFloatValues"] | null;
  requiredInt32Values?: Primitives["requiredInt32Values"] | null;
  requiredInt64Values?: Primitives["requiredInt64Values"] | null;
  requiredUint32Values?: Primitives["requiredUint32Values"] | null;
  requiredUint64Values?: Primitives["requiredUint64Values"] | null;
  requiredSint32Values?: Primitives["requiredSint32Values"] | null;
  requiredSint64Values?: Primitives["requiredSint64Values"] | null;
  requiredFixed32Values?: Primitives["requiredFixed32Values"] | null;
  requiredFixed64Values?: Primitives["requiredFixed64Values"] | null;
  requiredSfixed32Values?: Primitives["requiredSfixed32Values"] | null;
  requiredSfixed64Values?: Primitives["requiredSfixed64Values"] | null;
  requiredBoolValues?: Primitives["requiredBoolValues"] | null;
  requiredStringValues?: Primitives["requiredStringValues"] | null;
  requiredBytesValues?: Primitives["requiredBytesValues"] | null;
};

export const PrimitivesPartialInput$Ref: InputObjectRef<
  PrimitivesPartialInput$Shape
> = builder.inputRef<PrimitivesPartialInput$Shape>("PrimitivesPartialInput")
  .implement(
    {
      fields: (t) => ({
        requiredDoubleValue: t.field({
          type: "Float",
          required: false,
          extensions: {
            protobufField: {
              name: "required_double_value",
              typeFullName: "double",
            },
          },
        }),
        requiredFloatValue: t.field({
          type: "Float",
          required: false,
          extensions: {
            protobufField: {
              name: "required_float_value",
              typeFullName: "float",
            },
          },
        }),
        requiredInt32Value: t.field({
          type: "Int",
          required: false,
          extensions: {
            protobufField: {
              name: "required_int32_value",
              typeFullName: "int32",
            },
          },
        }),
        requiredInt64Value: t.field({
          type: "Int64",
          required: false,
          extensions: {
            protobufField: {
              name: "required_int64_value",
              typeFullName: "int64",
            },
          },
        }),
        requiredUint32Value: t.field({
          type: "Int",
          required: false,
          extensions: {
            protobufField: {
              name: "required_uint32_value",
              typeFullName: "uint32",
            },
          },
        }),
        requiredUint64Value: t.field({
          type: "Int64",
          required: false,
          extensions: {
            protobufField: {
              name: "required_uint64_value",
              typeFullName: "uint64",
            },
          },
        }),
        requiredSint32Value: t.field({
          type: "Int",
          required: false,
          extensions: {
            protobufField: {
              name: "required_sint32_value",
              typeFullName: "sint32",
            },
          },
        }),
        requiredSint64Value: t.field({
          type: "Int64",
          required: false,
          extensions: {
            protobufField: {
              name: "required_sint64_value",
              typeFullName: "sint64",
            },
          },
        }),
        requiredFixed32Value: t.field({
          type: "Int",
          required: false,
          extensions: {
            protobufField: {
              name: "required_fixed32_value",
              typeFullName: "fixed32",
            },
          },
        }),
        requiredFixed64Value: t.field({
          type: "Int64",
          required: false,
          extensions: {
            protobufField: {
              name: "required_fixed64_value",
              typeFullName: "fixed64",
            },
          },
        }),
        requiredSfixed32Value: t.field({
          type: "Int",
          required: false,
          extensions: {
            protobufField: {
              name: "required_sfixed32_value",
              typeFullName: "sfixed32",
            },
          },
        }),
        requiredSfixed64Value: t.field({
          type: "Int64",
          required: false,
          extensions: {
            protobufField: {
              name: "required_sfixed64_value",
              typeFullName: "sfixed64",
            },
          },
        }),
        requiredBoolValue: t.field({
          type: "Boolean",
          required: false,
          extensions: {
            protobufField: {
              name: "required_bool_value",
              typeFullName: "bool",
            },
          },
        }),
        requiredStringValue: t.field({
          type: "String",
          required: false,
          extensions: {
            protobufField: {
              name: "required_string_value",
              typeFullName: "string",
            },
          },
        }),
        requiredBytesValue: t.field({
          type: "Byte",
          required: false,
          extensions: {
            protobufField: {
              name: "required_bytes_value",
              typeFullName: "bytes",
            },
          },
        }),
        requiredDoubleValues: t.field({
          type: ["Float"],
          required: { list: false, items: true },
          extensions: {
            protobufField: {
              name: "required_double_values",
              typeFullName: "double",
            },
          },
        }),
        requiredFloatValues: t.field({
          type: ["Float"],
          required: { list: false, items: true },
          extensions: {
            protobufField: {
              name: "required_float_values",
              typeFullName: "float",
            },
          },
        }),
        requiredInt32Values: t.field({
          type: ["Int"],
          required: { list: false, items: true },
          extensions: {
            protobufField: {
              name: "required_int32_values",
              typeFullName: "int32",
            },
          },
        }),
        requiredInt64Values: t.field({
          type: ["Int64"],
          required: { list: false, items: true },
          extensions: {
            protobufField: {
              name: "required_int64_values",
              typeFullName: "int64",
            },
          },
        }),
        requiredUint32Values: t.field({
          type: ["Int"],
          required: { list: false, items: true },
          extensions: {
            protobufField: {
              name: "required_uint32_values",
              typeFullName: "uint32",
            },
          },
        }),
        requiredUint64Values: t.field({
          type: ["Int64"],
          required: { list: false, items: true },
          extensions: {
            protobufField: {
              name: "required_uint64_values",
              typeFullName: "uint64",
            },
          },
        }),
        requiredSint32Values: t.field({
          type: ["Int"],
          required: { list: false, items: true },
          extensions: {
            protobufField: {
              name: "required_sint32_values",
              typeFullName: "sint32",
            },
          },
        }),
        requiredSint64Values: t.field({
          type: ["Int64"],
          required: { list: false, items: true },
          extensions: {
            protobufField: {
              name: "required_sint64_values",
              typeFullName: "sint64",
            },
          },
        }),
        requiredFixed32Values: t.field({
          type: ["Int"],
          required: { list: false, items: true },
          extensions: {
            protobufField: {
              name: "required_fixed32_values",
              typeFullName: "fixed32",
            },
          },
        }),
        requiredFixed64Values: t.field({
          type: ["Int64"],
          required: { list: false, items: true },
          extensions: {
            protobufField: {
              name: "required_fixed64_values",
              typeFullName: "fixed64",
            },
          },
        }),
        requiredSfixed32Values: t.field({
          type: ["Int"],
          required: { list: false, items: true },
          extensions: {
            protobufField: {
              name: "required_sfixed32_values",
              typeFullName: "sfixed32",
            },
          },
        }),
        requiredSfixed64Values: t.field({
          type: ["Int64"],
          required: { list: false, items: true },
          extensions: {
            protobufField: {
              name: "required_sfixed64_values",
              typeFullName: "sfixed64",
            },
          },
        }),
        requiredBoolValues: t.field({
          type: ["Boolean"],
          required: { list: false, items: true },
          extensions: {
            protobufField: {
              name: "required_bool_values",
              typeFullName: "bool",
            },
          },
        }),
        requiredStringValues: t.field({
          type: ["String"],
          required: { list: false, items: true },
          extensions: {
            protobufField: {
              name: "required_string_values",
              typeFullName: "string",
            },
          },
        }),
        requiredBytesValues: t.field({
          type: ["Byte"],
          required: { list: false, items: true },
          extensions: {
            protobufField: {
              name: "required_bytes_values",
              typeFullName: "bytes",
            },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.primitives.Primitives",
          name: "Primitives",
          package: "testapis.primitives",
        },
      },
    },
  );

export function PrimitivesPartialInput$toProto(
  input: PrimitivesPartialInput$Shape | null | undefined,
): Primitives {
  return new Primitives({
    requiredDoubleValue: input?.requiredDoubleValue ?? undefined,
    requiredFloatValue: input?.requiredFloatValue ?? undefined,
    requiredInt32Value: input?.requiredInt32Value ?? undefined,
    requiredInt64Value: input?.requiredInt64Value ?? undefined,
    requiredUint32Value: input?.requiredUint32Value ?? undefined,
    requiredUint64Value: input?.requiredUint64Value ?? undefined,
    requiredSint32Value: input?.requiredSint32Value ?? undefined,
    requiredSint64Value: input?.requiredSint64Value ?? undefined,
    requiredFixed32Value: input?.requiredFixed32Value ?? undefined,
    requiredFixed64Value: input?.requiredFixed64Value ?? undefined,
    requiredSfixed32Value: input?.requiredSfixed32Value ?? undefined,
    requiredSfixed64Value: input?.requiredSfixed64Value ?? undefined,
    requiredBoolValue: input?.requiredBoolValue ?? undefined,
    requiredStringValue: input?.requiredStringValue ?? undefined,
    requiredBytesValue: input?.requiredBytesValue ?? undefined,
    requiredDoubleValues: input?.requiredDoubleValues ?? undefined,
    requiredFloatValues: input?.requiredFloatValues ?? undefined,
    requiredInt32Values: input?.requiredInt32Values ?? undefined,
    requiredInt64Values: input?.requiredInt64Values ?? undefined,
    requiredUint32Values: input?.requiredUint32Values ?? undefined,
    requiredUint64Values: input?.requiredUint64Values ?? undefined,
    requiredSint32Values: input?.requiredSint32Values ?? undefined,
    requiredSint64Values: input?.requiredSint64Values ?? undefined,
    requiredFixed32Values: input?.requiredFixed32Values ?? undefined,
    requiredFixed64Values: input?.requiredFixed64Values ?? undefined,
    requiredSfixed32Values: input?.requiredSfixed32Values ?? undefined,
    requiredSfixed64Values: input?.requiredSfixed64Values ?? undefined,
    requiredBoolValues: input?.requiredBoolValues ?? undefined,
    requiredStringValues: input?.requiredStringValues ?? undefined,
    requiredBytesValues: input?.requiredBytesValues ?? undefined,
  });
}
",
    "name": "testapis/primitives/primitives.pb.pothos.ts",
  },
]
`;

exports[`protobuf-es > 'testapis.primitives' > generates files by plugin 'without import prefix' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/primitives/primitives.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { builder } from "../../builder";
import { Message, Primitives } from "./testapis/primitives/primitives_pb";

export const Message$Ref = builder.objectRef<Message>("Message");
builder.objectType(Message$Ref, {
  name: "Message",
  fields: (t) => ({
    requiredPrimitives: t.field({
      type: Primitives$Ref,
      nullable: false,
      description: "Required.",
      resolve: (source) => {
        return source.requiredPrimitives!;
      },
      extensions: {
        protobufField: {
          name: "required_primitives",
          typeFullName: "testapis.primitives.Primitives",
        },
      },
    }),
    optionalPrimitives: t.expose("optionalPrimitives", {
      type: Primitives$Ref,
      nullable: true,
      description: "Optional.",
      extensions: {
        protobufField: {
          name: "optional_primitives",
          typeFullName: "testapis.primitives.Primitives",
        },
      },
    }),
    requiredPrimitivesList: t.field({
      type: [Primitives$Ref],
      nullable: { list: false, items: false },
      description: "Required.",
      resolve: (source) => {
        return source.requiredPrimitivesList!;
      },
      extensions: {
        protobufField: {
          name: "required_primitives_list",
          typeFullName: "testapis.primitives.Primitives",
        },
      },
    }),
    optionalPrimitivesList: t.expose("optionalPrimitivesList", {
      type: [Primitives$Ref],
      nullable: { list: true, items: false },
      description: "Optional.",
      extensions: {
        protobufField: {
          name: "optional_primitives_list",
          typeFullName: "testapis.primitives.Primitives",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof Message;
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.primitives.Message",
      name: "Message",
      package: "testapis.primitives",
    },
  },
});

export const Primitives$Ref = builder.objectRef<Primitives>("Primitives");
builder.objectType(Primitives$Ref, {
  name: "Primitives",
  fields: (t) => ({
    requiredDoubleValue: t.expose("requiredDoubleValue", {
      type: "Float",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_double_value",
          typeFullName: "double",
        },
      },
    }),
    requiredFloatValue: t.expose("requiredFloatValue", {
      type: "Float",
      nullable: false,
      extensions: {
        protobufField: { name: "required_float_value", typeFullName: "float" },
      },
    }),
    requiredInt32Value: t.expose("requiredInt32Value", {
      type: "Int",
      nullable: false,
      extensions: {
        protobufField: { name: "required_int32_value", typeFullName: "int32" },
      },
    }),
    requiredInt64Value: t.expose("requiredInt64Value", {
      type: "Int64",
      nullable: false,
      extensions: {
        protobufField: { name: "required_int64_value", typeFullName: "int64" },
      },
    }),
    requiredUint32Value: t.expose("requiredUint32Value", {
      type: "Int",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_uint32_value",
          typeFullName: "uint32",
        },
      },
    }),
    requiredUint64Value: t.expose("requiredUint64Value", {
      type: "Int64",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_uint64_value",
          typeFullName: "uint64",
        },
      },
    }),
    requiredSint32Value: t.expose("requiredSint32Value", {
      type: "Int",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_sint32_value",
          typeFullName: "sint32",
        },
      },
    }),
    requiredSint64Value: t.expose("requiredSint64Value", {
      type: "Int64",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_sint64_value",
          typeFullName: "sint64",
        },
      },
    }),
    requiredFixed32Value: t.expose("requiredFixed32Value", {
      type: "Int",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_fixed32_value",
          typeFullName: "fixed32",
        },
      },
    }),
    requiredFixed64Value: t.expose("requiredFixed64Value", {
      type: "Int64",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_fixed64_value",
          typeFullName: "fixed64",
        },
      },
    }),
    requiredSfixed32Value: t.expose("requiredSfixed32Value", {
      type: "Int",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_sfixed32_value",
          typeFullName: "sfixed32",
        },
      },
    }),
    requiredSfixed64Value: t.expose("requiredSfixed64Value", {
      type: "Int64",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_sfixed64_value",
          typeFullName: "sfixed64",
        },
      },
    }),
    requiredBoolValue: t.expose("requiredBoolValue", {
      type: "Boolean",
      nullable: false,
      extensions: {
        protobufField: { name: "required_bool_value", typeFullName: "bool" },
      },
    }),
    requiredStringValue: t.expose("requiredStringValue", {
      type: "String",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_string_value",
          typeFullName: "string",
        },
      },
    }),
    requiredBytesValue: t.field({
      type: "Byte",
      nullable: false,
      resolve: (source) => {
        return Buffer.from(source.requiredBytesValue);
      },
      extensions: {
        protobufField: { name: "required_bytes_value", typeFullName: "bytes" },
      },
    }),
    requiredDoubleValues: t.expose("requiredDoubleValues", {
      type: ["Float"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: {
          name: "required_double_values",
          typeFullName: "double",
        },
      },
    }),
    requiredFloatValues: t.expose("requiredFloatValues", {
      type: ["Float"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: { name: "required_float_values", typeFullName: "float" },
      },
    }),
    requiredInt32Values: t.expose("requiredInt32Values", {
      type: ["Int"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: { name: "required_int32_values", typeFullName: "int32" },
      },
    }),
    requiredInt64Values: t.expose("requiredInt64Values", {
      type: ["Int64"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: { name: "required_int64_values", typeFullName: "int64" },
      },
    }),
    requiredUint32Values: t.expose("requiredUint32Values", {
      type: ["Int"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: {
          name: "required_uint32_values",
          typeFullName: "uint32",
        },
      },
    }),
    requiredUint64Values: t.expose("requiredUint64Values", {
      type: ["Int64"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: {
          name: "required_uint64_values",
          typeFullName: "uint64",
        },
      },
    }),
    requiredSint32Values: t.expose("requiredSint32Values", {
      type: ["Int"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: {
          name: "required_sint32_values",
          typeFullName: "sint32",
        },
      },
    }),
    requiredSint64Values: t.expose("requiredSint64Values", {
      type: ["Int64"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: {
          name: "required_sint64_values",
          typeFullName: "sint64",
        },
      },
    }),
    requiredFixed32Values: t.expose("requiredFixed32Values", {
      type: ["Int"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: {
          name: "required_fixed32_values",
          typeFullName: "fixed32",
        },
      },
    }),
    requiredFixed64Values: t.expose("requiredFixed64Values", {
      type: ["Int64"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: {
          name: "required_fixed64_values",
          typeFullName: "fixed64",
        },
      },
    }),
    requiredSfixed32Values: t.expose("requiredSfixed32Values", {
      type: ["Int"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: {
          name: "required_sfixed32_values",
          typeFullName: "sfixed32",
        },
      },
    }),
    requiredSfixed64Values: t.expose("requiredSfixed64Values", {
      type: ["Int64"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: {
          name: "required_sfixed64_values",
          typeFullName: "sfixed64",
        },
      },
    }),
    requiredBoolValues: t.expose("requiredBoolValues", {
      type: ["Boolean"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: { name: "required_bool_values", typeFullName: "bool" },
      },
    }),
    requiredStringValues: t.expose("requiredStringValues", {
      type: ["String"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: {
          name: "required_string_values",
          typeFullName: "string",
        },
      },
    }),
    requiredBytesValues: t.field({
      type: ["Byte"],
      nullable: { list: false, items: false },
      resolve: (source) => {
        return source.requiredBytesValues.map((v) => Buffer.from(v));
      },
      extensions: {
        protobufField: { name: "required_bytes_values", typeFullName: "bytes" },
      },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof Primitives;
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.primitives.Primitives",
      name: "Primitives",
      package: "testapis.primitives",
    },
  },
});

export type MessageInput$Shape = {
  requiredPrimitives: PrimitivesInput$Shape;
  optionalPrimitives?: PrimitivesInput$Shape | null;
  requiredPrimitivesList: Array<PrimitivesInput$Shape>;
  optionalPrimitivesList?: Array<PrimitivesInput$Shape> | null;
};

export const MessageInput$Ref: InputObjectRef<MessageInput$Shape> = builder
  .inputRef<MessageInput$Shape>("MessageInput").implement(
    {
      fields: (t) => ({
        requiredPrimitives: t.field({
          type: PrimitivesInput$Ref,
          required: true,
          description: "Required.",
          extensions: {
            protobufField: {
              name: "required_primitives",
              typeFullName: "testapis.primitives.Primitives",
            },
          },
        }),
        optionalPrimitives: t.field({
          type: PrimitivesInput$Ref,
          required: false,
          description: "Optional.",
          extensions: {
            protobufField: {
              name: "optional_primitives",
              typeFullName: "testapis.primitives.Primitives",
            },
          },
        }),
        requiredPrimitivesList: t.field({
          type: [PrimitivesInput$Ref],
          required: { list: true, items: true },
          description: "Required.",
          extensions: {
            protobufField: {
              name: "required_primitives_list",
              typeFullName: "testapis.primitives.Primitives",
            },
          },
        }),
        optionalPrimitivesList: t.field({
          type: [PrimitivesInput$Ref],
          required: { list: false, items: true },
          description: "Optional.",
          extensions: {
            protobufField: {
              name: "optional_primitives_list",
              typeFullName: "testapis.primitives.Primitives",
            },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.primitives.Message",
          name: "Message",
          package: "testapis.primitives",
        },
      },
    },
  );

export function MessageInput$toProto(
  input: MessageInput$Shape | null | undefined,
): Message {
  return new Message({
    requiredPrimitives: input?.requiredPrimitives
      ? PrimitivesInput$toProto(input.requiredPrimitives)
      : undefined,
    optionalPrimitives: input?.optionalPrimitives
      ? PrimitivesInput$toProto(input.optionalPrimitives)
      : undefined,
    requiredPrimitivesList: input?.requiredPrimitivesList?.map((v) =>
      PrimitivesInput$toProto(v)
    ),
    optionalPrimitivesList: input?.optionalPrimitivesList?.map((v) =>
      PrimitivesInput$toProto(v)
    ),
  });
}

export type PrimitivesInput$Shape = {
  requiredDoubleValue: Primitives["requiredDoubleValue"];
  requiredFloatValue: Primitives["requiredFloatValue"];
  requiredInt32Value: Primitives["requiredInt32Value"];
  requiredInt64Value: Primitives["requiredInt64Value"];
  requiredUint32Value: Primitives["requiredUint32Value"];
  requiredUint64Value: Primitives["requiredUint64Value"];
  requiredSint32Value: Primitives["requiredSint32Value"];
  requiredSint64Value: Primitives["requiredSint64Value"];
  requiredFixed32Value: Primitives["requiredFixed32Value"];
  requiredFixed64Value: Primitives["requiredFixed64Value"];
  requiredSfixed32Value: Primitives["requiredSfixed32Value"];
  requiredSfixed64Value: Primitives["requiredSfixed64Value"];
  requiredBoolValue: Primitives["requiredBoolValue"];
  requiredStringValue: Primitives["requiredStringValue"];
  requiredBytesValue: Primitives["requiredBytesValue"];
  requiredDoubleValues: Primitives["requiredDoubleValues"];
  requiredFloatValues: Primitives["requiredFloatValues"];
  requiredInt32Values: Primitives["requiredInt32Values"];
  requiredInt64Values: Primitives["requiredInt64Values"];
  requiredUint32Values: Primitives["requiredUint32Values"];
  requiredUint64Values: Primitives["requiredUint64Values"];
  requiredSint32Values: Primitives["requiredSint32Values"];
  requiredSint64Values: Primitives["requiredSint64Values"];
  requiredFixed32Values: Primitives["requiredFixed32Values"];
  requiredFixed64Values: Primitives["requiredFixed64Values"];
  requiredSfixed32Values: Primitives["requiredSfixed32Values"];
  requiredSfixed64Values: Primitives["requiredSfixed64Values"];
  requiredBoolValues: Primitives["requiredBoolValues"];
  requiredStringValues: Primitives["requiredStringValues"];
  requiredBytesValues: Primitives["requiredBytesValues"];
};

export const PrimitivesInput$Ref: InputObjectRef<PrimitivesInput$Shape> =
  builder.inputRef<PrimitivesInput$Shape>("PrimitivesInput").implement(
    {
      fields: (t) => ({
        requiredDoubleValue: t.field({
          type: "Float",
          required: true,
          extensions: {
            protobufField: {
              name: "required_double_value",
              typeFullName: "double",
            },
          },
        }),
        requiredFloatValue: t.field({
          type: "Float",
          required: true,
          extensions: {
            protobufField: {
              name: "required_float_value",
              typeFullName: "float",
            },
          },
        }),
        requiredInt32Value: t.field({
          type: "Int",
          required: true,
          extensions: {
            protobufField: {
              name: "required_int32_value",
              typeFullName: "int32",
            },
          },
        }),
        requiredInt64Value: t.field({
          type: "Int64",
          required: true,
          extensions: {
            protobufField: {
              name: "required_int64_value",
              typeFullName: "int64",
            },
          },
        }),
        requiredUint32Value: t.field({
          type: "Int",
          required: true,
          extensions: {
            protobufField: {
              name: "required_uint32_value",
              typeFullName: "uint32",
            },
          },
        }),
        requiredUint64Value: t.field({
          type: "Int64",
          required: true,
          extensions: {
            protobufField: {
              name: "required_uint64_value",
              typeFullName: "uint64",
            },
          },
        }),
        requiredSint32Value: t.field({
          type: "Int",
          required: true,
          extensions: {
            protobufField: {
              name: "required_sint32_value",
              typeFullName: "sint32",
            },
          },
        }),
        requiredSint64Value: t.field({
          type: "Int64",
          required: true,
          extensions: {
            protobufField: {
              name: "required_sint64_value",
              typeFullName: "sint64",
            },
          },
        }),
        requiredFixed32Value: t.field({
          type: "Int",
          required: true,
          extensions: {
            protobufField: {
              name: "required_fixed32_value",
              typeFullName: "fixed32",
            },
          },
        }),
        requiredFixed64Value: t.field({
          type: "Int64",
          required: true,
          extensions: {
            protobufField: {
              name: "required_fixed64_value",
              typeFullName: "fixed64",
            },
          },
        }),
        requiredSfixed32Value: t.field({
          type: "Int",
          required: true,
          extensions: {
            protobufField: {
              name: "required_sfixed32_value",
              typeFullName: "sfixed32",
            },
          },
        }),
        requiredSfixed64Value: t.field({
          type: "Int64",
          required: true,
          extensions: {
            protobufField: {
              name: "required_sfixed64_value",
              typeFullName: "sfixed64",
            },
          },
        }),
        requiredBoolValue: t.field({
          type: "Boolean",
          required: true,
          extensions: {
            protobufField: {
              name: "required_bool_value",
              typeFullName: "bool",
            },
          },
        }),
        requiredStringValue: t.field({
          type: "String",
          required: true,
          extensions: {
            protobufField: {
              name: "required_string_value",
              typeFullName: "string",
            },
          },
        }),
        requiredBytesValue: t.field({
          type: "Byte",
          required: true,
          extensions: {
            protobufField: {
              name: "required_bytes_value",
              typeFullName: "bytes",
            },
          },
        }),
        requiredDoubleValues: t.field({
          type: ["Float"],
          required: { list: true, items: true },
          extensions: {
            protobufField: {
              name: "required_double_values",
              typeFullName: "double",
            },
          },
        }),
        requiredFloatValues: t.field({
          type: ["Float"],
          required: { list: true, items: true },
          extensions: {
            protobufField: {
              name: "required_float_values",
              typeFullName: "float",
            },
          },
        }),
        requiredInt32Values: t.field({
          type: ["Int"],
          required: { list: true, items: true },
          extensions: {
            protobufField: {
              name: "required_int32_values",
              typeFullName: "int32",
            },
          },
        }),
        requiredInt64Values: t.field({
          type: ["Int64"],
          required: { list: true, items: true },
          extensions: {
            protobufField: {
              name: "required_int64_values",
              typeFullName: "int64",
            },
          },
        }),
        requiredUint32Values: t.field({
          type: ["Int"],
          required: { list: true, items: true },
          extensions: {
            protobufField: {
              name: "required_uint32_values",
              typeFullName: "uint32",
            },
          },
        }),
        requiredUint64Values: t.field({
          type: ["Int64"],
          required: { list: true, items: true },
          extensions: {
            protobufField: {
              name: "required_uint64_values",
              typeFullName: "uint64",
            },
          },
        }),
        requiredSint32Values: t.field({
          type: ["Int"],
          required: { list: true, items: true },
          extensions: {
            protobufField: {
              name: "required_sint32_values",
              typeFullName: "sint32",
            },
          },
        }),
        requiredSint64Values: t.field({
          type: ["Int64"],
          required: { list: true, items: true },
          extensions: {
            protobufField: {
              name: "required_sint64_values",
              typeFullName: "sint64",
            },
          },
        }),
        requiredFixed32Values: t.field({
          type: ["Int"],
          required: { list: true, items: true },
          extensions: {
            protobufField: {
              name: "required_fixed32_values",
              typeFullName: "fixed32",
            },
          },
        }),
        requiredFixed64Values: t.field({
          type: ["Int64"],
          required: { list: true, items: true },
          extensions: {
            protobufField: {
              name: "required_fixed64_values",
              typeFullName: "fixed64",
            },
          },
        }),
        requiredSfixed32Values: t.field({
          type: ["Int"],
          required: { list: true, items: true },
          extensions: {
            protobufField: {
              name: "required_sfixed32_values",
              typeFullName: "sfixed32",
            },
          },
        }),
        requiredSfixed64Values: t.field({
          type: ["Int64"],
          required: { list: true, items: true },
          extensions: {
            protobufField: {
              name: "required_sfixed64_values",
              typeFullName: "sfixed64",
            },
          },
        }),
        requiredBoolValues: t.field({
          type: ["Boolean"],
          required: { list: true, items: true },
          extensions: {
            protobufField: {
              name: "required_bool_values",
              typeFullName: "bool",
            },
          },
        }),
        requiredStringValues: t.field({
          type: ["String"],
          required: { list: true, items: true },
          extensions: {
            protobufField: {
              name: "required_string_values",
              typeFullName: "string",
            },
          },
        }),
        requiredBytesValues: t.field({
          type: ["Byte"],
          required: { list: true, items: true },
          extensions: {
            protobufField: {
              name: "required_bytes_values",
              typeFullName: "bytes",
            },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.primitives.Primitives",
          name: "Primitives",
          package: "testapis.primitives",
        },
      },
    },
  );

export function PrimitivesInput$toProto(
  input: PrimitivesInput$Shape | null | undefined,
): Primitives {
  return new Primitives({
    requiredDoubleValue: input?.requiredDoubleValue ?? undefined,
    requiredFloatValue: input?.requiredFloatValue ?? undefined,
    requiredInt32Value: input?.requiredInt32Value ?? undefined,
    requiredInt64Value: input?.requiredInt64Value ?? undefined,
    requiredUint32Value: input?.requiredUint32Value ?? undefined,
    requiredUint64Value: input?.requiredUint64Value ?? undefined,
    requiredSint32Value: input?.requiredSint32Value ?? undefined,
    requiredSint64Value: input?.requiredSint64Value ?? undefined,
    requiredFixed32Value: input?.requiredFixed32Value ?? undefined,
    requiredFixed64Value: input?.requiredFixed64Value ?? undefined,
    requiredSfixed32Value: input?.requiredSfixed32Value ?? undefined,
    requiredSfixed64Value: input?.requiredSfixed64Value ?? undefined,
    requiredBoolValue: input?.requiredBoolValue ?? undefined,
    requiredStringValue: input?.requiredStringValue ?? undefined,
    requiredBytesValue: input?.requiredBytesValue ?? undefined,
    requiredDoubleValues: input?.requiredDoubleValues ?? undefined,
    requiredFloatValues: input?.requiredFloatValues ?? undefined,
    requiredInt32Values: input?.requiredInt32Values ?? undefined,
    requiredInt64Values: input?.requiredInt64Values ?? undefined,
    requiredUint32Values: input?.requiredUint32Values ?? undefined,
    requiredUint64Values: input?.requiredUint64Values ?? undefined,
    requiredSint32Values: input?.requiredSint32Values ?? undefined,
    requiredSint64Values: input?.requiredSint64Values ?? undefined,
    requiredFixed32Values: input?.requiredFixed32Values ?? undefined,
    requiredFixed64Values: input?.requiredFixed64Values ?? undefined,
    requiredSfixed32Values: input?.requiredSfixed32Values ?? undefined,
    requiredSfixed64Values: input?.requiredSfixed64Values ?? undefined,
    requiredBoolValues: input?.requiredBoolValues ?? undefined,
    requiredStringValues: input?.requiredStringValues ?? undefined,
    requiredBytesValues: input?.requiredBytesValues ?? undefined,
  });
}
",
    "name": "testapis/primitives/primitives.pb.pothos.ts",
  },
]
`;

exports[`protobuf-es > 'testapis.proto3_optional' > generates files by plugin 'with import prefix' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/proto3_optional/proto3_optional.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { Message } from "@testapis/protobuf-es/testapis/proto3_optional/proto3_optional_pb";
import { builder } from "../../builder";

export const Message$Ref = builder.objectRef<Message>("Message");
builder.objectType(Message$Ref, {
  name: "Message",
  fields: (t) => ({
    requiredStringValue: t.expose("requiredStringValue", {
      type: "String",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_string_value",
          typeFullName: "string",
        },
      },
    }),
    optionalStringValue: t.expose("optionalStringValue", {
      type: "String",
      nullable: true,
      extensions: {
        protobufField: {
          name: "optional_string_value",
          typeFullName: "string",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof Message;
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.proto3_optional.Message",
      name: "Message",
      package: "testapis.proto3_optional",
    },
  },
});

export type MessageInput$Shape = {
  requiredStringValue: Message["requiredStringValue"];
  optionalStringValue?: Message["optionalStringValue"] | null;
};

export const MessageInput$Ref: InputObjectRef<MessageInput$Shape> = builder
  .inputRef<MessageInput$Shape>("MessageInput").implement(
    {
      fields: (t) => ({
        requiredStringValue: t.field({
          type: "String",
          required: true,
          extensions: {
            protobufField: {
              name: "required_string_value",
              typeFullName: "string",
            },
          },
        }),
        optionalStringValue: t.field({
          type: "String",
          required: false,
          extensions: {
            protobufField: {
              name: "optional_string_value",
              typeFullName: "string",
            },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.proto3_optional.Message",
          name: "Message",
          package: "testapis.proto3_optional",
        },
      },
    },
  );

export function MessageInput$toProto(
  input: MessageInput$Shape | null | undefined,
): Message {
  return new Message({
    requiredStringValue: input?.requiredStringValue ?? undefined,
    optionalStringValue: input?.optionalStringValue ?? undefined,
  });
}
",
    "name": "testapis/proto3_optional/proto3_optional.pb.pothos.ts",
  },
]
`;

exports[`protobuf-es > 'testapis.proto3_optional' > generates files by plugin 'with partial inputs' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/proto3_optional/proto3_optional.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { Message } from "@testapis/protobuf-es/testapis/proto3_optional/proto3_optional_pb";
import { builder } from "../../builder";

export const Message$Ref = builder.objectRef<Message>("Message");
builder.objectType(Message$Ref, {
  name: "Message",
  fields: (t) => ({
    requiredStringValue: t.expose("requiredStringValue", {
      type: "String",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_string_value",
          typeFullName: "string",
        },
      },
    }),
    optionalStringValue: t.expose("optionalStringValue", {
      type: "String",
      nullable: true,
      extensions: {
        protobufField: {
          name: "optional_string_value",
          typeFullName: "string",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof Message;
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.proto3_optional.Message",
      name: "Message",
      package: "testapis.proto3_optional",
    },
  },
});

export type MessageInput$Shape = {
  requiredStringValue: Message["requiredStringValue"];
  optionalStringValue?: Message["optionalStringValue"] | null;
};

export const MessageInput$Ref: InputObjectRef<MessageInput$Shape> = builder
  .inputRef<MessageInput$Shape>("MessageInput").implement(
    {
      fields: (t) => ({
        requiredStringValue: t.field({
          type: "String",
          required: true,
          extensions: {
            protobufField: {
              name: "required_string_value",
              typeFullName: "string",
            },
          },
        }),
        optionalStringValue: t.field({
          type: "String",
          required: false,
          extensions: {
            protobufField: {
              name: "optional_string_value",
              typeFullName: "string",
            },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.proto3_optional.Message",
          name: "Message",
          package: "testapis.proto3_optional",
        },
      },
    },
  );

export function MessageInput$toProto(
  input: MessageInput$Shape | null | undefined,
): Message {
  return new Message({
    requiredStringValue: input?.requiredStringValue ?? undefined,
    optionalStringValue: input?.optionalStringValue ?? undefined,
  });
}

export type MessagePartialInput$Shape = {
  requiredStringValue?: Message["requiredStringValue"] | null;
  optionalStringValue?: Message["optionalStringValue"] | null;
};

export const MessagePartialInput$Ref: InputObjectRef<
  MessagePartialInput$Shape
> = builder.inputRef<MessagePartialInput$Shape>("MessagePartialInput")
  .implement(
    {
      fields: (t) => ({
        requiredStringValue: t.field({
          type: "String",
          required: false,
          extensions: {
            protobufField: {
              name: "required_string_value",
              typeFullName: "string",
            },
          },
        }),
        optionalStringValue: t.field({
          type: "String",
          required: false,
          extensions: {
            protobufField: {
              name: "optional_string_value",
              typeFullName: "string",
            },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.proto3_optional.Message",
          name: "Message",
          package: "testapis.proto3_optional",
        },
      },
    },
  );

export function MessagePartialInput$toProto(
  input: MessagePartialInput$Shape | null | undefined,
): Message {
  return new Message({
    requiredStringValue: input?.requiredStringValue ?? undefined,
    optionalStringValue: input?.optionalStringValue ?? undefined,
  });
}
",
    "name": "testapis/proto3_optional/proto3_optional.pb.pothos.ts",
  },
]
`;

exports[`protobuf-es > 'testapis.proto3_optional' > generates files by plugin 'without import prefix' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/proto3_optional/proto3_optional.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { builder } from "../../builder";
import { Message } from "./testapis/proto3_optional/proto3_optional_pb";

export const Message$Ref = builder.objectRef<Message>("Message");
builder.objectType(Message$Ref, {
  name: "Message",
  fields: (t) => ({
    requiredStringValue: t.expose("requiredStringValue", {
      type: "String",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_string_value",
          typeFullName: "string",
        },
      },
    }),
    optionalStringValue: t.expose("optionalStringValue", {
      type: "String",
      nullable: true,
      extensions: {
        protobufField: {
          name: "optional_string_value",
          typeFullName: "string",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof Message;
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.proto3_optional.Message",
      name: "Message",
      package: "testapis.proto3_optional",
    },
  },
});

export type MessageInput$Shape = {
  requiredStringValue: Message["requiredStringValue"];
  optionalStringValue?: Message["optionalStringValue"] | null;
};

export const MessageInput$Ref: InputObjectRef<MessageInput$Shape> = builder
  .inputRef<MessageInput$Shape>("MessageInput").implement(
    {
      fields: (t) => ({
        requiredStringValue: t.field({
          type: "String",
          required: true,
          extensions: {
            protobufField: {
              name: "required_string_value",
              typeFullName: "string",
            },
          },
        }),
        optionalStringValue: t.field({
          type: "String",
          required: false,
          extensions: {
            protobufField: {
              name: "optional_string_value",
              typeFullName: "string",
            },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.proto3_optional.Message",
          name: "Message",
          package: "testapis.proto3_optional",
        },
      },
    },
  );

export function MessageInput$toProto(
  input: MessageInput$Shape | null | undefined,
): Message {
  return new Message({
    requiredStringValue: input?.requiredStringValue ?? undefined,
    optionalStringValue: input?.optionalStringValue ?? undefined,
  });
}
",
    "name": "testapis/proto3_optional/proto3_optional.pb.pothos.ts",
  },
]
`;

exports[`protobuf-es > 'testapis.wktypes' > generates files by plugin 'with import prefix' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/wktypes/well_known_types.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { Message } from "@testapis/protobuf-es/testapis/wktypes/well_known_types_pb";
import { builder } from "../../builder";

export const Message$Ref = builder.objectRef<Message>("Message");
builder.objectType(Message$Ref, {
  name: "Message",
  fields: (t) => ({
    timestamp: t.expose("timestamp", {
      type: "DateTime",
      nullable: true,
      extensions: {
        protobufField: {
          name: "timestamp",
          typeFullName: "google.protobuf.Timestamp",
        },
      },
    }),
    int32Value: t.expose("int32Value", {
      type: "Int",
      nullable: true,
      extensions: {
        protobufField: {
          name: "int32_value",
          typeFullName: "google.protobuf.Int32Value",
        },
      },
    }),
    int64Value: t.expose("int64Value", {
      type: "Int64",
      nullable: true,
      extensions: {
        protobufField: {
          name: "int64_value",
          typeFullName: "google.protobuf.Int64Value",
        },
      },
    }),
    uint32Value: t.expose("uint32Value", {
      type: "Int",
      nullable: true,
      extensions: {
        protobufField: {
          name: "uint32_value",
          typeFullName: "google.protobuf.UInt32Value",
        },
      },
    }),
    uint64Value: t.expose("uint64Value", {
      type: "Int64",
      nullable: true,
      extensions: {
        protobufField: {
          name: "uint64_value",
          typeFullName: "google.protobuf.UInt64Value",
        },
      },
    }),
    floatValue: t.expose("floatValue", {
      type: "Float",
      nullable: true,
      extensions: {
        protobufField: {
          name: "float_value",
          typeFullName: "google.protobuf.FloatValue",
        },
      },
    }),
    doubleValue: t.expose("doubleValue", {
      type: "Float",
      nullable: true,
      extensions: {
        protobufField: {
          name: "double_value",
          typeFullName: "google.protobuf.DoubleValue",
        },
      },
    }),
    boolValue: t.expose("boolValue", {
      type: "Boolean",
      nullable: true,
      extensions: {
        protobufField: {
          name: "bool_value",
          typeFullName: "google.protobuf.BoolValue",
        },
      },
    }),
    stringValue: t.expose("stringValue", {
      type: "String",
      nullable: true,
      extensions: {
        protobufField: {
          name: "string_value",
          typeFullName: "google.protobuf.StringValue",
        },
      },
    }),
    bytesValue: t.field({
      type: "Byte",
      nullable: true,
      resolve: (source) => {
        return source.bytesValue == null
          ? null
          : Buffer.from(source.bytesValue);
      },
      extensions: {
        protobufField: {
          name: "bytes_value",
          typeFullName: "google.protobuf.BytesValue",
        },
      },
    }),
    requiredTimestamp: t.field({
      type: "DateTime",
      nullable: false,
      description: "Required.",
      resolve: (source) => {
        return source.requiredTimestamp!;
      },
      extensions: {
        protobufField: {
          name: "required_timestamp",
          typeFullName: "google.protobuf.Timestamp",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof Message;
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.wktypes.Message",
      name: "Message",
      package: "testapis.wktypes",
    },
  },
});

export type MessageInput$Shape = {
  timestamp?: Message["timestamp"] | null;
  int32Value?: Message["int32Value"] | null;
  int64Value?: Message["int64Value"] | null;
  uint32Value?: Message["uint32Value"] | null;
  uint64Value?: Message["uint64Value"] | null;
  floatValue?: Message["floatValue"] | null;
  doubleValue?: Message["doubleValue"] | null;
  boolValue?: Message["boolValue"] | null;
  stringValue?: Message["stringValue"] | null;
  bytesValue?: Message["bytesValue"] | null;
  requiredTimestamp: NonNullable<Message["requiredTimestamp"]>;
};

export const MessageInput$Ref: InputObjectRef<MessageInput$Shape> = builder
  .inputRef<MessageInput$Shape>("MessageInput").implement(
    {
      fields: (t) => ({
        timestamp: t.field({
          type: "DateTime",
          required: false,
          extensions: {
            protobufField: {
              name: "timestamp",
              typeFullName: "google.protobuf.Timestamp",
            },
          },
        }),
        int32Value: t.field({
          type: "Int",
          required: false,
          extensions: {
            protobufField: {
              name: "int32_value",
              typeFullName: "google.protobuf.Int32Value",
            },
          },
        }),
        int64Value: t.field({
          type: "Int64",
          required: false,
          extensions: {
            protobufField: {
              name: "int64_value",
              typeFullName: "google.protobuf.Int64Value",
            },
          },
        }),
        uint32Value: t.field({
          type: "Int",
          required: false,
          extensions: {
            protobufField: {
              name: "uint32_value",
              typeFullName: "google.protobuf.UInt32Value",
            },
          },
        }),
        uint64Value: t.field({
          type: "Int64",
          required: false,
          extensions: {
            protobufField: {
              name: "uint64_value",
              typeFullName: "google.protobuf.UInt64Value",
            },
          },
        }),
        floatValue: t.field({
          type: "Float",
          required: false,
          extensions: {
            protobufField: {
              name: "float_value",
              typeFullName: "google.protobuf.FloatValue",
            },
          },
        }),
        doubleValue: t.field({
          type: "Float",
          required: false,
          extensions: {
            protobufField: {
              name: "double_value",
              typeFullName: "google.protobuf.DoubleValue",
            },
          },
        }),
        boolValue: t.field({
          type: "Boolean",
          required: false,
          extensions: {
            protobufField: {
              name: "bool_value",
              typeFullName: "google.protobuf.BoolValue",
            },
          },
        }),
        stringValue: t.field({
          type: "String",
          required: false,
          extensions: {
            protobufField: {
              name: "string_value",
              typeFullName: "google.protobuf.StringValue",
            },
          },
        }),
        bytesValue: t.field({
          type: "Byte",
          required: false,
          extensions: {
            protobufField: {
              name: "bytes_value",
              typeFullName: "google.protobuf.BytesValue",
            },
          },
        }),
        requiredTimestamp: t.field({
          type: "DateTime",
          required: true,
          description: "Required.",
          extensions: {
            protobufField: {
              name: "required_timestamp",
              typeFullName: "google.protobuf.Timestamp",
            },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.wktypes.Message",
          name: "Message",
          package: "testapis.wktypes",
        },
      },
    },
  );

export function MessageInput$toProto(
  input: MessageInput$Shape | null | undefined,
): Message {
  return new Message({
    timestamp: input?.timestamp ?? undefined,
    int32Value: input?.int32Value ?? undefined,
    int64Value: input?.int64Value ?? undefined,
    uint32Value: input?.uint32Value ?? undefined,
    uint64Value: input?.uint64Value ?? undefined,
    floatValue: input?.floatValue ?? undefined,
    doubleValue: input?.doubleValue ?? undefined,
    boolValue: input?.boolValue ?? undefined,
    stringValue: input?.stringValue ?? undefined,
    bytesValue: input?.bytesValue ?? undefined,
    requiredTimestamp: input?.requiredTimestamp ?? undefined,
  });
}
",
    "name": "testapis/wktypes/well_known_types.pb.pothos.ts",
  },
]
`;

exports[`protobuf-es > 'testapis.wktypes' > generates files by plugin 'with partial inputs' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/wktypes/well_known_types.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { Message } from "@testapis/protobuf-es/testapis/wktypes/well_known_types_pb";
import { builder } from "../../builder";

export const Message$Ref = builder.objectRef<Message>("Message");
builder.objectType(Message$Ref, {
  name: "Message",
  fields: (t) => ({
    timestamp: t.expose("timestamp", {
      type: "DateTime",
      nullable: true,
      extensions: {
        protobufField: {
          name: "timestamp",
          typeFullName: "google.protobuf.Timestamp",
        },
      },
    }),
    int32Value: t.expose("int32Value", {
      type: "Int",
      nullable: true,
      extensions: {
        protobufField: {
          name: "int32_value",
          typeFullName: "google.protobuf.Int32Value",
        },
      },
    }),
    int64Value: t.expose("int64Value", {
      type: "Int64",
      nullable: true,
      extensions: {
        protobufField: {
          name: "int64_value",
          typeFullName: "google.protobuf.Int64Value",
        },
      },
    }),
    uint32Value: t.expose("uint32Value", {
      type: "Int",
      nullable: true,
      extensions: {
        protobufField: {
          name: "uint32_value",
          typeFullName: "google.protobuf.UInt32Value",
        },
      },
    }),
    uint64Value: t.expose("uint64Value", {
      type: "Int64",
      nullable: true,
      extensions: {
        protobufField: {
          name: "uint64_value",
          typeFullName: "google.protobuf.UInt64Value",
        },
      },
    }),
    floatValue: t.expose("floatValue", {
      type: "Float",
      nullable: true,
      extensions: {
        protobufField: {
          name: "float_value",
          typeFullName: "google.protobuf.FloatValue",
        },
      },
    }),
    doubleValue: t.expose("doubleValue", {
      type: "Float",
      nullable: true,
      extensions: {
        protobufField: {
          name: "double_value",
          typeFullName: "google.protobuf.DoubleValue",
        },
      },
    }),
    boolValue: t.expose("boolValue", {
      type: "Boolean",
      nullable: true,
      extensions: {
        protobufField: {
          name: "bool_value",
          typeFullName: "google.protobuf.BoolValue",
        },
      },
    }),
    stringValue: t.expose("stringValue", {
      type: "String",
      nullable: true,
      extensions: {
        protobufField: {
          name: "string_value",
          typeFullName: "google.protobuf.StringValue",
        },
      },
    }),
    bytesValue: t.field({
      type: "Byte",
      nullable: true,
      resolve: (source) => {
        return source.bytesValue == null
          ? null
          : Buffer.from(source.bytesValue);
      },
      extensions: {
        protobufField: {
          name: "bytes_value",
          typeFullName: "google.protobuf.BytesValue",
        },
      },
    }),
    requiredTimestamp: t.field({
      type: "DateTime",
      nullable: false,
      description: "Required.",
      resolve: (source) => {
        return source.requiredTimestamp!;
      },
      extensions: {
        protobufField: {
          name: "required_timestamp",
          typeFullName: "google.protobuf.Timestamp",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof Message;
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.wktypes.Message",
      name: "Message",
      package: "testapis.wktypes",
    },
  },
});

export type MessageInput$Shape = {
  timestamp?: Message["timestamp"] | null;
  int32Value?: Message["int32Value"] | null;
  int64Value?: Message["int64Value"] | null;
  uint32Value?: Message["uint32Value"] | null;
  uint64Value?: Message["uint64Value"] | null;
  floatValue?: Message["floatValue"] | null;
  doubleValue?: Message["doubleValue"] | null;
  boolValue?: Message["boolValue"] | null;
  stringValue?: Message["stringValue"] | null;
  bytesValue?: Message["bytesValue"] | null;
  requiredTimestamp: NonNullable<Message["requiredTimestamp"]>;
};

export const MessageInput$Ref: InputObjectRef<MessageInput$Shape> = builder
  .inputRef<MessageInput$Shape>("MessageInput").implement(
    {
      fields: (t) => ({
        timestamp: t.field({
          type: "DateTime",
          required: false,
          extensions: {
            protobufField: {
              name: "timestamp",
              typeFullName: "google.protobuf.Timestamp",
            },
          },
        }),
        int32Value: t.field({
          type: "Int",
          required: false,
          extensions: {
            protobufField: {
              name: "int32_value",
              typeFullName: "google.protobuf.Int32Value",
            },
          },
        }),
        int64Value: t.field({
          type: "Int64",
          required: false,
          extensions: {
            protobufField: {
              name: "int64_value",
              typeFullName: "google.protobuf.Int64Value",
            },
          },
        }),
        uint32Value: t.field({
          type: "Int",
          required: false,
          extensions: {
            protobufField: {
              name: "uint32_value",
              typeFullName: "google.protobuf.UInt32Value",
            },
          },
        }),
        uint64Value: t.field({
          type: "Int64",
          required: false,
          extensions: {
            protobufField: {
              name: "uint64_value",
              typeFullName: "google.protobuf.UInt64Value",
            },
          },
        }),
        floatValue: t.field({
          type: "Float",
          required: false,
          extensions: {
            protobufField: {
              name: "float_value",
              typeFullName: "google.protobuf.FloatValue",
            },
          },
        }),
        doubleValue: t.field({
          type: "Float",
          required: false,
          extensions: {
            protobufField: {
              name: "double_value",
              typeFullName: "google.protobuf.DoubleValue",
            },
          },
        }),
        boolValue: t.field({
          type: "Boolean",
          required: false,
          extensions: {
            protobufField: {
              name: "bool_value",
              typeFullName: "google.protobuf.BoolValue",
            },
          },
        }),
        stringValue: t.field({
          type: "String",
          required: false,
          extensions: {
            protobufField: {
              name: "string_value",
              typeFullName: "google.protobuf.StringValue",
            },
          },
        }),
        bytesValue: t.field({
          type: "Byte",
          required: false,
          extensions: {
            protobufField: {
              name: "bytes_value",
              typeFullName: "google.protobuf.BytesValue",
            },
          },
        }),
        requiredTimestamp: t.field({
          type: "DateTime",
          required: true,
          description: "Required.",
          extensions: {
            protobufField: {
              name: "required_timestamp",
              typeFullName: "google.protobuf.Timestamp",
            },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.wktypes.Message",
          name: "Message",
          package: "testapis.wktypes",
        },
      },
    },
  );

export function MessageInput$toProto(
  input: MessageInput$Shape | null | undefined,
): Message {
  return new Message({
    timestamp: input?.timestamp ?? undefined,
    int32Value: input?.int32Value ?? undefined,
    int64Value: input?.int64Value ?? undefined,
    uint32Value: input?.uint32Value ?? undefined,
    uint64Value: input?.uint64Value ?? undefined,
    floatValue: input?.floatValue ?? undefined,
    doubleValue: input?.doubleValue ?? undefined,
    boolValue: input?.boolValue ?? undefined,
    stringValue: input?.stringValue ?? undefined,
    bytesValue: input?.bytesValue ?? undefined,
    requiredTimestamp: input?.requiredTimestamp ?? undefined,
  });
}

export type MessagePartialInput$Shape = {
  timestamp?: Message["timestamp"] | null;
  int32Value?: Message["int32Value"] | null;
  int64Value?: Message["int64Value"] | null;
  uint32Value?: Message["uint32Value"] | null;
  uint64Value?: Message["uint64Value"] | null;
  floatValue?: Message["floatValue"] | null;
  doubleValue?: Message["doubleValue"] | null;
  boolValue?: Message["boolValue"] | null;
  stringValue?: Message["stringValue"] | null;
  bytesValue?: Message["bytesValue"] | null;
  requiredTimestamp?: Message["requiredTimestamp"] | null;
};

export const MessagePartialInput$Ref: InputObjectRef<
  MessagePartialInput$Shape
> = builder.inputRef<MessagePartialInput$Shape>("MessagePartialInput")
  .implement(
    {
      fields: (t) => ({
        timestamp: t.field({
          type: "DateTime",
          required: false,
          extensions: {
            protobufField: {
              name: "timestamp",
              typeFullName: "google.protobuf.Timestamp",
            },
          },
        }),
        int32Value: t.field({
          type: "Int",
          required: false,
          extensions: {
            protobufField: {
              name: "int32_value",
              typeFullName: "google.protobuf.Int32Value",
            },
          },
        }),
        int64Value: t.field({
          type: "Int64",
          required: false,
          extensions: {
            protobufField: {
              name: "int64_value",
              typeFullName: "google.protobuf.Int64Value",
            },
          },
        }),
        uint32Value: t.field({
          type: "Int",
          required: false,
          extensions: {
            protobufField: {
              name: "uint32_value",
              typeFullName: "google.protobuf.UInt32Value",
            },
          },
        }),
        uint64Value: t.field({
          type: "Int64",
          required: false,
          extensions: {
            protobufField: {
              name: "uint64_value",
              typeFullName: "google.protobuf.UInt64Value",
            },
          },
        }),
        floatValue: t.field({
          type: "Float",
          required: false,
          extensions: {
            protobufField: {
              name: "float_value",
              typeFullName: "google.protobuf.FloatValue",
            },
          },
        }),
        doubleValue: t.field({
          type: "Float",
          required: false,
          extensions: {
            protobufField: {
              name: "double_value",
              typeFullName: "google.protobuf.DoubleValue",
            },
          },
        }),
        boolValue: t.field({
          type: "Boolean",
          required: false,
          extensions: {
            protobufField: {
              name: "bool_value",
              typeFullName: "google.protobuf.BoolValue",
            },
          },
        }),
        stringValue: t.field({
          type: "String",
          required: false,
          extensions: {
            protobufField: {
              name: "string_value",
              typeFullName: "google.protobuf.StringValue",
            },
          },
        }),
        bytesValue: t.field({
          type: "Byte",
          required: false,
          extensions: {
            protobufField: {
              name: "bytes_value",
              typeFullName: "google.protobuf.BytesValue",
            },
          },
        }),
        requiredTimestamp: t.field({
          type: "DateTime",
          required: false,
          description: "Required.",
          extensions: {
            protobufField: {
              name: "required_timestamp",
              typeFullName: "google.protobuf.Timestamp",
            },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.wktypes.Message",
          name: "Message",
          package: "testapis.wktypes",
        },
      },
    },
  );

export function MessagePartialInput$toProto(
  input: MessagePartialInput$Shape | null | undefined,
): Message {
  return new Message({
    timestamp: input?.timestamp ?? undefined,
    int32Value: input?.int32Value ?? undefined,
    int64Value: input?.int64Value ?? undefined,
    uint32Value: input?.uint32Value ?? undefined,
    uint64Value: input?.uint64Value ?? undefined,
    floatValue: input?.floatValue ?? undefined,
    doubleValue: input?.doubleValue ?? undefined,
    boolValue: input?.boolValue ?? undefined,
    stringValue: input?.stringValue ?? undefined,
    bytesValue: input?.bytesValue ?? undefined,
    requiredTimestamp: input?.requiredTimestamp ?? undefined,
  });
}
",
    "name": "testapis/wktypes/well_known_types.pb.pothos.ts",
  },
]
`;

exports[`protobuf-es > 'testapis.wktypes' > generates files by plugin 'without import prefix' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/wktypes/well_known_types.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { builder } from "../../builder";
import { Message } from "./testapis/wktypes/well_known_types_pb";

export const Message$Ref = builder.objectRef<Message>("Message");
builder.objectType(Message$Ref, {
  name: "Message",
  fields: (t) => ({
    timestamp: t.expose("timestamp", {
      type: "DateTime",
      nullable: true,
      extensions: {
        protobufField: {
          name: "timestamp",
          typeFullName: "google.protobuf.Timestamp",
        },
      },
    }),
    int32Value: t.expose("int32Value", {
      type: "Int",
      nullable: true,
      extensions: {
        protobufField: {
          name: "int32_value",
          typeFullName: "google.protobuf.Int32Value",
        },
      },
    }),
    int64Value: t.expose("int64Value", {
      type: "Int64",
      nullable: true,
      extensions: {
        protobufField: {
          name: "int64_value",
          typeFullName: "google.protobuf.Int64Value",
        },
      },
    }),
    uint32Value: t.expose("uint32Value", {
      type: "Int",
      nullable: true,
      extensions: {
        protobufField: {
          name: "uint32_value",
          typeFullName: "google.protobuf.UInt32Value",
        },
      },
    }),
    uint64Value: t.expose("uint64Value", {
      type: "Int64",
      nullable: true,
      extensions: {
        protobufField: {
          name: "uint64_value",
          typeFullName: "google.protobuf.UInt64Value",
        },
      },
    }),
    floatValue: t.expose("floatValue", {
      type: "Float",
      nullable: true,
      extensions: {
        protobufField: {
          name: "float_value",
          typeFullName: "google.protobuf.FloatValue",
        },
      },
    }),
    doubleValue: t.expose("doubleValue", {
      type: "Float",
      nullable: true,
      extensions: {
        protobufField: {
          name: "double_value",
          typeFullName: "google.protobuf.DoubleValue",
        },
      },
    }),
    boolValue: t.expose("boolValue", {
      type: "Boolean",
      nullable: true,
      extensions: {
        protobufField: {
          name: "bool_value",
          typeFullName: "google.protobuf.BoolValue",
        },
      },
    }),
    stringValue: t.expose("stringValue", {
      type: "String",
      nullable: true,
      extensions: {
        protobufField: {
          name: "string_value",
          typeFullName: "google.protobuf.StringValue",
        },
      },
    }),
    bytesValue: t.field({
      type: "Byte",
      nullable: true,
      resolve: (source) => {
        return source.bytesValue == null
          ? null
          : Buffer.from(source.bytesValue);
      },
      extensions: {
        protobufField: {
          name: "bytes_value",
          typeFullName: "google.protobuf.BytesValue",
        },
      },
    }),
    requiredTimestamp: t.field({
      type: "DateTime",
      nullable: false,
      description: "Required.",
      resolve: (source) => {
        return source.requiredTimestamp!;
      },
      extensions: {
        protobufField: {
          name: "required_timestamp",
          typeFullName: "google.protobuf.Timestamp",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return source instanceof Message;
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.wktypes.Message",
      name: "Message",
      package: "testapis.wktypes",
    },
  },
});

export type MessageInput$Shape = {
  timestamp?: Message["timestamp"] | null;
  int32Value?: Message["int32Value"] | null;
  int64Value?: Message["int64Value"] | null;
  uint32Value?: Message["uint32Value"] | null;
  uint64Value?: Message["uint64Value"] | null;
  floatValue?: Message["floatValue"] | null;
  doubleValue?: Message["doubleValue"] | null;
  boolValue?: Message["boolValue"] | null;
  stringValue?: Message["stringValue"] | null;
  bytesValue?: Message["bytesValue"] | null;
  requiredTimestamp: NonNullable<Message["requiredTimestamp"]>;
};

export const MessageInput$Ref: InputObjectRef<MessageInput$Shape> = builder
  .inputRef<MessageInput$Shape>("MessageInput").implement(
    {
      fields: (t) => ({
        timestamp: t.field({
          type: "DateTime",
          required: false,
          extensions: {
            protobufField: {
              name: "timestamp",
              typeFullName: "google.protobuf.Timestamp",
            },
          },
        }),
        int32Value: t.field({
          type: "Int",
          required: false,
          extensions: {
            protobufField: {
              name: "int32_value",
              typeFullName: "google.protobuf.Int32Value",
            },
          },
        }),
        int64Value: t.field({
          type: "Int64",
          required: false,
          extensions: {
            protobufField: {
              name: "int64_value",
              typeFullName: "google.protobuf.Int64Value",
            },
          },
        }),
        uint32Value: t.field({
          type: "Int",
          required: false,
          extensions: {
            protobufField: {
              name: "uint32_value",
              typeFullName: "google.protobuf.UInt32Value",
            },
          },
        }),
        uint64Value: t.field({
          type: "Int64",
          required: false,
          extensions: {
            protobufField: {
              name: "uint64_value",
              typeFullName: "google.protobuf.UInt64Value",
            },
          },
        }),
        floatValue: t.field({
          type: "Float",
          required: false,
          extensions: {
            protobufField: {
              name: "float_value",
              typeFullName: "google.protobuf.FloatValue",
            },
          },
        }),
        doubleValue: t.field({
          type: "Float",
          required: false,
          extensions: {
            protobufField: {
              name: "double_value",
              typeFullName: "google.protobuf.DoubleValue",
            },
          },
        }),
        boolValue: t.field({
          type: "Boolean",
          required: false,
          extensions: {
            protobufField: {
              name: "bool_value",
              typeFullName: "google.protobuf.BoolValue",
            },
          },
        }),
        stringValue: t.field({
          type: "String",
          required: false,
          extensions: {
            protobufField: {
              name: "string_value",
              typeFullName: "google.protobuf.StringValue",
            },
          },
        }),
        bytesValue: t.field({
          type: "Byte",
          required: false,
          extensions: {
            protobufField: {
              name: "bytes_value",
              typeFullName: "google.protobuf.BytesValue",
            },
          },
        }),
        requiredTimestamp: t.field({
          type: "DateTime",
          required: true,
          description: "Required.",
          extensions: {
            protobufField: {
              name: "required_timestamp",
              typeFullName: "google.protobuf.Timestamp",
            },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.wktypes.Message",
          name: "Message",
          package: "testapis.wktypes",
        },
      },
    },
  );

export function MessageInput$toProto(
  input: MessageInput$Shape | null | undefined,
): Message {
  return new Message({
    timestamp: input?.timestamp ?? undefined,
    int32Value: input?.int32Value ?? undefined,
    int64Value: input?.int64Value ?? undefined,
    uint32Value: input?.uint32Value ?? undefined,
    uint64Value: input?.uint64Value ?? undefined,
    floatValue: input?.floatValue ?? undefined,
    doubleValue: input?.doubleValue ?? undefined,
    boolValue: input?.boolValue ?? undefined,
    stringValue: input?.stringValue ?? undefined,
    bytesValue: input?.bytesValue ?? undefined,
    requiredTimestamp: input?.requiredTimestamp ?? undefined,
  });
}
",
    "name": "testapis/wktypes/well_known_types.pb.pothos.ts",
  },
]
`;

exports[`with scalar type override > maps 64bit integers to bigint > generates files from 'testapis.primitives' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/primitives/primitives.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { builder } from "../../builder";
import { Message, Primitives } from "./testapis/primitives/primitives";

export const Message$Ref = builder.objectRef<Message>("Message");
builder.objectType(Message$Ref, {
  name: "Message",
  fields: (t) => ({
    requiredPrimitives: t.field({
      type: Primitives$Ref,
      nullable: false,
      description: "Required.",
      resolve: (source) => {
        return source.requiredPrimitives!;
      },
      extensions: {
        protobufField: {
          name: "required_primitives",
          typeFullName: "testapis.primitives.Primitives",
        },
      },
    }),
    optionalPrimitives: t.expose("optionalPrimitives", {
      type: Primitives$Ref,
      nullable: true,
      description: "Optional.",
      extensions: {
        protobufField: {
          name: "optional_primitives",
          typeFullName: "testapis.primitives.Primitives",
        },
      },
    }),
    requiredPrimitivesList: t.field({
      type: [Primitives$Ref],
      nullable: { list: false, items: false },
      description: "Required.",
      resolve: (source) => {
        return source.requiredPrimitivesList!;
      },
      extensions: {
        protobufField: {
          name: "required_primitives_list",
          typeFullName: "testapis.primitives.Primitives",
        },
      },
    }),
    optionalPrimitivesList: t.expose("optionalPrimitivesList", {
      type: [Primitives$Ref],
      nullable: { list: true, items: false },
      description: "Optional.",
      extensions: {
        protobufField: {
          name: "optional_primitives_list",
          typeFullName: "testapis.primitives.Primitives",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as Message | { $type: string & {}; }).$type ===
      "testapis.primitives.Message";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.primitives.Message",
      name: "Message",
      package: "testapis.primitives",
    },
  },
});

export const Primitives$Ref = builder.objectRef<Primitives>("Primitives");
builder.objectType(Primitives$Ref, {
  name: "Primitives",
  fields: (t) => ({
    requiredDoubleValue: t.expose("requiredDoubleValue", {
      type: "Float",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_double_value",
          typeFullName: "double",
        },
      },
    }),
    requiredFloatValue: t.expose("requiredFloatValue", {
      type: "Float",
      nullable: false,
      extensions: {
        protobufField: { name: "required_float_value", typeFullName: "float" },
      },
    }),
    requiredInt32Value: t.expose("requiredInt32Value", {
      type: "Int",
      nullable: false,
      extensions: {
        protobufField: { name: "required_int32_value", typeFullName: "int32" },
      },
    }),
    requiredInt64Value: t.expose("requiredInt64Value", {
      type: "Int",
      nullable: false,
      extensions: {
        protobufField: { name: "required_int64_value", typeFullName: "int64" },
      },
    }),
    requiredUint32Value: t.expose("requiredUint32Value", {
      type: "Int",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_uint32_value",
          typeFullName: "uint32",
        },
      },
    }),
    requiredUint64Value: t.expose("requiredUint64Value", {
      type: "Int",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_uint64_value",
          typeFullName: "uint64",
        },
      },
    }),
    requiredSint32Value: t.expose("requiredSint32Value", {
      type: "Int",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_sint32_value",
          typeFullName: "sint32",
        },
      },
    }),
    requiredSint64Value: t.expose("requiredSint64Value", {
      type: "Int",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_sint64_value",
          typeFullName: "sint64",
        },
      },
    }),
    requiredFixed32Value: t.expose("requiredFixed32Value", {
      type: "Int",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_fixed32_value",
          typeFullName: "fixed32",
        },
      },
    }),
    requiredFixed64Value: t.expose("requiredFixed64Value", {
      type: "Int",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_fixed64_value",
          typeFullName: "fixed64",
        },
      },
    }),
    requiredSfixed32Value: t.expose("requiredSfixed32Value", {
      type: "Int",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_sfixed32_value",
          typeFullName: "sfixed32",
        },
      },
    }),
    requiredSfixed64Value: t.expose("requiredSfixed64Value", {
      type: "Int",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_sfixed64_value",
          typeFullName: "sfixed64",
        },
      },
    }),
    requiredBoolValue: t.expose("requiredBoolValue", {
      type: "Boolean",
      nullable: false,
      extensions: {
        protobufField: { name: "required_bool_value", typeFullName: "bool" },
      },
    }),
    requiredStringValue: t.expose("requiredStringValue", {
      type: "String",
      nullable: false,
      extensions: {
        protobufField: {
          name: "required_string_value",
          typeFullName: "string",
        },
      },
    }),
    requiredBytesValue: t.field({
      type: "Byte",
      nullable: false,
      resolve: (source) => {
        return Buffer.from(source.requiredBytesValue);
      },
      extensions: {
        protobufField: { name: "required_bytes_value", typeFullName: "bytes" },
      },
    }),
    requiredDoubleValues: t.expose("requiredDoubleValues", {
      type: ["Float"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: {
          name: "required_double_values",
          typeFullName: "double",
        },
      },
    }),
    requiredFloatValues: t.expose("requiredFloatValues", {
      type: ["Float"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: { name: "required_float_values", typeFullName: "float" },
      },
    }),
    requiredInt32Values: t.expose("requiredInt32Values", {
      type: ["Int"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: { name: "required_int32_values", typeFullName: "int32" },
      },
    }),
    requiredInt64Values: t.expose("requiredInt64Values", {
      type: ["Int"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: { name: "required_int64_values", typeFullName: "int64" },
      },
    }),
    requiredUint32Values: t.expose("requiredUint32Values", {
      type: ["Int"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: {
          name: "required_uint32_values",
          typeFullName: "uint32",
        },
      },
    }),
    requiredUint64Values: t.expose("requiredUint64Values", {
      type: ["Int"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: {
          name: "required_uint64_values",
          typeFullName: "uint64",
        },
      },
    }),
    requiredSint32Values: t.expose("requiredSint32Values", {
      type: ["Int"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: {
          name: "required_sint32_values",
          typeFullName: "sint32",
        },
      },
    }),
    requiredSint64Values: t.expose("requiredSint64Values", {
      type: ["Int"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: {
          name: "required_sint64_values",
          typeFullName: "sint64",
        },
      },
    }),
    requiredFixed32Values: t.expose("requiredFixed32Values", {
      type: ["Int"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: {
          name: "required_fixed32_values",
          typeFullName: "fixed32",
        },
      },
    }),
    requiredFixed64Values: t.expose("requiredFixed64Values", {
      type: ["Int"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: {
          name: "required_fixed64_values",
          typeFullName: "fixed64",
        },
      },
    }),
    requiredSfixed32Values: t.expose("requiredSfixed32Values", {
      type: ["Int"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: {
          name: "required_sfixed32_values",
          typeFullName: "sfixed32",
        },
      },
    }),
    requiredSfixed64Values: t.expose("requiredSfixed64Values", {
      type: ["Int"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: {
          name: "required_sfixed64_values",
          typeFullName: "sfixed64",
        },
      },
    }),
    requiredBoolValues: t.expose("requiredBoolValues", {
      type: ["Boolean"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: { name: "required_bool_values", typeFullName: "bool" },
      },
    }),
    requiredStringValues: t.expose("requiredStringValues", {
      type: ["String"],
      nullable: { list: false, items: false },
      extensions: {
        protobufField: {
          name: "required_string_values",
          typeFullName: "string",
        },
      },
    }),
    requiredBytesValues: t.field({
      type: ["Byte"],
      nullable: { list: false, items: false },
      resolve: (source) => {
        return source.requiredBytesValues.map((v) => Buffer.from(v));
      },
      extensions: {
        protobufField: { name: "required_bytes_values", typeFullName: "bytes" },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as Primitives | { $type: string & {}; }).$type ===
      "testapis.primitives.Primitives";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.primitives.Primitives",
      name: "Primitives",
      package: "testapis.primitives",
    },
  },
});

export type MessageInput$Shape = {
  requiredPrimitives: PrimitivesInput$Shape;
  optionalPrimitives?: PrimitivesInput$Shape | null;
  requiredPrimitivesList: Array<PrimitivesInput$Shape>;
  optionalPrimitivesList?: Array<PrimitivesInput$Shape> | null;
};

export const MessageInput$Ref: InputObjectRef<MessageInput$Shape> = builder
  .inputRef<MessageInput$Shape>("MessageInput").implement(
    {
      fields: (t) => ({
        requiredPrimitives: t.field({
          type: PrimitivesInput$Ref,
          required: true,
          description: "Required.",
          extensions: {
            protobufField: {
              name: "required_primitives",
              typeFullName: "testapis.primitives.Primitives",
            },
          },
        }),
        optionalPrimitives: t.field({
          type: PrimitivesInput$Ref,
          required: false,
          description: "Optional.",
          extensions: {
            protobufField: {
              name: "optional_primitives",
              typeFullName: "testapis.primitives.Primitives",
            },
          },
        }),
        requiredPrimitivesList: t.field({
          type: [PrimitivesInput$Ref],
          required: { list: true, items: true },
          description: "Required.",
          extensions: {
            protobufField: {
              name: "required_primitives_list",
              typeFullName: "testapis.primitives.Primitives",
            },
          },
        }),
        optionalPrimitivesList: t.field({
          type: [PrimitivesInput$Ref],
          required: { list: false, items: true },
          description: "Optional.",
          extensions: {
            protobufField: {
              name: "optional_primitives_list",
              typeFullName: "testapis.primitives.Primitives",
            },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.primitives.Message",
          name: "Message",
          package: "testapis.primitives",
        },
      },
    },
  );

export type PrimitivesInput$Shape = {
  requiredDoubleValue: Primitives["requiredDoubleValue"];
  requiredFloatValue: Primitives["requiredFloatValue"];
  requiredInt32Value: Primitives["requiredInt32Value"];
  requiredInt64Value: Primitives["requiredInt64Value"];
  requiredUint32Value: Primitives["requiredUint32Value"];
  requiredUint64Value: Primitives["requiredUint64Value"];
  requiredSint32Value: Primitives["requiredSint32Value"];
  requiredSint64Value: Primitives["requiredSint64Value"];
  requiredFixed32Value: Primitives["requiredFixed32Value"];
  requiredFixed64Value: Primitives["requiredFixed64Value"];
  requiredSfixed32Value: Primitives["requiredSfixed32Value"];
  requiredSfixed64Value: Primitives["requiredSfixed64Value"];
  requiredBoolValue: Primitives["requiredBoolValue"];
  requiredStringValue: Primitives["requiredStringValue"];
  requiredBytesValue: Primitives["requiredBytesValue"];
  requiredDoubleValues: Primitives["requiredDoubleValues"];
  requiredFloatValues: Primitives["requiredFloatValues"];
  requiredInt32Values: Primitives["requiredInt32Values"];
  requiredInt64Values: Primitives["requiredInt64Values"];
  requiredUint32Values: Primitives["requiredUint32Values"];
  requiredUint64Values: Primitives["requiredUint64Values"];
  requiredSint32Values: Primitives["requiredSint32Values"];
  requiredSint64Values: Primitives["requiredSint64Values"];
  requiredFixed32Values: Primitives["requiredFixed32Values"];
  requiredFixed64Values: Primitives["requiredFixed64Values"];
  requiredSfixed32Values: Primitives["requiredSfixed32Values"];
  requiredSfixed64Values: Primitives["requiredSfixed64Values"];
  requiredBoolValues: Primitives["requiredBoolValues"];
  requiredStringValues: Primitives["requiredStringValues"];
  requiredBytesValues: Primitives["requiredBytesValues"];
};

export const PrimitivesInput$Ref: InputObjectRef<PrimitivesInput$Shape> =
  builder.inputRef<PrimitivesInput$Shape>("PrimitivesInput").implement(
    {
      fields: (t) => ({
        requiredDoubleValue: t.field({
          type: "Float",
          required: true,
          extensions: {
            protobufField: {
              name: "required_double_value",
              typeFullName: "double",
            },
          },
        }),
        requiredFloatValue: t.field({
          type: "Float",
          required: true,
          extensions: {
            protobufField: {
              name: "required_float_value",
              typeFullName: "float",
            },
          },
        }),
        requiredInt32Value: t.field({
          type: "Int",
          required: true,
          extensions: {
            protobufField: {
              name: "required_int32_value",
              typeFullName: "int32",
            },
          },
        }),
        requiredInt64Value: t.field({
          type: "Int",
          required: true,
          extensions: {
            protobufField: {
              name: "required_int64_value",
              typeFullName: "int64",
            },
          },
        }),
        requiredUint32Value: t.field({
          type: "Int",
          required: true,
          extensions: {
            protobufField: {
              name: "required_uint32_value",
              typeFullName: "uint32",
            },
          },
        }),
        requiredUint64Value: t.field({
          type: "Int",
          required: true,
          extensions: {
            protobufField: {
              name: "required_uint64_value",
              typeFullName: "uint64",
            },
          },
        }),
        requiredSint32Value: t.field({
          type: "Int",
          required: true,
          extensions: {
            protobufField: {
              name: "required_sint32_value",
              typeFullName: "sint32",
            },
          },
        }),
        requiredSint64Value: t.field({
          type: "Int",
          required: true,
          extensions: {
            protobufField: {
              name: "required_sint64_value",
              typeFullName: "sint64",
            },
          },
        }),
        requiredFixed32Value: t.field({
          type: "Int",
          required: true,
          extensions: {
            protobufField: {
              name: "required_fixed32_value",
              typeFullName: "fixed32",
            },
          },
        }),
        requiredFixed64Value: t.field({
          type: "Int",
          required: true,
          extensions: {
            protobufField: {
              name: "required_fixed64_value",
              typeFullName: "fixed64",
            },
          },
        }),
        requiredSfixed32Value: t.field({
          type: "Int",
          required: true,
          extensions: {
            protobufField: {
              name: "required_sfixed32_value",
              typeFullName: "sfixed32",
            },
          },
        }),
        requiredSfixed64Value: t.field({
          type: "Int",
          required: true,
          extensions: {
            protobufField: {
              name: "required_sfixed64_value",
              typeFullName: "sfixed64",
            },
          },
        }),
        requiredBoolValue: t.field({
          type: "Boolean",
          required: true,
          extensions: {
            protobufField: {
              name: "required_bool_value",
              typeFullName: "bool",
            },
          },
        }),
        requiredStringValue: t.field({
          type: "String",
          required: true,
          extensions: {
            protobufField: {
              name: "required_string_value",
              typeFullName: "string",
            },
          },
        }),
        requiredBytesValue: t.field({
          type: "Byte",
          required: true,
          extensions: {
            protobufField: {
              name: "required_bytes_value",
              typeFullName: "bytes",
            },
          },
        }),
        requiredDoubleValues: t.field({
          type: ["Float"],
          required: { list: true, items: true },
          extensions: {
            protobufField: {
              name: "required_double_values",
              typeFullName: "double",
            },
          },
        }),
        requiredFloatValues: t.field({
          type: ["Float"],
          required: { list: true, items: true },
          extensions: {
            protobufField: {
              name: "required_float_values",
              typeFullName: "float",
            },
          },
        }),
        requiredInt32Values: t.field({
          type: ["Int"],
          required: { list: true, items: true },
          extensions: {
            protobufField: {
              name: "required_int32_values",
              typeFullName: "int32",
            },
          },
        }),
        requiredInt64Values: t.field({
          type: ["Int"],
          required: { list: true, items: true },
          extensions: {
            protobufField: {
              name: "required_int64_values",
              typeFullName: "int64",
            },
          },
        }),
        requiredUint32Values: t.field({
          type: ["Int"],
          required: { list: true, items: true },
          extensions: {
            protobufField: {
              name: "required_uint32_values",
              typeFullName: "uint32",
            },
          },
        }),
        requiredUint64Values: t.field({
          type: ["Int"],
          required: { list: true, items: true },
          extensions: {
            protobufField: {
              name: "required_uint64_values",
              typeFullName: "uint64",
            },
          },
        }),
        requiredSint32Values: t.field({
          type: ["Int"],
          required: { list: true, items: true },
          extensions: {
            protobufField: {
              name: "required_sint32_values",
              typeFullName: "sint32",
            },
          },
        }),
        requiredSint64Values: t.field({
          type: ["Int"],
          required: { list: true, items: true },
          extensions: {
            protobufField: {
              name: "required_sint64_values",
              typeFullName: "sint64",
            },
          },
        }),
        requiredFixed32Values: t.field({
          type: ["Int"],
          required: { list: true, items: true },
          extensions: {
            protobufField: {
              name: "required_fixed32_values",
              typeFullName: "fixed32",
            },
          },
        }),
        requiredFixed64Values: t.field({
          type: ["Int"],
          required: { list: true, items: true },
          extensions: {
            protobufField: {
              name: "required_fixed64_values",
              typeFullName: "fixed64",
            },
          },
        }),
        requiredSfixed32Values: t.field({
          type: ["Int"],
          required: { list: true, items: true },
          extensions: {
            protobufField: {
              name: "required_sfixed32_values",
              typeFullName: "sfixed32",
            },
          },
        }),
        requiredSfixed64Values: t.field({
          type: ["Int"],
          required: { list: true, items: true },
          extensions: {
            protobufField: {
              name: "required_sfixed64_values",
              typeFullName: "sfixed64",
            },
          },
        }),
        requiredBoolValues: t.field({
          type: ["Boolean"],
          required: { list: true, items: true },
          extensions: {
            protobufField: {
              name: "required_bool_values",
              typeFullName: "bool",
            },
          },
        }),
        requiredStringValues: t.field({
          type: ["String"],
          required: { list: true, items: true },
          extensions: {
            protobufField: {
              name: "required_string_values",
              typeFullName: "string",
            },
          },
        }),
        requiredBytesValues: t.field({
          type: ["Byte"],
          required: { list: true, items: true },
          extensions: {
            protobufField: {
              name: "required_bytes_values",
              typeFullName: "bytes",
            },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.primitives.Primitives",
          name: "Primitives",
          package: "testapis.primitives",
        },
      },
    },
  );
",
    "name": "testapis/primitives/primitives.pb.pothos.ts",
  },
]
`;

exports[`with scalar type override > maps 64bit integers to bigint > generates files from 'testapis.wktypes' 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/wktypes/well_known_types.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { builder } from "../../builder";
import { Message } from "./testapis/wktypes/well_known_types";

export const Message$Ref = builder.objectRef<Message>("Message");
builder.objectType(Message$Ref, {
  name: "Message",
  fields: (t) => ({
    timestamp: t.expose("timestamp", {
      type: "DateTime",
      nullable: true,
      extensions: {
        protobufField: {
          name: "timestamp",
          typeFullName: "google.protobuf.Timestamp",
        },
      },
    }),
    int32Value: t.expose("int32Value", {
      type: "Int",
      nullable: true,
      extensions: {
        protobufField: {
          name: "int32_value",
          typeFullName: "google.protobuf.Int32Value",
        },
      },
    }),
    int64Value: t.expose("int64Value", {
      type: "Int",
      nullable: true,
      extensions: {
        protobufField: {
          name: "int64_value",
          typeFullName: "google.protobuf.Int64Value",
        },
      },
    }),
    uint32Value: t.expose("uint32Value", {
      type: "Int",
      nullable: true,
      extensions: {
        protobufField: {
          name: "uint32_value",
          typeFullName: "google.protobuf.UInt32Value",
        },
      },
    }),
    uint64Value: t.expose("uint64Value", {
      type: "Int",
      nullable: true,
      extensions: {
        protobufField: {
          name: "uint64_value",
          typeFullName: "google.protobuf.UInt64Value",
        },
      },
    }),
    floatValue: t.expose("floatValue", {
      type: "Float",
      nullable: true,
      extensions: {
        protobufField: {
          name: "float_value",
          typeFullName: "google.protobuf.FloatValue",
        },
      },
    }),
    doubleValue: t.expose("doubleValue", {
      type: "Float",
      nullable: true,
      extensions: {
        protobufField: {
          name: "double_value",
          typeFullName: "google.protobuf.DoubleValue",
        },
      },
    }),
    boolValue: t.expose("boolValue", {
      type: "Boolean",
      nullable: true,
      extensions: {
        protobufField: {
          name: "bool_value",
          typeFullName: "google.protobuf.BoolValue",
        },
      },
    }),
    stringValue: t.expose("stringValue", {
      type: "String",
      nullable: true,
      extensions: {
        protobufField: {
          name: "string_value",
          typeFullName: "google.protobuf.StringValue",
        },
      },
    }),
    bytesValue: t.field({
      type: "Byte",
      nullable: true,
      resolve: (source) => {
        return source.bytesValue == null
          ? null
          : Buffer.from(source.bytesValue);
      },
      extensions: {
        protobufField: {
          name: "bytes_value",
          typeFullName: "google.protobuf.BytesValue",
        },
      },
    }),
    requiredTimestamp: t.field({
      type: "DateTime",
      nullable: false,
      description: "Required.",
      resolve: (source) => {
        return source.requiredTimestamp!;
      },
      extensions: {
        protobufField: {
          name: "required_timestamp",
          typeFullName: "google.protobuf.Timestamp",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as Message | { $type: string & {}; }).$type ===
      "testapis.wktypes.Message";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.wktypes.Message",
      name: "Message",
      package: "testapis.wktypes",
    },
  },
});

export type MessageInput$Shape = {
  timestamp?: Message["timestamp"] | null;
  int32Value?: Message["int32Value"] | null;
  int64Value?: Message["int64Value"] | null;
  uint32Value?: Message["uint32Value"] | null;
  uint64Value?: Message["uint64Value"] | null;
  floatValue?: Message["floatValue"] | null;
  doubleValue?: Message["doubleValue"] | null;
  boolValue?: Message["boolValue"] | null;
  stringValue?: Message["stringValue"] | null;
  bytesValue?: Message["bytesValue"] | null;
  requiredTimestamp: NonNullable<Message["requiredTimestamp"]>;
};

export const MessageInput$Ref: InputObjectRef<MessageInput$Shape> = builder
  .inputRef<MessageInput$Shape>("MessageInput").implement(
    {
      fields: (t) => ({
        timestamp: t.field({
          type: "DateTime",
          required: false,
          extensions: {
            protobufField: {
              name: "timestamp",
              typeFullName: "google.protobuf.Timestamp",
            },
          },
        }),
        int32Value: t.field({
          type: "Int",
          required: false,
          extensions: {
            protobufField: {
              name: "int32_value",
              typeFullName: "google.protobuf.Int32Value",
            },
          },
        }),
        int64Value: t.field({
          type: "Int",
          required: false,
          extensions: {
            protobufField: {
              name: "int64_value",
              typeFullName: "google.protobuf.Int64Value",
            },
          },
        }),
        uint32Value: t.field({
          type: "Int",
          required: false,
          extensions: {
            protobufField: {
              name: "uint32_value",
              typeFullName: "google.protobuf.UInt32Value",
            },
          },
        }),
        uint64Value: t.field({
          type: "Int",
          required: false,
          extensions: {
            protobufField: {
              name: "uint64_value",
              typeFullName: "google.protobuf.UInt64Value",
            },
          },
        }),
        floatValue: t.field({
          type: "Float",
          required: false,
          extensions: {
            protobufField: {
              name: "float_value",
              typeFullName: "google.protobuf.FloatValue",
            },
          },
        }),
        doubleValue: t.field({
          type: "Float",
          required: false,
          extensions: {
            protobufField: {
              name: "double_value",
              typeFullName: "google.protobuf.DoubleValue",
            },
          },
        }),
        boolValue: t.field({
          type: "Boolean",
          required: false,
          extensions: {
            protobufField: {
              name: "bool_value",
              typeFullName: "google.protobuf.BoolValue",
            },
          },
        }),
        stringValue: t.field({
          type: "String",
          required: false,
          extensions: {
            protobufField: {
              name: "string_value",
              typeFullName: "google.protobuf.StringValue",
            },
          },
        }),
        bytesValue: t.field({
          type: "Byte",
          required: false,
          extensions: {
            protobufField: {
              name: "bytes_value",
              typeFullName: "google.protobuf.BytesValue",
            },
          },
        }),
        requiredTimestamp: t.field({
          type: "DateTime",
          required: true,
          description: "Required.",
          extensions: {
            protobufField: {
              name: "required_timestamp",
              typeFullName: "google.protobuf.Timestamp",
            },
          },
        }),
      }),
      extensions: {
        protobufMessage: {
          fullName: "testapis.wktypes.Message",
          name: "Message",
          package: "testapis.wktypes",
        },
      },
    },
  );
",
    "name": "testapis/wktypes/well_known_types.pb.pothos.ts",
  },
]
`;

exports[`with scalar type override > maps testapis.custom_types.Date to Date scalar 1`] = `
[
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/custom_types/date.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { builder } from "../../builder";
import { Date } from "./testapis/custom_types/date";

export const Date$Ref = builder.objectRef<Date>("Date");
builder.objectType(Date$Ref, {
  name: "Date",
  fields: (t) => ({
    year: t.expose("year", {
      type: "Int",
      nullable: false,
      extensions: { protobufField: { name: "year", typeFullName: "uint32" } },
    }),
    month: t.expose("month", {
      type: "Int",
      nullable: false,
      extensions: { protobufField: { name: "month", typeFullName: "uint32" } },
    }),
    day: t.expose("day", {
      type: "Int",
      nullable: false,
      extensions: { protobufField: { name: "day", typeFullName: "uint32" } },
    }),
  }),
  isTypeOf: (source) => {
    return (source as Date | { $type: string & {}; }).$type ===
      "testapis.custom_types.Date";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.custom_types.Date",
      name: "Date",
      package: "testapis.custom_types",
    },
  },
});

export type DateInput$Shape = {
  year: Date["year"];
  month: Date["month"];
  day: Date["day"];
};

export const DateInput$Ref: InputObjectRef<DateInput$Shape> = builder.inputRef<
  DateInput$Shape
>("DateInput").implement(
  {
    fields: (t) => ({
      year: t.field({
        type: "Int",
        required: true,
        extensions: { protobufField: { name: "year", typeFullName: "uint32" } },
      }),
      month: t.field({
        type: "Int",
        required: true,
        extensions: {
          protobufField: { name: "month", typeFullName: "uint32" },
        },
      }),
      day: t.field({
        type: "Int",
        required: true,
        extensions: { protobufField: { name: "day", typeFullName: "uint32" } },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.custom_types.Date",
        name: "Date",
        package: "testapis.custom_types",
      },
    },
  },
);
",
    "name": "testapis/custom_types/date.pb.pothos.ts",
  },
  {
    "content": "// Code generated by protoc-gen-pothos. DO NOT EDIT.
// source: testapis/custom_types/post.proto

/* eslint-disable */

import { InputObjectRef } from "@pothos/core";
import { builder } from "../../builder";
import { Post } from "./testapis/custom_types/post";

export const Post$Ref = builder.objectRef<Post>("Post");
builder.objectType(Post$Ref, {
  name: "Post",
  fields: (t) => ({
    title: t.expose("title", {
      type: "String",
      nullable: false,
      description: "Required.",
      extensions: { protobufField: { name: "title", typeFullName: "string" } },
    }),
    publishedDate: t.expose("publishedDate", {
      type: "Date",
      nullable: true,
      description: "Optional.",
      extensions: {
        protobufField: {
          name: "published_date",
          typeFullName: "testapis.custom_types.Date",
        },
      },
    }),
  }),
  isTypeOf: (source) => {
    return (source as Post | { $type: string & {}; }).$type ===
      "testapis.custom_types.Post";
  },
  extensions: {
    protobufMessage: {
      fullName: "testapis.custom_types.Post",
      name: "Post",
      package: "testapis.custom_types",
    },
  },
});

export type PostInput$Shape = {
  title: Post["title"];
  publishedDate?: Post["publishedDate"] | null;
};

export const PostInput$Ref: InputObjectRef<PostInput$Shape> = builder.inputRef<
  PostInput$Shape
>("PostInput").implement(
  {
    fields: (t) => ({
      title: t.field({
        type: "String",
        required: true,
        description: "Required.",
        extensions: {
          protobufField: { name: "title", typeFullName: "string" },
        },
      }),
      publishedDate: t.field({
        type: "Date",
        required: false,
        description: "Optional.",
        extensions: {
          protobufField: {
            name: "published_date",
            typeFullName: "testapis.custom_types.Date",
          },
        },
      }),
    }),
    extensions: {
      protobufMessage: {
        fullName: "testapis.custom_types.Post",
        name: "Post",
        package: "testapis.custom_types",
      },
    },
  },
);
",
    "name": "testapis/custom_types/post.pb.pothos.ts",
  },
]
`;
