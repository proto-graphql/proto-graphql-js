import dprint from "dprint-node";
import { printToString } from "./helpers.js";
import type { Printable } from "./types.js";
import { isImportSymbol } from "./types.js";

/**
 * Collect all ImportSymbols from Printable array.
 * Returns a Map of module path -> Set of symbol names.
 */
export function collectImports(
  printables: Printable[],
): Map<string, Set<string>> {
  const imports = new Map<string, Set<string>>();

  function visit(p: Printable) {
    if (isImportSymbol(p)) {
      const symbols = imports.get(p.from) ?? new Set();
      symbols.add(p.name);
      imports.set(p.from, symbols);
    } else if (Array.isArray(p)) {
      for (const item of p) {
        visit(item);
      }
    }
  }

  for (const p of printables) {
    visit(p);
  }

  return imports;
}

/**
 * Check if import path is a relative path.
 */
function isRelativePath(path: string): boolean {
  return path.startsWith("./") || path.startsWith("../");
}

/**
 * Generate import statements from collected imports.
 * Sorts imports: external packages first, then relative paths.
 * Within each group, sorts alphabetically.
 */
export function generateImportStatements(
  imports: Map<string, Set<string>>,
): string {
  if (imports.size === 0) {
    return "";
  }

  const lines: string[] = [];

  // Sort by path: external packages first, then relative paths
  const sortedEntries = [...imports.entries()].sort(([a], [b]) => {
    const aIsRelative = isRelativePath(a);
    const bIsRelative = isRelativePath(b);

    // External packages come before relative paths
    if (aIsRelative !== bIsRelative) {
      return aIsRelative ? 1 : -1;
    }

    // Within same group, sort alphabetically
    return a.localeCompare(b);
  });

  for (const [path, symbols] of sortedEntries) {
    // Sort symbols alphabetically
    const sortedSymbols = [...symbols].sort();
    lines.push(`import { ${sortedSymbols.join(", ")} } from "${path}";`);
  }

  return lines.join("\n");
}

export interface StringifyOptions {
  programName: string;
  fileName: string;
}

/**
 * Convert Printable[] to formatted TypeScript code string.
 * Handles import collection, generation, and code formatting.
 */
export function stringifyPrintables(
  printables: Printable[],
  options: StringifyOptions,
): string {
  const header = `// Code generated by ${options.programName}. DO NOT EDIT.
// source: ${options.fileName}

/* eslint-disable */

`;

  if (printables.length === 0) {
    return `${header}export {};
`;
  }

  const imports = collectImports(printables);
  const importStatements = generateImportStatements(imports);
  const body = printToString(printables);

  const parts: string[] = [header];

  if (importStatements) {
    parts.push(importStatements);
    parts.push("\n\n");
  }

  parts.push(body);

  // Ensure trailing newline
  let result = parts.join("");
  if (!result.endsWith("\n")) {
    result += "\n";
  }

  return formatCode(result);
}

export function formatCode(code: string): string {
  return dprint.format("file.ts", code, {
    lineWidth: 80,
    indentWidth: 2,
    useTabs: false,
    semiColons: "always",
    quoteStyle: "preferDouble",
    quoteProps: "asNeeded",
    newLineKind: "lf",
    useBraces: "whenNotSingleLine",
    bracePosition: "sameLineUnlessHanging",
    singleBodyPosition: "maintain",
    nextControlFlowPosition: "sameLine",
    trailingCommas: "onlyMultiLine",
    operatorPosition: "nextLine",
    preferHanging: false,
    "arrowFunction.useParentheses": "force",
  });
}
