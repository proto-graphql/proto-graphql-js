import type { ImportSymbol, Printable } from "./types.js";

function isImportSymbol(value: unknown): value is ImportSymbol {
  return (
    typeof value === "object" &&
    value !== null &&
    "kind" in value &&
    (value as Record<string, unknown>).kind === "es_symbol"
  );
}

/**
 * Collect all ImportSymbols from Printable array.
 * Returns a Map of module path -> Set of symbol names.
 */
export function collectImports(
  printables: Printable[]
): Map<string, Set<string>> {
  const imports = new Map<string, Set<string>>();

  function visit(p: Printable) {
    if (isImportSymbol(p)) {
      const symbols = imports.get(p.from) ?? new Set();
      symbols.add(p.name);
      imports.set(p.from, symbols);
    } else if (Array.isArray(p)) {
      for (const item of p) {
        visit(item);
      }
    }
  }

  for (const p of printables) {
    visit(p);
  }

  return imports;
}

/**
 * Check if import path is a relative path.
 */
function isRelativePath(path: string): boolean {
  return path.startsWith("./") || path.startsWith("../");
}

/**
 * Generate import statements from collected imports.
 * Sorts imports: external packages first, then relative paths.
 * Within each group, sorts alphabetically.
 */
export function generateImportStatements(
  imports: Map<string, Set<string>>
): string {
  if (imports.size === 0) {
    return "";
  }

  const lines: string[] = [];

  // Sort by path: external packages first, then relative paths
  const sortedPaths = [...imports.keys()].sort((a, b) => {
    const aIsRelative = isRelativePath(a);
    const bIsRelative = isRelativePath(b);

    // External packages come before relative paths
    if (aIsRelative !== bIsRelative) {
      return aIsRelative ? 1 : -1;
    }

    // Within same group, sort alphabetically
    return a.localeCompare(b);
  });

  for (const path of sortedPaths) {
    const symbols = imports.get(path)!;
    // Sort symbols alphabetically
    const sortedSymbols = [...symbols].sort();
    lines.push(`import { ${sortedSymbols.join(", ")} } from "${path}";`);
  }

  return lines.join("\n");
}

/**
 * Convert Printable array to code body string (without imports).
 * ImportSymbols are replaced with their names.
 */
function printablesToBody(printables: Printable[]): string {
  const parts: string[] = [];

  function visit(p: Printable) {
    if (typeof p === "string") {
      parts.push(p);
    } else if (isImportSymbol(p)) {
      parts.push(p.name);
    } else if (Array.isArray(p)) {
      for (const item of p) {
        visit(item);
      }
    }
  }

  for (const p of printables) {
    visit(p);
  }

  return parts.join("");
}

export interface StringifyOptions {
  programName: string;
  fileName: string;
}

/**
 * Convert Printable[] to formatted TypeScript code string.
 * Handles import collection, generation, and code formatting.
 */
export function stringifyPrintables(
  printables: Printable[],
  options: StringifyOptions
): string {
  const header = `// Code generated by ${options.programName}. DO NOT EDIT.
// source: ${options.fileName}

/* eslint-disable */

`;

  if (printables.length === 0) {
    return `${header}export {};
`;
  }

  const imports = collectImports(printables);
  const importStatements = generateImportStatements(imports);
  const body = printablesToBody(printables);

  const parts: string[] = [header];

  if (importStatements) {
    parts.push(importStatements);
    parts.push("\n\n");
  }

  parts.push(body);

  // Ensure trailing newline
  let result = parts.join("");
  if (!result.endsWith("\n")) {
    result += "\n";
  }

  return result;
}
