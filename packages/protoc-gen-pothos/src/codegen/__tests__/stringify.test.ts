import { describe, expect, it } from "vitest";
import {
  collectImports,
  generateImportStatements,
  stringifyPrintables,
} from "../stringify.js";
import type { Printable } from "../types.js";
import { createImportSymbol } from "../types.js";

describe("collectImports", () => {
  it("returns empty map for empty array", () => {
    const result = collectImports([]);
    expect(result.size).toBe(0);
  });

  it("returns empty map for array with only strings", () => {
    const result = collectImports(["const x = 1;", "const y = 2;"]);
    expect(result.size).toBe(0);
  });

  it("collects single import symbol", () => {
    const symbol = createImportSymbol("Foo", "@pothos/core");
    const result = collectImports([symbol]);
    expect(result.size).toBe(1);
    expect(result.get("@pothos/core")).toEqual(new Set(["Foo"]));
  });

  it("collects multiple symbols from same module", () => {
    const foo = createImportSymbol("Foo", "@pothos/core");
    const bar = createImportSymbol("Bar", "@pothos/core");
    const result = collectImports([foo, " ", bar]);
    expect(result.size).toBe(1);
    expect(result.get("@pothos/core")).toEqual(new Set(["Foo", "Bar"]));
  });

  it("collects symbols from different modules", () => {
    const foo = createImportSymbol("Foo", "@pothos/core");
    const msg = createImportSymbol("Message", "./types_pb");
    const result = collectImports([foo, " ", msg]);
    expect(result.size).toBe(2);
    expect(result.get("@pothos/core")).toEqual(new Set(["Foo"]));
    expect(result.get("./types_pb")).toEqual(new Set(["Message"]));
  });

  it("handles nested arrays (Printable[])", () => {
    const foo = createImportSymbol("Foo", "@pothos/core");
    const bar = createImportSymbol("Bar", "@pothos/core");
    const nested: Printable[] = ["const x = ", foo, ";"];
    const result = collectImports([nested, " ", bar]);
    expect(result.size).toBe(1);
    expect(result.get("@pothos/core")).toEqual(new Set(["Foo", "Bar"]));
  });

  it("handles symbols with $ in name", () => {
    const ref = createImportSymbol("Message$Ref", "./types_pb");
    const result = collectImports([ref]);
    expect(result.size).toBe(1);
    expect(result.get("./types_pb")).toEqual(new Set(["Message$Ref"]));
  });

  it("deduplicates same symbol from same module", () => {
    const foo1 = createImportSymbol("Foo", "@pothos/core");
    const foo2 = createImportSymbol("Foo", "@pothos/core");
    const result = collectImports([foo1, " ", foo2]);
    expect(result.size).toBe(1);
    expect(result.get("@pothos/core")).toEqual(new Set(["Foo"]));
  });
});

describe("generateImportStatements", () => {
  it("returns empty string for empty map", () => {
    const result = generateImportStatements(new Map());
    expect(result).toBe("");
  });

  it("generates single import statement", () => {
    const imports = new Map<string, Set<string>>([
      ["@pothos/core", new Set(["Foo"])],
    ]);
    const result = generateImportStatements(imports);
    expect(result).toBe('import { Foo } from "@pothos/core";');
  });

  it("generates import with multiple symbols sorted alphabetically", () => {
    const imports = new Map<string, Set<string>>([
      ["@pothos/core", new Set(["Foo", "Bar", "Baz"])],
    ]);
    const result = generateImportStatements(imports);
    expect(result).toBe('import { Bar, Baz, Foo } from "@pothos/core";');
  });

  it("generates multiple import statements sorted by path", () => {
    const imports = new Map<string, Set<string>>([
      ["./types_pb", new Set(["Message"])],
      ["@pothos/core", new Set(["Foo"])],
    ]);
    const result = generateImportStatements(imports);
    expect(result).toBe(
      'import { Foo } from "@pothos/core";\nimport { Message } from "./types_pb";',
    );
  });

  it("handles symbols with $ in name", () => {
    const imports = new Map<string, Set<string>>([
      ["./types_pb", new Set(["Message$Ref", "Message$Shape"])],
    ]);
    const result = generateImportStatements(imports);
    expect(result).toBe(
      'import { Message$Ref, Message$Shape } from "./types_pb";',
    );
  });
});

describe("stringifyPrintables", () => {
  it("returns empty export for empty array", () => {
    const result = stringifyPrintables([], {
      programName: "test",
      fileName: "test.proto",
    });
    expect(result).toContain("// Code generated by test. DO NOT EDIT.");
    expect(result).toContain("// source: test.proto");
    expect(result).toContain("export {};");
  });

  it("stringifies simple code without imports", () => {
    const result = stringifyPrintables(["const x = 1;"], {
      programName: "test",
      fileName: "test.proto",
    });
    expect(result).toContain("const x = 1;");
    expect(result).not.toContain("import");
  });

  it("stringifies code with imports", () => {
    const foo = createImportSymbol("Foo", "@pothos/core");
    const result = stringifyPrintables(["const x: ", foo, " = null;"], {
      programName: "test",
      fileName: "test.proto",
    });
    expect(result).toContain('import { Foo } from "@pothos/core";');
    expect(result).toContain("const x: Foo = null;");
  });

  it("handles multiple Printable[] arrays", () => {
    const foo = createImportSymbol("Foo", "@pothos/core");
    const bar = createImportSymbol("Bar", "@pothos/core");
    const printables: Printable[][] = [
      ["const x: ", foo, " = null;"],
      ["const y: ", bar, " = null;"],
    ];
    const result = stringifyPrintables(printables.flat(), {
      programName: "test",
      fileName: "test.proto",
    });
    expect(result).toContain('import { Bar, Foo } from "@pothos/core";');
    expect(result).toContain("const x: Foo = null;");
    expect(result).toContain("const y: Bar = null;");
  });

  it("handles symbols with $ in name", () => {
    const ref = createImportSymbol("Message$Ref", "./types_pb");
    const result = stringifyPrintables(["const ref = ", ref, ";"], {
      programName: "test",
      fileName: "test.proto",
    });
    expect(result).toContain('import { Message$Ref } from "./types_pb";');
    expect(result).toContain("const ref = Message$Ref;");
  });

  it("includes header comment with eslint disable", () => {
    const result = stringifyPrintables(["const x = 1;"], {
      programName: "protoc-gen-pothos",
      fileName: "example.proto",
    });
    expect(result).toContain(
      "// Code generated by protoc-gen-pothos. DO NOT EDIT.",
    );
    expect(result).toContain("// source: example.proto");
    expect(result).toContain("/* eslint-disable */");
  });

  it("formats code with proper indentation", () => {
    const result = stringifyPrintables(
      [
        'const obj = { aaaa: 1, bbbb: 2, cccc: 3, dddd: 4, eeee: 5, ffff: 6, gggg: 7, hhhh: 8, iiii: 9, jjjj: 10, kkkk: 11, llll: 12, mmmm: 13 };',
      ],
      {
        programName: "test",
        fileName: "test.proto",
      },
    );
    expect(result).toContain("const obj = {");
    expect(result).toMatch(/\n\s+aaaa: 1,/);
  });

  it("formats long lines by breaking them", () => {
    const result = stringifyPrintables(
      [
        'builder.objectType(Ref, { "name": "Foo", "fields": t => ({field1: t.expose("field1", { "type": "String" }),field2: t.expose("field2", { "type": "Int" }),}) });',
      ],
      {
        programName: "test",
        fileName: "test.proto",
      },
    );
    expect(result).toMatch(/\n\s+name:/);
    expect(result).toMatch(/\n\s+fields:/);
  });
});
